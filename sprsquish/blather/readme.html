<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="style.css" type="text/css" charset="utf-8" />
<link rel="stylesheet" href="syntax_highlight.css" type="text/css" charset="utf-8" />

    <title>README</title>
  </head>
  <body>
    <div id="content">
      <div class="section docstring readme">
        <h1>Blather</h1>
<p>
An evented XMPP library
</p>
<h2>Features</h2>
<ul>
<li>evented architecture

</li>
<li>uses libxml

</li>
<li>simplified starting point

</li>
</ul>
<h2>Project Pages</h2>
<table>
<tr><td valign="top">GitHub:</td><td>https://github.com/sprsquish/blather

</td></tr>
<tr><td valign="top">RubyForge:</td><td>http://rubyforge.org/projects/squishtech/

</td></tr>
</table>
<h2>Author</h2>
<p>
Jeff Smick &lt;sprsquish@gmail.com&gt;
</p>
<h1>Usage</h1>
<h2>Installation</h2>
<pre class="code">
  <span class='sudo identifier id'>sudo</span> <span class='gem identifier id'>gem</span> <span class='install identifier id'>install</span> <span class='blather identifier id'>blather</span>
</pre>
<h2>Example</h2>
<p>
See the /examples directory for more advanced examples.
</p>
<p>
This will auto-accept any subscription requests and echo back any chat
messages.
</p>
<pre class="code">
  <span class='require identifier id'>require</span> <span class='string val'>'rubygems'</span>
  <span class='require identifier id'>require</span> <span class='string val'>'blather/client'</span>

  <span class='setup identifier id'>setup</span> <span class='string val'>'echo@jabber.local'</span><span class='comma token'>,</span> <span class='string val'>'echo'</span>

  <span class='comment val'># Auto approve subscription requests</span>
  <span class='subscription identifier id'>subscription</span> <span class='symbol val'>:request?</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='s identifier id'>s</span><span class='bitor op'>|</span>
    <span class='write identifier id'>write</span> <span class='s identifier id'>s</span><span class='dot token'>.</span><span class='approve! fid id'>approve!</span>
  <span class='end end kw'>end</span>

  <span class='comment val'># Echo back what was said</span>
  <span class='message identifier id'>message</span> <span class='symbol val'>:chat?</span><span class='comma token'>,</span> <span class='symbol val'>:body</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='m identifier id'>m</span><span class='bitor op'>|</span>
    <span class='write identifier id'>write</span> <span class='m identifier id'>m</span><span class='dot token'>.</span><span class='reply identifier id'>reply</span>
  <span class='end end kw'>end</span>
</pre>
<h2>Handlers</h2>
<p>
Setup handlers by calling their names as methods.
</p>
<pre class="code">
  <span class='comment val'># Will only be called for messages where #chat? responds positively</span>
  <span class='comment val'># and #body == 'exit'</span>
  <span class='message identifier id'>message</span> <span class='symbol val'>:chat?</span><span class='comma token'>,</span> <span class='symbol val'>:body</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'exit'</span>
</pre>
<h3>Handler Guards</h3>
<p>
Guards act like AND statements. Each condition must be met if the handler
is to be used.
</p>
<pre class="code">
  <span class='comment val'># Equivalent to saying (stanza.chat? &amp;&amp; stanza.body)</span>
  <span class='message identifier id'>message</span> <span class='symbol val'>:chat?</span><span class='comma token'>,</span> <span class='symbol val'>:body</span>
</pre>
<p>
There are 5 different types of guards:
</p>
<pre class="code">
  <span class='comment val'># Symbol</span>
  <span class='comment val'>#   Checks for a non-false reply to calling the symbol on the stanza</span>
  <span class='comment val'>#   Equivalent to stanza.chat?</span>
  <span class='message identifier id'>message</span> <span class='symbol val'>:chat?</span>

  <span class='comment val'># Hash with string (:body =&gt; 'exit')</span>
  <span class='comment val'>#   Calls the key on the stanza and checks for equality</span>
  <span class='comment val'>#   Equivalent to stanza.body == 'exit'</span>
  <span class='message identifier id'>message</span> <span class='symbol val'>:body</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'exit'</span>

  <span class='comment val'># Hash with regular expression (:body =&gt; /exit/)</span>
  <span class='comment val'>#   Calls the key on the stanza and checks for a match</span>
  <span class='comment val'>#   Equivalent to stanza.body.match /exit/</span>
  <span class='message identifier id'>message</span> <span class='symbol val'>:body</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='regexp val'>/exit/</span>

  <span class='comment val'># Proc</span>
  <span class='comment val'>#   Calls the proc passing in the stanza</span>
  <span class='comment val'>#   Checks that the ID is modulo 3</span>
  <span class='message identifier id'>message</span> <span class='proc identifier id'>proc</span> <span class='lbrace token'>{</span> <span class='bitor op'>|</span><span class='m identifier id'>m</span><span class='bitor op'>|</span> <span class='m identifier id'>m</span><span class='dot token'>.</span><span class='id identifier id'>id</span> <span class='mod op'>%</span> <span class='integer val'>3</span> <span class='eq op'>==</span> <span class='integer val'>0</span> <span class='rbrace token'>}</span>

  <span class='comment val'># Array</span>
  <span class='comment val'>#   Use arrays with the previous types effectively turns the guard into</span>
  <span class='comment val'>#   an OR statement.</span>
  <span class='comment val'>#   Equivalent to stanza.body == 'foo' || stanza.body == 'baz'</span>
  <span class='message identifier id'>message</span> <span class='lbrack token'>[</span><span class='lbrace token'>{</span><span class='symbol val'>:body</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'foo'</span><span class='rbrace token'>}</span><span class='comma token'>,</span> <span class='lbrace token'>{</span><span class='symbol val'>:body</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'baz'</span><span class='rbrace token'>}</span><span class='rbrack token'>]</span>
</pre>
<h1>TODO</h1>
<ul>
<li>Cleanup API

</li>
<li>Add lambda callback ability to Iq stanzas

</li>
<li>Better Documentation

</li>
<li>Service Discovery (XEP-0030: http://xmpp.org/extensions/xep-0030.html)

</li>
<li>PubSub (XEP-0060: http://xmpp.org/extensions/xep-0060.html)

</li>
<li>More examples (Re-write XMPP4R examples into Blather)

</li>
</ul>
<h1>License</h1>
<p>
Please see LICENSE The LibXML-Ruby license can be found in its directory
</p>

      </div>
    </div>
  </body>
</html>