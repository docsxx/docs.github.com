<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="../style.css" type="text/css" charset="utf-8" />
<link rel="stylesheet" href="../syntax_highlight.css" type="text/css" charset="utf-8" />

    <script src="../jquery.js" type="text/javascript" charset="utf-8"></script>
    <script src="../app.js" type="text/javascript" charset="utf-8"></script>
    <title>Class: MQ::Exchange</title>
  </head>
  <body>
    <div id="content">
      <div class="section class MQ_Exchange">
  <h1 class="title">Class: MQ::Exchange</h1>
  <div class="section mixins">
  <h1>Included Modules</h1>
  <p><a href='Exchange/AMQP.html' title='AMQP'>AMQP</a></p>
</div><div class="section docstring">
  <p>
An Exchange acts as an ingress point for all published messages. An
exchange may also be described as a router or a matcher. Every published
message is received by an exchange which, depending on its type (described
below), determines how to deliver the message.
</p>
<p>
It determines the next delivery hop by examining the bindings associated
with the exchange.
</p>
<p>
There are three (3) supported Exchange types: direct, fanout and topic.
</p>
<p>
As part of the standard, the server <em>must</em> predeclare the direct
exchange &#8216;amq.direct&#8217; and the fanout exchange
&#8216;amq.fanout&#8217; (all exchange names starting with
&#8216;amq.&#8217; are reserved). Attempts to declare an exchange using
&#8216;amq.&#8217; as the name will raise an MQ:Error and fail. In practice
these default exchanges are never used directly by client code.
</p>
<p>
These predececlared exchanges are used when the client code declares an
exchange without a name. In these cases the library will use the default
exchange for publishing the messages.
</p>

</div><div class="section attributes">
  <h1>Attributes</h1>

  
    <div class="instance">
      <h2>Instance Attributes</h2>
      <table>
      
        <tr>
          <th class="name">key</td>
          <td class="readwrite">
            [<span id='key-instance_method'>R</span>W] 
          </td>
          <td class="visibility">
            public
          </td>
          <td class="docstring">
            <p>
Returns the value of attribute <tt>key</tt>.
</p>

            
          </td>
        </tr>
      
        <tr>
          <th class="name">name</td>
          <td class="readwrite">
            [<span id='name-instance_method'>R</span>W] 
          </td>
          <td class="visibility">
            public
          </td>
          <td class="docstring">
            <p>
Returns the value of attribute <tt>name</tt>.
</p>

            
          </td>
        </tr>
      
        <tr>
          <th class="name">type</td>
          <td class="readwrite">
            [<span id='type-instance_method'>R</span>W] 
          </td>
          <td class="visibility">
            public
          </td>
          <td class="docstring">
            <p>
Returns the value of attribute <tt>type</tt>.
</p>

            
          </td>
        </tr>
      
      </table>
    </div>
  
</div><div class="section constants">
  <div class="included">
  
  <div>
    <h1>Constants Included from <a href='Exchange/AMQP.html' title='AMQP'>AMQP</a></h1>
    <p><span class='name'><a href='../AMQP.html#DIR-constant' title='DIR'>DIR</a></span>, <span class='name'><a href='../AMQP.html#FIELDS-constant' title='FIELDS'>FIELDS</a></span>, <span class='name'><a href='../AMQP.html#HEADER-constant' title='HEADER'>HEADER</a></span>, <span class='name'><a href='../AMQP.html#PORT-constant' title='PORT'>PORT</a></span>, <span class='name'><a href='../AMQP.html#RESPONSES-constant' title='RESPONSES'>RESPONSES</a></span>, <span class='name'><a href='../AMQP.html#VERSION-constant' title='VERSION'>VERSION</a></span>, <span class='name'><a href='../AMQP.html#VERSION_MAJOR-constant' title='VERSION_MAJOR'>VERSION_MAJOR</a></span>, <span class='name'><a href='../AMQP.html#VERSION_MINOR-constant' title='VERSION_MINOR'>VERSION_MINOR</a></span></p>
  </div>
  
</div>
<div class="clear"></div>
</div><div class="section constructor">
<h1>Constructor Summary</h1>
  <div id="initialize-instance_method" class="section method">
  <div class="details_title">
  <div class='section methodsignature'>
  <tt class='def'>
    <span class='visibility'>public</span>
    <span class='return_types'></span>
    <span class='name'>initialize</span><span class='args'>mq, type, name, opts = {}</span>
    <span class='block'></span>
  </tt>
</div>

</div><div class="section docstring">
  <p>
Defines, intializes and returns an Exchange to act as an ingress point for
all published messages.
</p>
<p>
There are three (3) supported Exchange types: direct, fanout and topic.
</p>
<p>
As part of the standard, the server <em>must</em> predeclare the direct
exchange &#8216;amq.direct&#8217; and the fanout exchange
&#8216;amq.fanout&#8217; (all exchange names starting with
&#8216;amq.&#8217; are reserved). Attempts to declare an exchange using
&#8216;amq.&#8217; as the name will raise an MQ:Error and fail. In practice
these default exchanges are never used directly by client code.
</p>
<h2>Direct</h2>
<p>
A direct exchange is useful for 1:1 communication between a publisher and
subscriber. Messages are routed to the queue with a binding that shares the
same name as the exchange. Alternately, the messages are routed to the
bound queue that shares the same name as the routing key used for defining
the exchange. This exchange type does not honor the :key option when
defining a new instance with a name. It <em>will</em> honor the :key option
if the exchange name is the empty string. This is because an exchange
defined with the empty string uses the default pre-declared exchange called
&#8216;amq.direct&#8217;. In this case it needs to use :key to do its
matching.
</p>
<pre class="code">
 <span class='comment val'># exchange is named 'foo'</span>
 <span class='exchange identifier id'>exchange</span> <span class='assign token'>=</span> <span class='MQ constant id'>MQ</span><span class='colon2 op'>::</span><span class='Exchange constant id'>Exchange</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='MQ constant id'>MQ</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='comma token'>,</span> <span class='symbol val'>:direct</span><span class='comma token'>,</span> <span class='string val'>'foo'</span><span class='rparen token'>)</span>

 <span class='comment val'># or, the exchange can use the default name (amq.direct) and perform</span>
 <span class='comment val'># routing comparisons using the :key</span>
 <span class='exchange identifier id'>exchange</span> <span class='assign token'>=</span> <span class='MQ constant id'>MQ</span><span class='colon2 op'>::</span><span class='Exchange constant id'>Exchange</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='MQ constant id'>MQ</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='comma token'>,</span> <span class='symbol val'>:direct</span><span class='comma token'>,</span> <span class='string val'>&quot;&quot;</span><span class='comma token'>,</span> <span class='symbol val'>:key</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'foo'</span><span class='rparen token'>)</span>
 <span class='exchange identifier id'>exchange</span><span class='dot token'>.</span><span class='publish identifier id'>publish</span><span class='lparen token'>(</span><span class='string val'>'some data'</span><span class='rparen token'>)</span> <span class='comment val'># will be delivered to queue bound to 'foo'</span>

 <span class='queue identifier id'>queue</span> <span class='assign token'>=</span> <span class='MQ constant id'>MQ</span><span class='colon2 op'>::</span><span class='Queue constant id'>Queue</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='MQ constant id'>MQ</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='comma token'>,</span> <span class='string val'>'foo'</span><span class='rparen token'>)</span>
 <span class='comment val'># can receive data since the queue name and the exchange key match exactly</span>
 <span class='queue identifier id'>queue</span><span class='dot token'>.</span><span class='pop identifier id'>pop</span> <span class='lbrace token'>{</span> <span class='bitor op'>|</span><span class='data identifier id'>data</span><span class='bitor op'>|</span> <span class='puts identifier id'>puts</span> <span class='dstring node'>&quot;received data [#{data}]&quot;</span> <span class='rbrace token'>}</span>
</pre>
<h2>Fanout</h2>
<p>
A fanout exchange is useful for 1:N communication where one publisher feeds
multiple subscribers. Like direct exchanges, messages published to a fanout
exchange are delivered to queues whose name matches the exchange name (or
are bound to that exchange name). Each queue gets its own copy of the
message.
</p>
<p>
Like the direct exchange type, this exchange type does not honor the :key
option when defining a new instance with a name. It <em>will</em> honor the
:key option if the exchange name is the empty string. Fanout exchanges
defined with the empty string as the name use the default
&#8216;amq.fanout&#8217;. In this case it needs to use :key to do its
matching.
</p>
<pre class="code">
 <span class='EM constant id'>EM</span><span class='dot token'>.</span><span class='run identifier id'>run</span> <span class='do do kw'>do</span>
   <span class='clock identifier id'>clock</span> <span class='assign token'>=</span> <span class='MQ constant id'>MQ</span><span class='colon2 op'>::</span><span class='Exchange constant id'>Exchange</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='MQ constant id'>MQ</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='comma token'>,</span> <span class='symbol val'>:fanout</span><span class='comma token'>,</span> <span class='string val'>'clock'</span><span class='rparen token'>)</span>
   <span class='EM constant id'>EM</span><span class='dot token'>.</span><span class='add_periodic_timer identifier id'>add_periodic_timer</span><span class='lparen token'>(</span><span class='integer val'>1</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
     <span class='puts identifier id'>puts</span> <span class='dstring node'>&quot;\npublishing #{time = Time.now}&quot;</span>
     <span class='clock identifier id'>clock</span><span class='dot token'>.</span><span class='publish identifier id'>publish</span><span class='lparen token'>(</span><span class='Marshal constant id'>Marshal</span><span class='dot token'>.</span><span class='dump identifier id'>dump</span><span class='lparen token'>(</span><span class='time identifier id'>time</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
   <span class='end end kw'>end</span>

   <span class='comment val'># one way of defining a queue</span>
   <span class='amq identifier id'>amq</span> <span class='assign token'>=</span> <span class='MQ constant id'>MQ</span><span class='colon2 op'>::</span><span class='Queue constant id'>Queue</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='MQ constant id'>MQ</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='comma token'>,</span> <span class='string val'>'every second'</span><span class='rparen token'>)</span>
   <span class='amq identifier id'>amq</span><span class='dot token'>.</span><span class='bind identifier id'>bind</span><span class='lparen token'>(</span><span class='MQ constant id'>MQ</span><span class='dot token'>.</span><span class='fanout identifier id'>fanout</span><span class='lparen token'>(</span><span class='string val'>'clock'</span><span class='rparen token'>)</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='subscribe identifier id'>subscribe</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='time identifier id'>time</span><span class='bitor op'>|</span>
     <span class='puts identifier id'>puts</span> <span class='dstring node'>&quot;every second received #{Marshal.load(time)}&quot;</span>
   <span class='end end kw'>end</span>

   <span class='comment val'># defining a queue using the convenience method</span>
   <span class='comment val'># note the string passed to #bind</span>
   <span class='MQ constant id'>MQ</span><span class='dot token'>.</span><span class='queue identifier id'>queue</span><span class='lparen token'>(</span><span class='string val'>'every 5 seconds'</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='bind identifier id'>bind</span><span class='lparen token'>(</span><span class='string val'>'clock'</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='subscribe identifier id'>subscribe</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='time identifier id'>time</span><span class='bitor op'>|</span>
     <span class='time identifier id'>time</span> <span class='assign token'>=</span> <span class='Marshal constant id'>Marshal</span><span class='dot token'>.</span><span class='load identifier id'>load</span><span class='lparen token'>(</span><span class='time identifier id'>time</span><span class='rparen token'>)</span>
     <span class='puts identifier id'>puts</span> <span class='dstring node'>&quot;every 5 seconds received #{time}&quot;</span> <span class='if if_mod kw'>if</span> <span class='time identifier id'>time</span><span class='dot token'>.</span><span class='strftime identifier id'>strftime</span><span class='lparen token'>(</span><span class='string val'>'%S'</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='to_i identifier id'>to_i</span><span class='mod op'>%</span><span class='integer val'>5</span> <span class='eq op'>==</span> <span class='integer val'>0</span>
   <span class='end end kw'>end</span>
 <span class='end end kw'>end</span>
</pre>
<h2>Topic</h2>
<p>
A topic exchange allows for messages to be published to an exchange tagged
with a specific routing key. The Exchange uses the routing key to determine
which queues to deliver the message. Wildcard matching is allowed. The
topic must be declared using dot notation to separate each subtopic.
</p>
<p>
This is the only exchange type to honor the :key parameter.
</p>
<p>
As part of the AMQP standard, each server <em>should</em> predeclare a
topic exchange called &#8216;amq.topic&#8217; (this is not required by the
standard).
</p>
<p>
The classic example is delivering market data. When publishing market data
for stocks, we may subdivide the stream based on 2 characteristics: nation
code and trading symbol. The topic tree for Apple Computer would look like:
</p>
<pre class="code">
 <span class='string val'>'stock.us.aapl'</span>
</pre>
<p>
For a foreign stock, it may look like:
</p>
<pre class="code">
 <span class='string val'>'stock.de.dax'</span>
</pre>
<p>
When publishing data to the exchange, bound queues subscribing to the
exchange indicate which data interests them by passing a routing key for
matching against the published routing key.
</p>
<pre class="code">
 <span class='EM constant id'>EM</span><span class='dot token'>.</span><span class='run identifier id'>run</span> <span class='do do kw'>do</span>
   <span class='exch identifier id'>exch</span> <span class='assign token'>=</span> <span class='MQ constant id'>MQ</span><span class='colon2 op'>::</span><span class='Exchange constant id'>Exchange</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='MQ constant id'>MQ</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='comma token'>,</span> <span class='symbol val'>:topic</span><span class='comma token'>,</span> <span class='string val'>&quot;stocks&quot;</span><span class='rparen token'>)</span>
   <span class='keys identifier id'>keys</span> <span class='assign token'>=</span> <span class='lbrack token'>[</span><span class='string val'>'stock.us.aapl'</span><span class='comma token'>,</span> <span class='string val'>'stock.de.dax'</span><span class='rbrack token'>]</span>

   <span class='EM constant id'>EM</span><span class='dot token'>.</span><span class='add_periodic_timer identifier id'>add_periodic_timer</span><span class='lparen token'>(</span><span class='integer val'>1</span><span class='rparen token'>)</span> <span class='do do kw'>do</span> <span class='comment val'># every second</span>
     <span class='puts identifier id'>puts</span>
     <span class='exch identifier id'>exch</span><span class='dot token'>.</span><span class='publish identifier id'>publish</span><span class='lparen token'>(</span><span class='integer val'>10</span><span class='plus op'>+</span><span class='rand identifier id'>rand</span><span class='lparen token'>(</span><span class='integer val'>10</span><span class='rparen token'>)</span><span class='comma token'>,</span> <span class='symbol val'>:routing_key</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='keys identifier id'>keys</span><span class='lbrack token'>[</span><span class='rand identifier id'>rand</span><span class='lparen token'>(</span><span class='integer val'>2</span><span class='rparen token'>)</span><span class='rbrack token'>]</span><span class='rparen token'>)</span>
   <span class='end end kw'>end</span>

   <span class='comment val'># match against one dot-separated item</span>
   <span class='MQ constant id'>MQ</span><span class='dot token'>.</span><span class='queue identifier id'>queue</span><span class='lparen token'>(</span><span class='string val'>'us stocks'</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='bind identifier id'>bind</span><span class='lparen token'>(</span><span class='exch identifier id'>exch</span><span class='comma token'>,</span> <span class='symbol val'>:key</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'stock.us.*'</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='subscribe identifier id'>subscribe</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='price identifier id'>price</span><span class='bitor op'>|</span>
     <span class='puts identifier id'>puts</span> <span class='dstring node'>&quot;us stock price [#{price}]&quot;</span>
   <span class='end end kw'>end</span>

   <span class='comment val'># match against multiple dot-separated items</span>
   <span class='MQ constant id'>MQ</span><span class='dot token'>.</span><span class='queue identifier id'>queue</span><span class='lparen token'>(</span><span class='string val'>'all stocks'</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='bind identifier id'>bind</span><span class='lparen token'>(</span><span class='exch identifier id'>exch</span><span class='comma token'>,</span> <span class='symbol val'>:key</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'stock.#'</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='subscribe identifier id'>subscribe</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='price identifier id'>price</span><span class='bitor op'>|</span>
     <span class='puts identifier id'>puts</span> <span class='dstring node'>&quot;all stocks: price [#{price}]&quot;</span>
   <span class='end end kw'>end</span>

   <span class='comment val'># require exact match</span>
   <span class='MQ constant id'>MQ</span><span class='dot token'>.</span><span class='queue identifier id'>queue</span><span class='lparen token'>(</span><span class='string val'>'only dax'</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='bind identifier id'>bind</span><span class='lparen token'>(</span><span class='exch identifier id'>exch</span><span class='comma token'>,</span> <span class='symbol val'>:key</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'stock.de.dax'</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='subscribe identifier id'>subscribe</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='price identifier id'>price</span><span class='bitor op'>|</span>
     <span class='puts identifier id'>puts</span> <span class='dstring node'>&quot;dax price [#{price}]&quot;</span>
   <span class='end end kw'>end</span>
 <span class='end end kw'>end</span>
</pre>
<p>
For matching, the &#8217;*&#8217; (asterisk) wildcard matches against one
dot-separated item only. The &#8217;#&#8217; wildcard (hash or pound
symbol) matches against 0 or more dot-separated items. If none of these
symbols are used, the exchange performs a comparison looking for an exact
match.
</p>
<h2>Options</h2>
<ul>
<li>:passive =&gt; true | false (default false)

</li>
</ul>
<p>
If set, the server will not create the exchange if it does not already
exist. The client can use this to check whether an exchange exists without
modifying the server state.
</p>
<ul>
<li>:durable =&gt; true | false (default false)

</li>
</ul>
<p>
If set when creating a new exchange, the exchange will be marked as
durable. Durable exchanges remain active when a server restarts.
Non-durable exchanges (transient exchanges) are purged if/when a server
restarts.
</p>
<p>
A transient exchange (the default) is stored in memory-only therefore it is
a good choice for high-performance and low-latency message publishing.
</p>
<p>
Durable exchanges cause all messages to be written to non-volatile backing
store (i.e. disk) prior to routing to any bound queues.
</p>
<ul>
<li>:auto_delete =&gt; true | false (default false)

</li>
</ul>
<p>
If set, the exchange is deleted when all queues have finished using it. The
server waits for a short period of time before determining the exchange is
unused to give time to the client code to bind a queue to it.
</p>
<p>
If the exchange has been previously declared, this option is ignored on
subsequent declarations.
</p>
<ul>
<li>:internal =&gt; true | false (default false)

</li>
</ul>
<p>
If set, the exchange may not be used directly by publishers, but only when
bound to other exchanges. Internal exchanges are used to construct wiring
that is not visible to applications.
</p>
<ul>
<li>:nowait =&gt; true | false (default true)

</li>
</ul>
<p>
If set, the server will not respond to the method. The client should not
wait for a reply method. If the server could not complete the method it
will raise a channel or connection exception.
</p>
<h2>Exceptions</h2>
<p>
Doing any of these activities are illegal and will raise MQ:Error.
</p>
<ul>
<li>redeclare an already-declared exchange to a different type

</li>
<li>:passive =&gt; true and the exchange does not exist (NOT_FOUND)

</li>
</ul>

</div><div class="section source">
  <span>[<a class="source_link" href="#">View source</a>]</span>
  <div class="source_code">
    <table>
      <tr>
        <td>
          <pre class="lines">


191
192
193
194
195
196
197
198
199
200
201
202</pre>
        </td>
        <td>
          <pre class="code"><span class="info file"># File 'lib/mq/exchange.rb', line 191</span>

<span class='def def kw'>def</span> <span class='initialize identifier id'>initialize</span> <span class='mq identifier id'>mq</span><span class='comma token'>,</span> <span class='type identifier id'>type</span><span class='comma token'>,</span> <span class='name identifier id'>name</span><span class='comma token'>,</span> <span class='opts identifier id'>opts</span> <span class='assign token'>=</span> <span class='lbrace token'>{</span><span class='rbrace token'>}</span>
  <span class='@mq ivar id'>@mq</span> <span class='assign token'>=</span> <span class='mq identifier id'>mq</span>
  <span class='@type ivar id'>@type</span><span class='comma token'>,</span> <span class='@name ivar id'>@name</span><span class='comma token'>,</span> <span class='@opts ivar id'>@opts</span> <span class='assign token'>=</span> <span class='type identifier id'>type</span><span class='comma token'>,</span> <span class='name identifier id'>name</span><span class='comma token'>,</span> <span class='opts identifier id'>opts</span>
  <span class='@mq ivar id'>@mq</span><span class='dot token'>.</span><span class='exchanges identifier id'>exchanges</span><span class='lbrack token'>[</span><span class='@name ivar id'>@name</span> <span class='assign token'>=</span> <span class='name identifier id'>name</span><span class='rbrack token'>]</span> <span class='opasgn op'>||=</span> <span class='self self kw'>self</span>
  <span class='@key ivar id'>@key</span> <span class='assign token'>=</span> <span class='opts identifier id'>opts</span><span class='lbrack token'>[</span><span class='symbol val'>:key</span><span class='rbrack token'>]</span>
  
  <span class='@mq ivar id'>@mq</span><span class='dot token'>.</span><span class='callback identifier id'>callback</span><span class='lbrace token'>{</span>
    <span class='@mq ivar id'>@mq</span><span class='dot token'>.</span><span class='send identifier id'>send</span> <span class='Protocol constant id'>Protocol</span><span class='colon2 op'>::</span><span class='Exchange constant id'>Exchange</span><span class='colon2 op'>::</span><span class='Declare constant id'>Declare</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='lbrace token'>{</span> <span class='symbol val'>:exchange</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='name identifier id'>name</span><span class='comma token'>,</span>
                                               <span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='type identifier id'>type</span><span class='comma token'>,</span>
                                               <span class='symbol val'>:nowait</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='true true kw'>true</span> <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='merge identifier id'>merge</span><span class='lparen token'>(</span><span class='opts identifier id'>opts</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
  <span class='rbrace token'>}</span> <span class='unless unless_mod kw'>unless</span> <span class='name identifier id'>name</span> <span class='eq op'>==</span> <span class='dstring node'>&quot;amq.#{type}&quot;</span> <span class='or or kw'>or</span> <span class='name identifier id'>name</span> <span class='eq op'>==</span> <span class='string val'>''</span>
<span class='end end kw'>end</span>
</pre>
        </td>
      </tr>
    </table>
  </div>
</div>
</div>
</div>  <div class="section visibilitygroup public">
    <h1>Public Visibility</h1>
      <div class="section methodsummary class public">
    <div class="included">
  
  <div>
    <h1>Public Class Methods Included from <a href='Exchange/AMQP.html' title='AMQP'>AMQP</a></h1>
    <p><span class='name'><a href='../AMQP.html#client-class_method' title='client'>client</a></span>, <span class='name'><a href='../AMQP.html#connect-class_method' title='connect'>connect</a></span>, <span class='name'><a href='../AMQP.html#fork-class_method' title='fork'>fork</a></span>, <span class='name'><a href='../AMQP.html#settings-class_method' title='settings'>settings</a></span>, <span class='name'><a href='../AMQP.html#start-class_method' title='start'>start</a></span>, <span class='name'><a href='../AMQP.html#stop-class_method' title='stop'>stop</a></span></p>
  </div>
  
</div>
<div class="clear"></div>
  </div>
  <div class="section methodsummary instance public">
    <h1>Public Instance Method Summary</h1>
<table class="summary">
  
    <tr>
      <th class="signature">
        <span class='name'><a href='#delete-instance_method' title='#delete'>#delete</a></span><span class='args'>opts = {}</span>
        <span class='block'></span>
        
      </th>
      <td class="docstring">
        <p>
This method deletes an exchange.
</p>

        
      </td>
    </tr>
  
    <tr>
      <th class="signature">
        <span class='name'><a href='#publish-instance_method' title='#publish'>#publish</a></span><span class='args'>data, opts = {}</span>
        <span class='block'></span>
        
      </th>
      <td class="docstring">
        <p>
This method publishes a staged file message to a specific exchange.
</p>

        
      </td>
    </tr>
  
    <tr>
      <th class="signature">
        <span class='name'><a href='#reset-instance_method' title='#reset'>#reset</a></span><span class='args'></span>
        <span class='block'></span>
        
      </th>
      <td class="docstring">
        
        
      </td>
    </tr>
  
</table><div class="included">
  
  <div>
    <h1>Public Instance Methods Included from <a href='Exchange/AMQP.html' title='AMQP'>AMQP</a></h1>
    <p><span class='name'><a href='../AMQP.html#_read-instance_method' title='_read'>_read</a></span>, <span class='name'><a href='../AMQP.html#_write-instance_method' title='_write'>_write</a></span>, <span class='name'><a href='../AMQP.html#extract-instance_method' title='extract'>extract</a></span></p>
  </div>
  
</div>
<div class="clear"></div>
  </div>
<div class="section methoddetails instance public">
  <h1>Public Instance Method Details</h1>
  
    <div class="method">
      <div class="method_header">
  <h3>delete</h3>
</div><div id="delete-instance_method" class="section method">
  <div class="details_title">
  <div class='section methodsignature'>
  <tt class='def'>
    <span class='visibility'>public</span>
    <span class='return_types'></span>
    <span class='name'>delete</span><span class='args'>opts = {}</span>
    <span class='block'></span>
  </tt>
</div>

</div><div class="section docstring">
  <p>
This method deletes an exchange. When an exchange is deleted all queue
bindings on the exchange are cancelled.
</p>
<p>
Further attempts to publish messages to a deleted exchange will raise an
MQ::Error due to a channel close exception.
</p>
<pre class="code">
 <span class='exchange identifier id'>exchange</span> <span class='assign token'>=</span> <span class='MQ constant id'>MQ</span><span class='dot token'>.</span><span class='direct identifier id'>direct</span><span class='lparen token'>(</span><span class='string val'>'name'</span><span class='comma token'>,</span> <span class='symbol val'>:key</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'foo.bar'</span><span class='rparen token'>)</span>
 <span class='exchange identifier id'>exchange</span><span class='dot token'>.</span><span class='delete identifier id'>delete</span>
</pre>
<h2>Options</h2>
<ul>
<li>:nowait =&gt; true | false (default true)

</li>
</ul>
<p>
If set, the server will not respond to the method. The client should not
wait for a reply method. If the server could not complete the method it
will raise a channel or connection exception.
</p>
<pre class="code">
 <span class='exchange identifier id'>exchange</span><span class='dot token'>.</span><span class='delete identifier id'>delete</span><span class='lparen token'>(</span><span class='symbol val'>:nowait</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='false false kw'>false</span><span class='rparen token'>)</span>
</pre>
<ul>
<li>:if_unused =&gt; true | false (default false)

</li>
</ul>
<p>
If set, the server will only delete the exchange if it has no queue
bindings. If the exchange has queue bindings the server does not delete it
but raises a channel exception instead (MQ:Error).
</p>

</div><div class="section source">
  <span>[<a class="source_link" href="#">View source</a>]</span>
  <div class="source_code">
    <table>
      <tr>
        <td>
          <pre class="lines">


288
289
290
291
292
293
294
295</pre>
        </td>
        <td>
          <pre class="code"><span class="info file"># File 'lib/mq/exchange.rb', line 288</span>

<span class='def def kw'>def</span> <span class='delete identifier id'>delete</span> <span class='opts identifier id'>opts</span> <span class='assign token'>=</span> <span class='lbrace token'>{</span><span class='rbrace token'>}</span>
  <span class='@mq ivar id'>@mq</span><span class='dot token'>.</span><span class='callback identifier id'>callback</span><span class='lbrace token'>{</span>
    <span class='@mq ivar id'>@mq</span><span class='dot token'>.</span><span class='send identifier id'>send</span> <span class='Protocol constant id'>Protocol</span><span class='colon2 op'>::</span><span class='Exchange constant id'>Exchange</span><span class='colon2 op'>::</span><span class='Delete constant id'>Delete</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='lbrace token'>{</span> <span class='symbol val'>:exchange</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='name identifier id'>name</span><span class='comma token'>,</span>
                                              <span class='symbol val'>:nowait</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='true true kw'>true</span> <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='merge identifier id'>merge</span><span class='lparen token'>(</span><span class='opts identifier id'>opts</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
    <span class='@mq ivar id'>@mq</span><span class='dot token'>.</span><span class='exchanges identifier id'>exchanges</span><span class='dot token'>.</span><span class='delete identifier id'>delete</span> <span class='name identifier id'>name</span>
  <span class='rbrace token'>}</span>
  <span class='nil nil kw'>nil</span>
<span class='end end kw'>end</span>
</pre>
        </td>
      </tr>
    </table>
  </div>
</div>
</div>
    </div>
  
    <div class="method">
      <div class="method_header">
  <h3>publish</h3>
</div><div id="publish-instance_method" class="section method">
  <div class="details_title">
  <div class='section methodsignature'>
  <tt class='def'>
    <span class='visibility'>public</span>
    <span class='return_types'></span>
    <span class='name'>publish</span><span class='args'>data, opts = {}</span>
    <span class='block'></span>
  </tt>
</div>

</div><div class="section docstring">
  <p>
This method publishes a staged file message to a specific exchange. The
file message will be routed to queues as defined by the exchange
configuration and distributed to any active consumers when the transaction,
if any, is committed.
</p>
<pre class="code">
 <span class='exchange identifier id'>exchange</span> <span class='assign token'>=</span> <span class='MQ constant id'>MQ</span><span class='dot token'>.</span><span class='direct identifier id'>direct</span><span class='lparen token'>(</span><span class='string val'>'name'</span><span class='comma token'>,</span> <span class='symbol val'>:key</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'foo.bar'</span><span class='rparen token'>)</span>
 <span class='exchange identifier id'>exchange</span><span class='dot token'>.</span><span class='publish identifier id'>publish</span><span class='lparen token'>(</span><span class='string val'>&quot;some data&quot;</span><span class='rparen token'>)</span>
</pre>
<p>
The method takes several hash key options which modify the behavior or
lifecycle of the message.
</p>
<ul>
<li>:routing_key =&gt; &#8216;string&#8217;

</li>
</ul>
<p>
Specifies the routing key for the message. The routing key is used for
routing messages depending on the exchange configuration.
</p>
<ul>
<li>:mandatory =&gt; true | false (default false)

</li>
</ul>
<p>
This flag tells the server how to react if the message cannot be routed to
a queue. If this flag is set, the server will return an unroutable message
with a Return method. If this flag is zero, the server silently drops the
message.
</p>
<ul>
<li>:immediate =&gt; true | false (default false)

</li>
</ul>
<p>
This flag tells the server how to react if the message cannot be routed to
a queue consumer immediately. If this flag is set, the server will return
an undeliverable message with a Return method. If this flag is zero, the
server will queue the message, but with no guarantee that it will ever be
consumed.
</p>
<pre class="code">
 <span class='mult op'>*</span> <span class='symbol val'>:persistent</span>
</pre>
<p>
True or False. When true, this message will remain in the queue until it is
consumed (if the queue is durable). When false, the message is lost if the
server restarts and the queue is recreated.
</p>
<p>
For high-performance and low-latency, set :persistent =&gt; false so the
message stays in memory and is never persisted to non-volatile (slow)
storage.
</p>

</div><div class="section source">
  <span>[<a class="source_link" href="#">View source</a>]</span>
  <div class="source_code">
    <table>
      <tr>
        <td>
          <pre class="lines">


245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264</pre>
        </td>
        <td>
          <pre class="code"><span class="info file"># File 'lib/mq/exchange.rb', line 245</span>

<span class='def def kw'>def</span> <span class='publish identifier id'>publish</span> <span class='data identifier id'>data</span><span class='comma token'>,</span> <span class='opts identifier id'>opts</span> <span class='assign token'>=</span> <span class='lbrace token'>{</span><span class='rbrace token'>}</span>
  <span class='@mq ivar id'>@mq</span><span class='dot token'>.</span><span class='callback identifier id'>callback</span><span class='lbrace token'>{</span>
    <span class='out identifier id'>out</span> <span class='assign token'>=</span> <span class='lbrack token'>[</span><span class='rbrack token'>]</span>

    <span class='out identifier id'>out</span> <span class='lshft op'>&lt;&lt;</span> <span class='Protocol constant id'>Protocol</span><span class='colon2 op'>::</span><span class='Basic constant id'>Basic</span><span class='colon2 op'>::</span><span class='Publish constant id'>Publish</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='lbrace token'>{</span> <span class='symbol val'>:exchange</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='name identifier id'>name</span><span class='comma token'>,</span>
                                          <span class='symbol val'>:routing_key</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='opts identifier id'>opts</span><span class='dot token'>.</span><span class='delete identifier id'>delete</span><span class='lparen token'>(</span><span class='symbol val'>:key</span><span class='rparen token'>)</span> <span class='orop op'>||</span> <span class='@key ivar id'>@key</span> <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='merge identifier id'>merge</span><span class='lparen token'>(</span><span class='opts identifier id'>opts</span><span class='rparen token'>)</span><span class='rparen token'>)</span>

    <span class='data identifier id'>data</span> <span class='assign token'>=</span> <span class='data identifier id'>data</span><span class='dot token'>.</span><span class='to_s identifier id'>to_s</span>

    <span class='out identifier id'>out</span> <span class='lshft op'>&lt;&lt;</span> <span class='Protocol constant id'>Protocol</span><span class='colon2 op'>::</span><span class='Header constant id'>Header</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='Protocol constant id'>Protocol</span><span class='colon2 op'>::</span><span class='Basic constant id'>Basic</span><span class='comma token'>,</span>
                                <span class='data identifier id'>data</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='comma token'>,</span> <span class='lbrace token'>{</span> <span class='symbol val'>:content_type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'application/octet-stream'</span><span class='comma token'>,</span>
                                               <span class='symbol val'>:delivery_mode</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='lparen token'>(</span><span class='opts identifier id'>opts</span><span class='dot token'>.</span><span class='delete identifier id'>delete</span><span class='lparen token'>(</span><span class='symbol val'>:persistent</span><span class='rparen token'>)</span> <span class='question op'>?</span> <span class='integer val'>2</span> <span class='colon op'>:</span> <span class='integer val'>1</span><span class='rparen token'>)</span><span class='comma token'>,</span>
                                               <span class='symbol val'>:priority</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='integer val'>0</span> <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='merge identifier id'>merge</span><span class='lparen token'>(</span><span class='opts identifier id'>opts</span><span class='rparen token'>)</span><span class='rparen token'>)</span>

    <span class='out identifier id'>out</span> <span class='lshft op'>&lt;&lt;</span> <span class='Frame constant id'>Frame</span><span class='colon2 op'>::</span><span class='Body constant id'>Body</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='data identifier id'>data</span><span class='rparen token'>)</span>

    <span class='@mq ivar id'>@mq</span><span class='dot token'>.</span><span class='send identifier id'>send</span> <span class='mult op'>*</span><span class='out identifier id'>out</span>
  <span class='rbrace token'>}</span>
  <span class='self self kw'>self</span>
<span class='end end kw'>end</span>
</pre>
        </td>
      </tr>
    </table>
  </div>
</div>
</div>
    </div>
  
    <div class="method">
      <div class="method_header">
  <h3>reset</h3>
</div><div id="reset-instance_method" class="section method">
  <div class="details_title">
  <div class='section methodsignature'>
  <tt class='def'>
    <span class='visibility'>public</span>
    <span class='return_types'></span>
    <span class='name'>reset</span><span class='args'></span>
    <span class='block'></span>
  </tt>
</div>

</div><div class="section source">
  <span>[<a class="source_link" href="#">View source</a>]</span>
  <div class="source_code">
    <table>
      <tr>
        <td>
          <pre class="lines">


297
298
299
300</pre>
        </td>
        <td>
          <pre class="code"><span class="info file"># File 'lib/mq/exchange.rb', line 297</span>

<span class='def def kw'>def</span> <span class='reset identifier id'>reset</span>
  <span class='@deferred_status ivar id'>@deferred_status</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
  <span class='initialize identifier id'>initialize</span> <span class='@mq ivar id'>@mq</span><span class='comma token'>,</span> <span class='@type ivar id'>@type</span><span class='comma token'>,</span> <span class='@name ivar id'>@name</span><span class='comma token'>,</span> <span class='@opts ivar id'>@opts</span>
<span class='end end kw'>end</span>
</pre>
        </td>
      </tr>
    </table>
  </div>
</div>
</div>
    </div>
  
</div>
  </div>

</div>
    </div>
  </body>
</html>