<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="style.css" type="text/css" charset="utf-8" />
<link rel="stylesheet" href="syntax_highlight.css" type="text/css" charset="utf-8" />

    <title>README</title>
  </head>
  <body>
    <div id="content">
      <div class="section docstring readme">
        <h1>Simple background loops framework for rails and merb</h1>
<p>
loops is a small and lightweight framework for Ruby on Rails and Merb
created to support simple background loops in your application which are
usually used to do some background data processing on your servers (queue
workers, batch tasks processors, etc).
</p>
<h2>What tasks could you use it for?</h2>
<p>
Originally loops plugin was created to make our own loops code more
organized. We used to have tens of different modules with methods that were
called with script/runner and then used with nohup and other not so
convenient backgrounding techniques. When you have such a number of
loops/workers to run in background it becomes a nightmare to manage them on
a regular basis (restarts, code upgrades, status/health checking, etc).
</p>
<p>
After a short time of writing our loops in more organized ways we were able
to generalize most of the loops code so now our loops look like a classes
with a single mandatory public method called <b>run</b>. Everything else
(spawning many workers, managing them, logging, backgrounding, pid-files
management, etc) is handled by the plugin itself.
</p>
<h2>But there are dozens of libraries like this! Why do we need one more?</h2>
<p>
The major idea behind this small project was to create a deadly simple and
yet robust framework to be able to run some tasks in background and do not
think about spawning many workers, restarting them when they die, etc. So,
if you need to be able to run either one or many copies of your worker or
you do not want to think about re-spawning dead workers and do not want to
spend megabytes of RAM on separate copies of Ruby interpreter (when you run
each copy of your loop as a separate process controlled by monit/god/etc),
then I&#8217;d recommend you to try this framework &#8212; you&#8217;d like
it.
</p>
<h2>How to install?</h2>
<p>
To install this plugin you need to do a few steps:
</p>
<ul>
<li>To install the plugin, you can use the following command:

<pre class="code">
  <span class='dot token'>.</span><span class='div op'>/</span><span class='script identifier id'>script</span><span class='div op'>/</span><span class='plugin identifier id'>plugin</span> <span class='install identifier id'>install</span> <span class='git identifier id'>git</span><span class='symbol val'>:/</span><span class='regexp val'>/github.com/</span><span class='kovyrin identifier id'>kovyrin</span><span class='div op'>/</span><span class='loops identifier id'>loops</span><span class='dot token'>.</span><span class='git identifier id'>git</span>
</pre>
</li>
</ul>
<p>
This will install the whole package in your vendor/plugins directory. For
merb applications, just check out the code and place it to the
vendor/plugins directory.
</p>
<ul>
<li>Generate binary and configuration files by running

<pre class="code">
  <span class='dot token'>.</span><span class='div op'>/</span><span class='script identifier id'>script</span><span class='div op'>/</span><span class='generate identifier id'>generate</span> <span class='loops identifier id'>loops</span>
</pre>
</li>
</ul>
<p>
This will create the following list of files:
</p>
<ul>
<li><tt>./script/loops</tt> - binary file that will be used to manage your
loops

</li>
<li><tt>./config/loops.yml</tt> - example configuration file

</li>
<li><tt>./app/loops/simple.rb</tt> - REALLY simple loop example

</li>
<li><tt>./app/loops/queue_loop.rb</tt> - simple ActiveMQ queue worker

</li>
</ul>
<h2>How to use?</h2>
<p>
Here is a simple loop scaffold for you to start from (put this file to
app/loops/hello_world_loop.rb):
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='HelloWorldLoop constant id'>HelloWorldLoop</span> <span class='lt op'>&lt;</span> <span class='Loops constant id'>Loops</span><span class='colon2 op'>::</span><span class='Base constant id'>Base</span>
    <span class='def def kw'>def</span> <span class='run identifier id'>run</span>
      <span class='with_period_of identifier id'>with_period_of</span><span class='lparen token'>(</span><span class='integer val'>1</span><span class='rparen token'>)</span> <span class='do do kw'>do</span> <span class='comment val'># period is in seconds</span>
        <span class='debug identifier id'>debug</span><span class='lparen token'>(</span><span class='string val'>&quot;Hello, debug log!&quot;</span><span class='rparen token'>)</span>
        <span class='sleep identifier id'>sleep</span><span class='lparen token'>(</span><span class='config identifier id'>config</span><span class='lbrack token'>[</span><span class='string val'>'sleep_period'</span><span class='rbrack token'>]</span><span class='rparen token'>)</span> <span class='comment val'># Do something &quot;useful&quot; and make it configurable</span>
        <span class='debug identifier id'>debug</span><span class='lparen token'>(</span><span class='string val'>&quot;Hello, debug log (yes, once again)!&quot;</span><span class='rparen token'>)</span>
      <span class='end end kw'>end</span>
    <span class='end end kw'>end</span>
  <span class='end end kw'>end</span>
</pre>
<p>
When you have your loop ready to use, add the following lines to your
(maybe empty yet) config/loops.yml file:
</p>
<pre class="code">
  <span class='hello_world identifier id'>hello_world</span><span class='colon op'>:</span>
    <span class='type identifier id'>type</span><span class='colon op'>:</span> <span class='simple identifier id'>simple</span>
    <span class='sleep_period identifier id'>sleep_period</span><span class='colon op'>:</span> <span class='integer val'>10</span>
</pre>
<p>
This is it! To start your loop, just run one of the following commands:
</p>
<ul>
<li>To list all configured loops:

<pre class="code">
  $ <span class='dot token'>.</span><span class='div op'>/</span><span class='script identifier id'>script</span><span class='div op'>/</span><span class='loops identifier id'>loops</span> <span class='minus op'>-</span><span class='L constant id'>L</span>
</pre>
</li>
<li>To run all enabled (actually non-disabled) loops in foreground:

<pre class="code">
  $ <span class='dot token'>.</span><span class='div op'>/</span><span class='script identifier id'>script</span><span class='div op'>/</span><span class='loops identifier id'>loops</span> <span class='minus op'>-</span><span class='a identifier id'>a</span>
</pre>
</li>
<li>To run all enabled loops in background:

<pre class="code">
  $ <span class='dot token'>.</span><span class='div op'>/</span><span class='script identifier id'>script</span><span class='div op'>/</span><span class='loops identifier id'>loops</span> <span class='minus op'>-</span><span class='d identifier id'>d</span> <span class='minus op'>-</span><span class='a identifier id'>a</span>
</pre>
</li>
<li>To run specific loop in background:

<pre class="code">
  $ <span class='dot token'>.</span><span class='div op'>/</span><span class='script identifier id'>script</span><span class='div op'>/</span><span class='loops identifier id'>loops</span> <span class='minus op'>-</span><span class='d identifier id'>d</span> <span class='minus op'>-</span><span class='l identifier id'>l</span> <span class='hello_world identifier id'>hello_world</span>
</pre>
</li>
<li>To see all possible options:

<pre class="code">
  $ <span class='dot token'>.</span><span class='div op'>/</span><span class='script identifier id'>script</span><span class='div op'>/</span><span class='loops identifier id'>loops</span> <span class='minus op'>-</span><span class='h identifier id'>h</span>
</pre>
</li>
</ul>
<h2>How to run more than one worker?</h2>
<p>
If you want to have more than one copy of your worker running, that is as
simple as adding one option to your loop configuration:
</p>
<pre class="code">
  <span class='hello_world identifier id'>hello_world</span><span class='colon op'>:</span>
    <span class='type identifier id'>type</span><span class='colon op'>:</span> <span class='simple identifier id'>simple</span>
    <span class='sleep_period identifier id'>sleep_period</span><span class='colon op'>:</span> <span class='integer val'>10</span>
    <span class='workers_number identifier id'>workers_number</span><span class='colon op'>:</span> <span class='integer val'>1</span>
</pre>
<p>
This <em>workers_number</em> option would say loops manager to spawn more
than one copy of your loop and run them in parallel. The only thing
you&#8217;d need to do is to think about concurrent work of your loops. For
example, if you have some kind of database table with elements you need to
process, you can create a simple database-based locks system or use any
memcache-based locks.
</p>
<h2>ActiveMQ-based workers? What&#8217;s that?</h2>
<p>
In some of our worker loops we poll ActiveMQ queue and process its items to
perform some asynchronous operations. So, to make it simpler for us to
create such a workers, we&#8217;ve created really simple loops class
extension that wraps your code with basic queue polling/acknowledging code
and as the result, you can create a loops like this:
</p>
<pre class="code">
    <span class='class class kw'>class</span> <span class='MyQueueLoop constant id'>MyQueueLoop</span> <span class='lt op'>&lt;</span> <span class='Loops constant id'>Loops</span><span class='colon2 op'>::</span><span class='Queue constant id'>Queue</span>
      <span class='def def kw'>def</span> <span class='process_message identifier id'>process_message</span><span class='lparen token'>(</span><span class='message identifier id'>message</span><span class='rparen token'>)</span>
        <span class='debug identifier id'>debug</span> <span class='dstring node'>&quot;Received a message: #{message.body}&quot;</span>
        <span class='debug identifier id'>debug</span> <span class='string val'>&quot;sleeping...&quot;</span>
        <span class='sleep identifier id'>sleep</span><span class='lparen token'>(</span><span class='integer val'>0</span><span class='integer val'>.5</span> <span class='plus op'>+</span> <span class='rand identifier id'>rand</span><span class='lparen token'>(</span><span class='integer val'>10</span><span class='rparen token'>)</span> <span class='div op'>/</span> <span class='float val'>10.0</span><span class='rparen token'>)</span> <span class='comment val'># do something &quot;useful&quot; with the message :-)</span>
        <span class='debug identifier id'>debug</span> <span class='string val'>&quot;done...&quot;</span>
      <span class='end end kw'>end</span>
    <span class='end end kw'>end</span>
</pre>
<p>
With configs like this:
</p>
<pre class="code">
    <span class='comment val'># An example of a STOMP queue-based loop</span>
    <span class='my_queue identifier id'>my_queue</span><span class='colon op'>:</span>
      <span class='type identifier id'>type</span><span class='colon op'>:</span> <span class='queue identifier id'>queue</span>
      <span class='host identifier id'>host</span><span class='colon op'>:</span> <span class='float val'>127.0</span><span class='float val'>.0.1</span>
      <span class='port identifier id'>port</span><span class='colon op'>:</span> <span class='integer val'>61613</span>
      <span class='queue_name identifier id'>queue_name</span><span class='colon op'>:</span> <span class='blah identifier id'>blah</span>
</pre>
<p>
Of course, this solution scales perfectly and to make your queue processing
faster you just need to add more workers (by adding <tt>workers_number:
N</tt> option).
</p>
<p>
<em>Warning</em>: This type of loops requires you to have stomp plugin
installed in your system.
</p>
<h2>There is this <tt>workers_engine</tt> option in config file. What it could be used for?</h2>
<p>
There are two so called &quot;workers engines&quot; in this plugin:
<tt>fork</tt> and <tt>thread</tt>. They&#8217;re used to control the way
process manager would spawn new loops workers: with <tt>fork</tt> engine
we&#8217;ll load all loops classes and then fork ruby interpreter as many
times as many workers we need. With <tt>thread</tt> engine we&#8217;d do
Thread.new instead of forks. Thread engine could be useful if you are sure
your loop won&#8217;t lock ruby interpreter (it does not do native calls,
etc) or if you use some interpreter that does not support forks (like
jruby).
</p>
<p>
Default engine is <tt>fork</tt>.
</p>
<h2>What Ruby implementations does it work for?</h2>
<p>
We&#8217;ve tested and used the plugin on MRI 1.8.6 and on JRuby 1.1.5. At
this point we do not support demonization in JRuby and never tested the
code on Ruby 1.9. Obviously because of JVM limitations you won&#8217;t be
able to use <tt>fork</tt> workers engine in JRuby, but threaded workers do
pretty well.
</p>
<h2>Who are the authors?</h2>
<p>
This plugin has been created in Scribd.com for our internal use and then
the sources were opened for other people to use. All the code in this
package has been developed by Alexey Kovyrin and Dmytro Shteflyuk for
Scribd.com and is released under the GPLv2 license. For more details, see
LICENSE file.
</p>

      </div>
    </div>
  </body>
</html>