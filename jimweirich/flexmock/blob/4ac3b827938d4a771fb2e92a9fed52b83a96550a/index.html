<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <title>jimweirich's flexmock - GitHub Documentation</title>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="description" content="">

<link rel="search" type="application/opensearchdescription+xml" href="http://github.com/opensearch.xml" title="GitHub">
<link rel="fluid-icon" href="http://github.com/fluidicon.png" title="GitHub">
<link href="http://assets0.github.com/stylesheets/bundle.css" media="screen" rel="stylesheet" type="text/css">
<link href="http://github.com/feeds/jimweirich/commits/flexmock/master" rel="alternate" title="Recent Commits to flexmock:master" type="application/atom+xml">

<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js"></script>
<script type="text/javascript" src="http://assets3.github.com/javascripts/bundle.js"></script>              
<script src="app.js" type="text/javascript" charset="utf-8"></script>

<script type="text/javascript" src="http://docs.github.com/javascripts/md5.js"></script>
<script type="text/javascript" src="http://docs.github.com/javascripts/repos.js"></script>
<script type="text/javascript" src="http://docs.github.com/javascripts/commits.js"></script>
<script type="text/javascript">
  $(document).ready(function(){
    if (typeof skipHeaders != 'undefined') return;
    
    GitHubRepo.init("jimweirich", "flexmock", function(){ 
      GitHubRepo.links = " <a id='namespaces_button' rel='jimweirich/flexmock/blob/4ac3b827938d4a771fb2e92a9fed52b83a96550a' href='#'><img class='button' src='http://docs.github.com/namespaces_button.png' alt='Modules and Classes'/></a> ";
      GitHubRepo.links += " <a id='methods_button' rel='jimweirich/flexmock/blob/4ac3b827938d4a771fb2e92a9fed52b83a96550a' href='#'><img class='button' src='http://docs.github.com/methods_button.png' alt='Methods'/></a> ";
      $("#repo").html(GitHubRepo.content());
      $('#namespaces_button').click(function(){
        var url="/"+$(this).attr('rel')+"/namespaces/";
        $.gitbox(url);
        return false;
      });    
      $('#methods_button').click(function(){
        var url="/"+$(this).attr('rel')+"/methods/";
        $.gitbox(url);
        return false;
      });        
    });
    GitHubCommit.init("jimweirich", "flexmock", "4ac3b827938d4a771fb2e92a9fed52b83a96550a", function(){ 
      $("#commit").html(GitHubCommit.content());
    });
  });
</script>

    <link rel="stylesheet" href="style.css" type="text/css" charset="utf-8" />
  </head>
  <body>    
    
    
        <div id="main" style="padding-bottom:8em;">
      <div id="header">
        <div class="site">
          <div class="logo">
            <a href="http://github.com/"><img src="http://github.com/images/modules/header/logov3.png" alt="github"></a>
          </div>          
          <div class="topsearch">
            <form action="http://github.com/search" id="top_search_form" method="get">
              <input class="search" name="q" type="search"> <input value="Search" type="submit">
            </form>
            <div class="links">
              <a href="http://github.com/repositories">Browse</a> | <a href="http://github.com/guides">Guides</a> | <a href="http://github.com/search">Advanced</a>
            </div>
          </div>
          <div class="actions">
            <a href="http://github.com">Home</a>
            <a href="http://github.com/plans"><b><u>Pricing and Signup</u></b></a>
            <a href="http://docs.github.com/">Documentation</a>
            <a href="https://github.com/login">Login</a>
          </div>                  
        </div>
      </div>    
                                                  
      <div id="repo_menu">
        <div class="site">
          <ul>          
            <li class=""><a href="http://github.com/jimweirich/flexmock/tree/">Source</a></li>
            <li class=""><a href="http://github.com/jimweirich/flexmock/commits/">Commits</a></li>            
            <li class=""><a href="http://github.com/jimweirich/flexmock/network">Network</a></li>            
            <li class=""><a href="http://github.com/jimweirich/flexmock/issues">Issues</a></li>
            <li class=""><a href="http://wiki.github.com/jimweirich/flexmock">Wiki</a></li>
            <li class=""><a href="http://github.com/jimweirich/flexmock/graphs">Graphs</a></li>                    
            <li class="active"><a href="/jimweirich/flexmock">Documentation</a></li>
          </ul>
        </div>
      </div>

      <div id="repo_sub_menu">
        <div class="site">
          <div class="joiner"></div>      
        </div>
      </div>

      <div class="site">  
        <div id="repos">
          <div id="repo" class="repo public">
            <div class="title">
              <div class="path">
                <a href="http://github.com/jimweirich">jimweirich</a> / <b><a href="http://github.com/jimweirich/flexmock/tree">flexmock</a></b>        
                <a id="namespaces_button" rel="jimweirich/flexmock/blob/4ac3b827938d4a771fb2e92a9fed52b83a96550a" href="#"><img class="button" src="http://docs.github.com/namespaces_button.png" alt="Modules and Classes"/></a>
                <a id="methods_button" rel="jimweirich/flexmock/blob/4ac3b827938d4a771fb2e92a9fed52b83a96550a" href="#"><img class="button" src="http://docs.github.com/methods_button.png" alt="Methods"/></a>
              </div>
            </div>            
          </div>
          <div id="commit">
          </div> 
          <br/>                                       
          <div id="content">
            <div class="section docstring readme wikistyle">
  <h1>Flex Mock &#8212; Making Mock Easy</h1>
<p>
FlexMock is a simple, but flexible, mock object library for Ruby unit
testing.
</p>
<table>
<tr><td valign="top">Version :</td><td>0.8.6

</td></tr>
</table>
<h1>Links</h1>
<table>
<tr><td valign="top"><b>Documents</b>   :</td><td>http://flexmock.rubyforge.org

</td></tr>
<tr><td valign="top"><b>RubyGems</b>    :</td><td>Install with: <b>gem install flexmock</b>

</td></tr>
<tr><td valign="top"><b>Download</b>    :</td><td>Download from RubyForge at http://rubyforge.org/frs/?group_id=3433 (pre
0.6.0 versions may be found at http://rubyforge.org/frs/?group_id=170)

</td></tr>
</table>
<h2>Installation</h2>
<p>
You can install FlexMock with the following command.
</p>
<pre class="code">
 $ <span class='gem identifier id'>gem</span> <span class='install identifier id'>install</span> <span class='flexmock identifier id'>flexmock</span>
</pre>
<h2>Simple Example</h2>
<p>
We have a data acquisition class (<tt>TemperatureSampler</tt>) that reads a
temperature sensor and returns an average of 3 readings. We don&#8217;t
have a <em>real</em> temperature to use for testing, so we mock one up with
a mock object that responds to the <tt>read_temperature</tt> message.
</p>
<p>
Here&#8217;s the complete example:
</p>
<pre class="code">
  <span class='require identifier id'>require</span> <span class='string val'>'test/unit'</span>
  <span class='require identifier id'>require</span> <span class='string val'>'flexmock/test_unit'</span>

  <span class='class class kw'>class</span> <span class='TemperatureSampler constant id'>TemperatureSampler</span>
    <span class='def def kw'>def</span> <span class='initialize identifier id'>initialize</span><span class='lparen token'>(</span><span class='sensor identifier id'>sensor</span><span class='rparen token'>)</span>
      <span class='@sensor ivar id'>@sensor</span> <span class='assign token'>=</span> <span class='sensor identifier id'>sensor</span>
    <span class='end end kw'>end</span>

    <span class='def def kw'>def</span> <span class='average_temp identifier id'>average_temp</span>
      <span class='total identifier id'>total</span> <span class='assign token'>=</span> <span class='lparen token'>(</span><span class='integer val'>0</span><span class='dot3 op'>...</span><span class='integer val'>3</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='collect identifier id'>collect</span> <span class='lbrace token'>{</span>
        <span class='@sensor ivar id'>@sensor</span><span class='dot token'>.</span><span class='read_temperature identifier id'>read_temperature</span>
      <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='inject identifier id'>inject</span> <span class='lbrace token'>{</span> <span class='bitor op'>|</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='s identifier id'>s</span><span class='bitor op'>|</span> <span class='i identifier id'>i</span> <span class='plus op'>+</span> <span class='s identifier id'>s</span> <span class='rbrace token'>}</span>
      <span class='total identifier id'>total</span> <span class='div op'>/</span> <span class='float val'>3.0</span>
    <span class='end end kw'>end</span>
  <span class='end end kw'>end</span>

  <span class='class class kw'>class</span> <span class='TestTemperatureSampler constant id'>TestTemperatureSampler</span> <span class='lt op'>&lt;</span> <span class='Test constant id'>Test</span><span class='colon2 op'>::</span><span class='Unit constant id'>Unit</span><span class='colon2 op'>::</span><span class='TestCase constant id'>TestCase</span>
    <span class='def def kw'>def</span> <span class='test_sensor_can_average_three_temperature_readings identifier id'>test_sensor_can_average_three_temperature_readings</span>
      <span class='sensor identifier id'>sensor</span> <span class='assign token'>=</span> <span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='string val'>&quot;temp&quot;</span><span class='rparen token'>)</span>
      <span class='sensor identifier id'>sensor</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:read_temperature</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='times identifier id'>times</span><span class='lparen token'>(</span><span class='integer val'>3</span><span class='rparen token'>)</span><span class='dot token'>.</span>
        <span class='and_return identifier id'>and_return</span><span class='lparen token'>(</span><span class='integer val'>10</span><span class='comma token'>,</span> <span class='integer val'>12</span><span class='comma token'>,</span> <span class='integer val'>14</span><span class='rparen token'>)</span>

      <span class='sampler identifier id'>sampler</span> <span class='assign token'>=</span> <span class='TemperatureSampler constant id'>TemperatureSampler</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='sensor identifier id'>sensor</span><span class='rparen token'>)</span>
      <span class='assert_equal identifier id'>assert_equal</span> <span class='integer val'>12</span><span class='comma token'>,</span> <span class='sampler identifier id'>sampler</span><span class='dot token'>.</span><span class='average_temp identifier id'>average_temp</span>
    <span class='end end kw'>end</span>
  <span class='end end kw'>end</span>
</pre>
<p>
You can find an extended example of FlexMock in <tt>Example</tt>[http://flexmock.rubyforge.org/files/doc/GoogleExample_rdoc.html].
</p>
<h2>Test::Unit Integration</h2>
<p>
FlexMock integrates nicely with Test::Unit. Just require the
&#8216;flexmock/test_unit&#8217; file at the top of your test file. The
<tt>flexmock</tt> method will be available for mock creation, and any
created mocks will be automatically validated and closed at the end of the
individual test.
</p>
<p>
Your test case will look something like this:
</p>
<pre class="code">
  <span class='require identifier id'>require</span> <span class='string val'>'flexmock/test_unit'</span>

  <span class='class class kw'>class</span> <span class='TestDog constant id'>TestDog</span> <span class='lt op'>&lt;</span> <span class='Test constant id'>Test</span><span class='colon2 op'>::</span><span class='Unit constant id'>Unit</span><span class='colon2 op'>::</span><span class='TestCase constant id'>TestCase</span>
    <span class='def def kw'>def</span> <span class='test_dog_wags identifier id'>test_dog_wags</span>
      <span class='tail_mock identifier id'>tail_mock</span> <span class='assign token'>=</span> <span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='symbol val'>:wag</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='symbol val'>:happy</span><span class='rparen token'>)</span>
      <span class='assert_equal identifier id'>assert_equal</span> <span class='symbol val'>:happy</span><span class='comma token'>,</span> <span class='tail_mock identifier id'>tail_mock</span><span class='dot token'>.</span><span class='wag identifier id'>wag</span>
    <span class='end end kw'>end</span>
  <span class='end end kw'>end</span>
</pre>
<p>
<b>NOTE:</b> If you don&#8217;t want to automatically extend every TestCase
with the flexmock methods and overhead, then require the
&#8216;flexmock&#8217; file and explicitly include the FlexMock::TestCase
module in each test case class where you wish to use mock objects. FlexMock
versions prior to 0.6.0 required the explicit include.
</p>
<h2>RSpec Integration</h2>
<p>
FlexMock also supports integration with the RSpec behavior specification
framework. Starting with version 0.9.0 of RSpec, you will be able to say:
</p>
<pre class="code">
  <span class='Spec constant id'>Spec</span><span class='colon2 op'>::</span><span class='Runner constant id'>Runner</span><span class='dot token'>.</span><span class='configure identifier id'>configure</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='config identifier id'>config</span><span class='bitor op'>|</span>
    <span class='config identifier id'>config</span><span class='dot token'>.</span><span class='mock_with identifier id'>mock_with</span> <span class='symbol val'>:flexmock</span>
  <span class='end end kw'>end</span>

  <span class='describe identifier id'>describe</span> <span class='string val'>&quot;Using FlexMock with RSpec&quot;</span> <span class='do do kw'>do</span>
    <span class='it identifier id'>it</span> <span class='string val'>&quot;should be able to create a mock&quot;</span> <span class='do do kw'>do</span>
      <span class='m identifier id'>m</span> <span class='assign token'>=</span> <span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='symbol val'>:foo</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='symbol val'>:bar</span><span class='rparen token'>)</span>
      <span class='m identifier id'>m</span><span class='dot token'>.</span><span class='foo identifier id'>foo</span><span class='dot token'>.</span><span class='should identifier id'>should</span> <span class='eqq op'>===</span> <span class='symbol val'>:bar</span>
    <span class='end end kw'>end</span>
  <span class='end end kw'>end</span>
</pre>
<p>
If you wish to try this prior to the release of RSpec 0.9.0, check out the
trunk of the RSpec subversion repository.
</p>
<h2>Quick Reference</h2>
<h3>Creating Mock Objects</h3>
<p>
The <tt>flexmock</tt> method is used to create mocks in various
configurations. Here&#8217;s a quick rundown of the most common options.
See FlexMock::MockContainer#flexmock for more details.
</p>
<ul>
<li><b>mock = flexmock(&quot;joe&quot;)</b>

<p>
Create a mock object named &quot;joe&quot; (the name is used in reporting
errors).
</p>
</li>
<li><b>mock = flexmock(:foo =&gt; :bar, :baz =&gt; :froz)</b>

<p>
Create a mock object and define two mocked methods (:foo and :baz) that
return the values :bar and :froz respectively. This is useful when creating
mock objects with just a few methods and simple return values.
</p>
</li>
<li><b>mock = flexmock(&quot;joe&quot;, :foo =&gt; :bar, :bar =&gt; :froz)</b>

<p>
You can combine the mock name and an expectation hash in the same call to
flexmock.
</p>
</li>
<li><b>partial_mock = flexmock(real_object)</b>

<p>
If you you give <tt>flexmock</tt> a real object in the argument list, it
will treat that real object as a base for a partial mock object. The return
value <tt>m</tt> may be used to set expectations. The real_object should be
used in the reference portion of the test.
</p>
</li>
<li><b>partial_mock = flexmock(real_object, &quot;name&quot;, :foo =&gt;
:baz)</b>

<p>
Names and expectation hashes may be used with partial mocks as well.
</p>
</li>
<li><b>partial_mock = flexmock(:base, real_string_object)</b>

<p>
Since Strings (and Symbols for that matter) are used for mock names,
FlexMock will not recognize them as the base for a partial mock. To force a
string to be used as a partial mock base, proceed the string object in the
calling sequence with :base.
</p>
</li>
<li><b>partial_mock = flexmock(:safe, real_object) { |mock|
mock.should_receive(&#8230;) }</b>

<p>
When mocking real objects (i.e. &quot;partial mocks&quot;), FlexMock will
add a handful of mock related methods to the actual object (see below for
list of method names). If one or more of these added methods collide with
an existing method on the partial mock, then there are problems.
</p>
<p>
FlexMock offers a &quot;safe&quot; mode for partial mocks that does not add
these methods. Indicate safe mode by passing the symbol :safe as the first
argument of flexmock. A block <em>is required</em> when using safe mode
(the partial_mock returned in safe mode does not have a
<tt>should_receive</tt> method).
</p>
<p>
The methods added to partial mocks in non-safe mode are:
</p>
<ul>
<li>should_receive

</li>
<li>new_instances

</li>
<li>any_instance (note: deprecated)

</li>
<li>mock

</li>
<li>mock_teardown

</li>
<li>mock_setup

</li>
</ul>
</li>
<li><b>mock = flexmock(&#8230;) { |mock| mock.should_receive(&#8230;) }</b>

<p>
If a block is given to any of the <tt>flexmock</tt> forms, the mock object
will be passed to the block as an argument. Code in the block can set the
desired expectations for the mock object.
</p>
</li>
<li><b>mock_model = flexmock(:model, YourModel, &#8230;) { |mock|
mock.should_receive(&#8230;) }</b>

<p>
When given :model, flexmock() will return a pure mock (not a partial mock)
that will have some ActiveRecord specific methods defined. YourModel should
be the class of an ActiveRecord model. These predefined methods make it a
bit easier to mock out ActiveRecord model objects in a Rails application.
Other that the predefined mocked methods, the mock returned is a standard
FlexMock mock object.
</p>
<p>
The predefined mocked methods are:
</p>
<ul>
<li>id &#8212; returns a unique ID for each mocked model.

</li>
<li>to_params &#8212; returns a stringified version of the id.

</li>
<li>new_record? &#8212; returns false.

</li>
<li>errors &#8212; returns an empty (mocked) errors object.

</li>
<li>is_a?(other) &#8212; returns true if other == YourModel.

</li>
<li>instance_of?(class) &#8212; returns true if class == YourModel

</li>
<li>kind_of?(class) &#8212; returns true if class is YourModel or one of its
ancestors

</li>
<li>class &#8212; returns YourModel.

</li>
</ul>
</li>
</ul>
<p>
<b>NOTE:</b> Versions of FlexMock prior to 0.6.0 used <tt>flexstub</tt> to
create partial mocks. The <tt>flexmock</tt> method now assumes all the
functionality that was spread out between two different methods.
<tt>flexstub</tt> is still available for backward compatibility.
</p>
<h3>Expectation Declarators</h3>
<p>
Once a mock is created, you need to define what that mock should expect to
see. Expectation declarators are used to specify these expectations placed
upon received method calls. A basic expectation, created with the
<tt>should_receive</tt> method, just establishes the fact that a method may
(or may not) be called on the mock object. Refinements to that expectation
may be additionally declared. FlexMock always starts with the most general
expectation and adds constraints to that.
</p>
<p>
For example, the following code:
</p>
<pre class="code">
    <span class='mock identifier id'>mock</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:average</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='and_return identifier id'>and_return</span><span class='lparen token'>(</span><span class='integer val'>12</span><span class='rparen token'>)</span>
</pre>
<p>
Means that the mock will now accept method calls to an <tt>average</tt>
method. The expectation will accept any arguments and may be called any
number of times (including zero times). Strictly speaking, the
<tt>and_return</tt> part of the declaration isn&#8217;t exactly a
constraint, but it does specify what value the mock will return when the
expectation is matched.
</p>
<p>
If you want to be more specific, you need to add additional constraints to
your expectation. Here are some examples:
</p>
<pre class="code">
    <span class='mock identifier id'>mock</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:average</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='integer val'>12</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='once identifier id'>once</span>

    <span class='mock identifier id'>mock</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:average</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='Integer constant id'>Integer</span><span class='rparen token'>)</span><span class='dot token'>.</span>
        <span class='at_least identifier id'>at_least</span><span class='dot token'>.</span><span class='twice identifier id'>twice</span><span class='dot token'>.</span><span class='at_most identifier id'>at_most</span><span class='dot token'>.</span><span class='times identifier id'>times</span><span class='lparen token'>(</span><span class='integer val'>10</span><span class='rparen token'>)</span><span class='dot token'>.</span>
        <span class='and_return identifier id'>and_return</span> <span class='lbrace token'>{</span> <span class='rand identifier id'>rand</span> <span class='rbrace token'>}</span>
</pre>
<p>
The following methods may be used to create and refine expectations on a
mock object. See theFlexMock::Expectation for more details.
</p>
<ul>
<li><b>should_receive(<em>method_name</em>)</b>

<p>
Declares that a message named <em>method_name</em> will be sent to the mock
object. Constraints on this expected message (called expectations) may be
chained to the <tt>should_receive</tt> call.
</p>
</li>
<li><b>should_receive(<em>method_name1</em>, <em>method_name2</em>,
&#8230;)</b>

<p>
Define a number of expected messages that have the same constraints.
</p>
</li>
<li><b>should_receive(<em>meth1</em> =&gt; <em>result1</em>, <em>meth2</em>
=&gt; <em>result2</em>, &#8230;)</b>

<p>
Define a number of expected messages that have the same constrants, but
return different values.
</p>
</li>
<li><b>should_expect { |recorder| &#8230; }</b>

<p>
Creates a mock recording object that will translate received method calls
into mock expectations. The recorder is passed to a block supplied with the
<tt>should_expect</tt> method. See examples below.
</p>
</li>
<li><b>with(<em>arglist</em>)</b>

<p>
Declares that this expectation matches messages that match the given
argument list. The <tt>===</tt> operator is used on a argument by argument
basis to determine matching. This means that most literal values match
literally, class values match any instance of a class and regular
expression match any matching string (after a <tt>to_s</tt> conversion).
See argument validators (below) for details on argument validation options.
</p>
</li>
<li><b>with_any_args</b>

<p>
Declares that this expectation matches the message with any argument
(default)
</p>
</li>
<li><b>with_no_args</b>

<p>
Declares that this expectation matches messages with no arguments
</p>
</li>
<li><b>and_return(<em>value</em>)</b>

<p>
Declares that the expected message will return the given value.
</p>
</li>
<li><b>and_return(<em>value1</em>, <em>value2</em>, &#8230;)</b>

<p>
Declares that the expected message will return a series of values. Each
invocation of the message will return the next value in the series. The
last value will be repeatably returned if the number of matching calls
exceeds the number of values.
</p>
</li>
<li><b>and_return { |args, &#8230;| code &#8230; } </b>

<p>
Declares that the expected message will return the yielded value of the
block. The block will receive all the arguments in the message. If the
message was provided a block, it will be passed as the last parameter of
the block&#8217;s argument list.
</p>
</li>
<li><b>returns( &#8230; )</b>

<p>
Alias for <tt>and_return</tt>.
</p>
</li>
<li><b>and_raise(exception, *args)</b>

<p>
Declares that the expected messsage will raise the specified exception. If
<tt>exception</tt> is an exception class, then the raised exception will be
constructed from the class with <tt>new</tt> given the supplied arguments.
If <tt>exception</tt> is an instance of an exception class, then it will be
raised directly.
</p>
</li>
<li><b>raises( &#8230; )</b>

<p>
Alias for <tt>and_raise</tt>.
</p>
</li>
<li><b>and_throw(symbol)</b>

</li>
<li><b>and_throw(symbol, value)</b>

<p>
Declares that the expected messsage will throw the specified symbol. If an
optional value is included, then it will be the value returned from the
corresponding catch statement.
</p>
</li>
<li><b>throws( &#8230; )</b>

<p>
Alias for <tt>and_throw</tt>.
</p>
</li>
<li><b>and_yield(values, &#8230;)</b>

<p>
Declares that the mocked method will receive a block, and the mock will
call that block with the values given. Not providing a block will be an
error. Providing more than one <tt>and_yield</tt> clause one a single
expectation will mean that subsquent mock method calls will yield the
values provided by the additional <tt>and_yield</tt> clause.
</p>
</li>
<li><b>yields( &#8230; )</b>

<p>
Alias for <tt>and_yield( &#8230; )</tt>.
</p>
</li>
<li><b>zero_or_more_times</b>

<p>
Declares that the expected message is may be sent zero or more times
(default, equivalent to <tt>at_least.never</tt>).
</p>
</li>
<li><b>once</b>

<p>
Declares that the expected message is only sent once. <tt>at_least</tt> /
<tt>at_most</tt> modifiers are allowed.
</p>
</li>
<li><b>twice</b>

<p>
Declares that the expected message is only sent twice. <tt>at_least</tt> /
<tt>at_most</tt> modifiers are allowed.
</p>
</li>
<li><b>never</b>

<p>
Declares that the expected message is never sent. <tt>at_least</tt> /
<tt>at_most</tt> modifiers are allowed.
</p>
</li>
<li><b>times(<em>n</em>)</b>

<p>
Declares that the expected message is sent <em>n</em> times.
<tt>at_least</tt> / <tt>at_most</tt> modifiers are allowed.
</p>
</li>
<li><b>at_least</b>

<p>
Modifies the immediately following message count constraint so that it
means the message is sent at least that number of times. E.g.
<tt>at_least.once</tt> means the message is sent at least once during the
test, but may be sent more often. Both <tt>at_least</tt> and
<tt>at_most</tt> may be specified on the same expectation.
</p>
</li>
<li><b>at_most</b>

<p>
Similar to <tt>at_least</tt>, but puts an upper limit on the number of
messages. Both <tt>at_least</tt> and <tt>at_most</tt> may be specified on
the same expectation.
</p>
</li>
<li><b>ordered</b>

<p>
Declares that the expected message is ordered and is expected to be
received in a certain position in a sequence of messages. The message
should arrive after and previously declared ordered messages and prior to
any following declared ordered messages. Unordered messages are ignored
when considering the message order.
</p>
<p>
Normally ordering is performed only against calls in the same mock object.
If the &quot;globally&quot; adjective is used, then ordering is performed
against the other globally ordered method calls.
</p>
</li>
<li><b>ordered(<em>group</em>)</b>

<p>
Declare that the expected message belongs to an order group. Methods within
an order group may be received in any order. Ordered messages outside the
group must be received either before or after all of the grouped messages.
</p>
<p>
For example, in the following, messages <tt>flip</tt> and <tt>flop</tt> may
be received in any order (because they are in the same group), but must
occur strictly after <tt>start</tt> but before <tt>end</tt>. The message
<tt>any_time</tt> may be received at any time because it is not ordered.
</p>
<pre class="code">
  <span class='m identifier id'>m</span> <span class='assign token'>=</span> <span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='rparen token'>)</span>
  <span class='m identifier id'>m</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:any_time</span><span class='rparen token'>)</span>
  <span class='m identifier id'>m</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:start</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='ordered identifier id'>ordered</span>
  <span class='m identifier id'>m</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:flip</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='ordered identifier id'>ordered</span><span class='lparen token'>(</span><span class='symbol val'>:flip_flop_group</span><span class='rparen token'>)</span>
  <span class='m identifier id'>m</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:flop</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='ordered identifier id'>ordered</span><span class='lparen token'>(</span><span class='symbol val'>:flip_flop_group</span><span class='rparen token'>)</span>
  <span class='m identifier id'>m</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:end</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='ordered identifier id'>ordered</span>
</pre>
<p>
Normally ordering is performed only against calls in the same mock object.
If the &quot;globally&quot; adjective is used, then ordering is performed
against the other globally ordered method calls.
</p>
</li>
<li><b>globally.ordered</b>

</li>
<li><b>globally.ordered(<em>group_name</em>)</b>

<p>
When modified by the &quot;globally&quot; adjective, the mock call will be
ordered against other globally ordered methods in any of the mock objects
in the same container (i.e. same test). All the options of the per-mock
ordering are available in the globally ordered method calls.
</p>
</li>
<li><b>by_default</b>

<p>
Marks the expectation as a default. Default expectations act as normal as
long as there are no non-default expectations for the same method name. As
soon as a non-default expectation is defined, all default expectations for
that method name are ignored.
</p>
<p>
Default expectations allow you to setup a set of default behaviors for
various methods in the setup of a test suite, and then override only the
methods that need special handling in any given test.
</p>
</li>
<li><b>mock</b>

<p>
Expectation constraints always return the expectation so that the
constraints can be chained. If you wish to do a one-liner and assign the
mock to a variable, the <tt>mock</tt> method on an expectation will return
the original mock object.
</p>
<pre class="code">
  <span class='m identifier id'>m</span> <span class='assign token'>=</span> <span class='flexmock identifier id'>flexmock</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:hello</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='once identifier id'>once</span><span class='dot token'>.</span><span class='and_return identifier id'>and_return</span><span class='lparen token'>(</span><span class='string val'>&quot;World&quot;</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='mock identifier id'>mock</span>
</pre>
<p>
<b>NOTE:</b> &lt;em&gt;Using <b>mock</b> when specifying a Demeter mock
chain will return the last mock of the chain, which might not be what you
expect.
</p>
</li>
</ul>
<h3>Argument Validation</h3>
<p>
The values passed to the <tt>with</tt> declarator determine the criteria
for matching expectations. The first expectation found that matches the
arguments in a mock method call will be used to validate that mock method
call.
</p>
<p>
The following rules are used for argument matching:
</p>
<ul>
<li>A <tt>with</tt> parameter that is a class object will match any actual
argument that is an instance of that class.

<p>
Examples:
</p>
<pre class="code">
   <span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='Integer constant id'>Integer</span><span class='rparen token'>)</span>     <span class='will identifier id'>will</span> <span class='match identifier id'>match</span>    <span class='f identifier id'>f</span><span class='lparen token'>(</span><span class='integer val'>3</span><span class='rparen token'>)</span>
</pre>
</li>
<li>A regular expression will match any actual argument that matches the
regular expression. Non-string actual arguments are converted to strings
via <tt>to_s</tt> before applying the regular expression.

<p>
Examples:
</p>
<pre class="code">
  <span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='regexp val'>/^src/</span><span class='rparen token'>)</span>      <span class='will identifier id'>will</span> <span class='match identifier id'>match</span>    <span class='f identifier id'>f</span><span class='lparen token'>(</span><span class='string val'>&quot;src_object&quot;</span><span class='rparen token'>)</span>
  <span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='regexp val'>/^3\./</span><span class='rparen token'>)</span>      <span class='will identifier id'>will</span> <span class='match identifier id'>match</span>    <span class='f identifier id'>f</span><span class='lparen token'>(</span><span class='float val'>3.1415972</span><span class='rparen token'>)</span>
</pre>
</li>
<li>Most other objects will match based on equal values.

<p>
Examples:
</p>
<pre class="code">
    <span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='integer val'>3</span><span class='rparen token'>)</span>         <span class='will identifier id'>will</span> <span class='match identifier id'>match</span>    <span class='f identifier id'>f</span><span class='lparen token'>(</span><span class='integer val'>3</span><span class='rparen token'>)</span>
    <span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='string val'>&quot;hello&quot;</span><span class='rparen token'>)</span>   <span class='will identifier id'>will</span> <span class='match identifier id'>match</span>    <span class='f identifier id'>f</span><span class='lparen token'>(</span><span class='string val'>&quot;hello&quot;</span><span class='rparen token'>)</span>
</pre>
</li>
<li>If you wish to override the default matching behavior and force matching by
equality, you can use the FlexMock.eq convenience method. This is mostly
used when you wish to match class objects, since the default matching
behavior for class objects is to match instances, not themselves.

<p>
Examples:
</p>
<pre class="code">
    <span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='eq identifier id'>eq</span><span class='lparen token'>(</span><span class='Integer constant id'>Integer</span><span class='rparen token'>)</span><span class='rparen token'>)</span>             <span class='will identifier id'>will</span> <span class='match identifier id'>match</span>       <span class='f identifier id'>f</span><span class='lparen token'>(</span><span class='Integer constant id'>Integer</span><span class='rparen token'>)</span>
    <span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='eq identifier id'>eq</span><span class='lparen token'>(</span><span class='Integer constant id'>Integer</span><span class='rparen token'>)</span><span class='rparen token'>)</span>             <span class='will identifier id'>will</span> <span class='NOT constant id'>NOT</span> <span class='match identifier id'>match</span>   <span class='f identifier id'>f</span><span class='lparen token'>(</span><span class='integer val'>3</span><span class='rparen token'>)</span>
</pre>
<p>
<b>Note:</b> If you do not use the FlexMock::TestCase Test Unit integration
module, or the FlexMock::ArgumentTypes module, you will have to fully
qualify the <tt>eq</tt> method. This is true of all the special argument
matches (<tt>eq</tt>, <tt>on</tt>, <tt>any</tt>, <tt>hsh</tt> and
<tt>ducktype</tt>).
</p>
<pre class="code">
    <span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='FlexMock constant id'>FlexMock</span><span class='dot token'>.</span><span class='eq identifier id'>eq</span><span class='lparen token'>(</span><span class='Integer constant id'>Integer</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
    <span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='FlexMock constant id'>FlexMock</span><span class='dot token'>.</span><span class='on identifier id'>on</span> <span class='lbrace token'>{</span> <span class='code identifier id'>code</span> <span class='rbrace token'>}</span><span class='rparen token'>)</span>
    <span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='FlexMock constant id'>FlexMock</span><span class='dot token'>.</span><span class='any identifier id'>any</span><span class='rparen token'>)</span>
    <span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='FlexMock constant id'>FlexMock</span><span class='dot token'>.</span><span class='hsh identifier id'>hsh</span><span class='lparen token'>(</span><span class='symbol val'>:tag</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='integer val'>3</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
    <span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='FlexMock constant id'>FlexMock</span><span class='dot token'>.</span><span class='ducktype identifier id'>ducktype</span><span class='lparen token'>(</span><span class='symbol val'>:wag</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>&quot;dog&quot;</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
</pre>
</li>
<li>If you wish to match a hash on <em>some</em> of its values, the
FlexMock.hsh(&#8230;) method will work. Only specify the hash values you
are interested in, the others will be ignored.

<pre class="code">
    <span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='hsh identifier id'>hsh</span><span class='lparen token'>(</span><span class='symbol val'>:run</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='true true kw'>true</span><span class='rparen token'>)</span><span class='rparen token'>)</span>  <span class='will identifier id'>will</span> <span class='match identifier id'>match</span>    <span class='f identifier id'>f</span><span class='lparen token'>(</span><span class='symbol val'>:run</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='true true kw'>true</span><span class='comma token'>,</span> <span class='symbol val'>:stop</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='false false kw'>false</span><span class='rparen token'>)</span>
</pre>
</li>
<li>If you wish to match any object that responds to a certain set of methods,
use the FlexMock.ducktype method.

<pre class="code">
    <span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='ducktype identifier id'>ducktype</span><span class='lparen token'>(</span><span class='symbol val'>:to_str</span><span class='rparen token'>)</span><span class='rparen token'>)</span>     <span class='will identifier id'>will</span> <span class='match identifier id'>match</span>   <span class='f identifier id'>f</span><span class='lparen token'>(</span><span class='string val'>&quot;string&quot;</span><span class='rparen token'>)</span>
    <span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='ducktype identifier id'>ducktype</span><span class='lparen token'>(</span><span class='symbol val'>:wag</span><span class='comma token'>,</span> <span class='symbol val'>:bark</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='will identifier id'>will</span> <span class='match identifier id'>match</span>   <span class='f identifier id'>f</span><span class='lparen token'>(</span><span class='dog identifier id'>dog</span><span class='rparen token'>)</span>
                                <span class='lparen token'>(</span><span class='assuming identifier id'>assuming</span> <span class='dog identifier id'>dog</span> <span class='implements identifier id'>implements</span> <span class='wag identifier id'>wag</span> <span class='and and kw'>and</span> <span class='bark identifier id'>bark</span><span class='rparen token'>)</span>
</pre>
</li>
<li>If you wish to match <em>anything</em>, then use the <tt>FlexMock.any</tt>
method in the with argument list.

<p>
Examples (assumes either the FlexMock::TestCase or FlexMock::ArgumentTypes
mix-ins has been included):
</p>
<pre class="code">
    <span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='any identifier id'>any</span><span class='rparen token'>)</span>             <span class='will identifier id'>will</span> <span class='match identifier id'>match</span>       <span class='f identifier id'>f</span><span class='lparen token'>(</span><span class='integer val'>3</span><span class='rparen token'>)</span>
    <span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='any identifier id'>any</span><span class='rparen token'>)</span>             <span class='will identifier id'>will</span> <span class='match identifier id'>match</span>       <span class='f identifier id'>f</span><span class='lparen token'>(</span><span class='string val'>&quot;hello&quot;</span><span class='rparen token'>)</span>
    <span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='any identifier id'>any</span><span class='rparen token'>)</span>             <span class='will identifier id'>will</span> <span class='match identifier id'>match</span>       <span class='f identifier id'>f</span><span class='lparen token'>(</span><span class='Integer constant id'>Integer</span><span class='rparen token'>)</span>
    <span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='any identifier id'>any</span><span class='rparen token'>)</span>             <span class='will identifier id'>will</span> <span class='match identifier id'>match</span>       <span class='f identifier id'>f</span><span class='lparen token'>(</span><span class='nil nil kw'>nil</span><span class='rparen token'>)</span>
</pre>
</li>
<li>If you wish to specify a complex matching criteria, use the
<tt>FlexMock.on(&amp;block)</tt> with the logic contained in the block.

<p>
Examples (assumes FlexMock::ArguementTypes has been included):
</p>
<pre class="code">
    <span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='on identifier id'>on</span> <span class='lbrace token'>{</span> <span class='bitor op'>|</span><span class='arg identifier id'>arg</span><span class='bitor op'>|</span> <span class='lparen token'>(</span><span class='arg identifier id'>arg</span> <span class='mod op'>%</span> <span class='integer val'>2</span><span class='rparen token'>)</span> <span class='eq op'>==</span> <span class='integer val'>0</span> <span class='rbrace token'>}</span> <span class='rparen token'>)</span>
</pre>
<p>
will match any even integer.
</p>
</li>
<li>If you wish to match a method call where a block is given, add
<tt>Proc</tt> as the last argument to <tt>with</tt>.

<p>
Example:
</p>
<pre class="code">
    <span class='m identifier id'>m</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:foo</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='Integer constant id'>Integer</span><span class='comma token'>,</span><span class='Proc constant id'>Proc</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='and_return identifier id'>and_return</span><span class='lparen token'>(</span><span class='symbol val'>:got_block</span><span class='rparen token'>)</span>
    <span class='m identifier id'>m</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:foo</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='Integer constant id'>Integer</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='and_return identifier id'>and_return</span><span class='lparen token'>(</span><span class='symbol val'>:no_block</span><span class='rparen token'>)</span>
</pre>
<p>
will cause the mock to return the following:
</p>
<pre class="code">
   <span class='m identifier id'>m</span><span class='dot token'>.</span><span class='foo identifier id'>foo</span><span class='lparen token'>(</span><span class='integer val'>1</span><span class='rparen token'>)</span> <span class='lbrace token'>{</span> <span class='rbrace token'>}</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='returns identifier id'>returns</span> <span class='symbol val'>:got_block</span>
   <span class='m identifier id'>m</span><span class='dot token'>.</span><span class='foo identifier id'>foo</span><span class='lparen token'>(</span><span class='integer val'>1</span><span class='rparen token'>)</span>     <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='returns identifier id'>returns</span> <span class='symbol val'>:no_block</span>
</pre>
</li>
</ul>
<h3>Creating Partial Mocks</h3>
<p>
Sometimes it is useful to mock the behavior of one or two methods in an
existing object without changing the behavior of the rest of the object. If
you pass a real object to the <tt>flexmock</tt> method, it will allow you
to use that real object in your test and will just mock out the one or two
methods that you specify.
</p>
<p>
For example, suppose that a Dog object uses a Woofer object to bark. The
code for Dog looks like this (we will leave the code for Woofer to your
imagination):
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='Dog constant id'>Dog</span>
    <span class='def def kw'>def</span> <span class='initialize identifier id'>initialize</span>
      <span class='@woofer ivar id'>@woofer</span> <span class='assign token'>=</span> <span class='Woofer constant id'>Woofer</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
    <span class='end end kw'>end</span>
    <span class='def def kw'>def</span> <span class='bark identifier id'>bark</span>
      <span class='@woofer ivar id'>@woofer</span><span class='dot token'>.</span><span class='woof identifier id'>woof</span>
    <span class='end end kw'>end</span>
    <span class='def def kw'>def</span> <span class='wag identifier id'>wag</span>
      <span class='symbol val'>:happy</span>
    <span class='end end kw'>end</span>
  <span class='end end kw'>end</span>
</pre>
<p>
Now we want to test Dog, but using a real Woofer object in the test is a
real pain (why? &#8230; well because Woofer plays a sound file of a dog
barking, and that&#8217;s really annoying during testing).
</p>
<p>
So, how can we create a Dog object with mocked Woofer? All we need to do is
allow FlexMock to replace the <tt>bark</tt> method.
</p>
<p>
Here&#8217;s the test code:
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='TestDogBarking constant id'>TestDogBarking</span> <span class='lt op'>&lt;</span> <span class='Test constant id'>Test</span><span class='colon2 op'>::</span><span class='Unit constant id'>Unit</span><span class='colon2 op'>::</span><span class='TestCase constant id'>TestCase</span>
    <span class='include identifier id'>include</span> <span class='FlexMock constant id'>FlexMock</span><span class='colon2 op'>::</span><span class='TestCase constant id'>TestCase</span>

    <span class='comment val'># Setup the tests by mocking the &lt;tt&gt;new&lt;/tt&gt; method of</span>
    <span class='comment val'># Woofer and return a mock woofer.</span>
    <span class='def def kw'>def</span> <span class='setup identifier id'>setup</span>
      <span class='@dog ivar id'>@dog</span> <span class='assign token'>=</span> <span class='Dog constant id'>Dog</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
      <span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='@dog ivar id'>@dog</span><span class='comma token'>,</span> <span class='symbol val'>:bark</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='symbol val'>:grrr</span><span class='rparen token'>)</span>
    <span class='end end kw'>end</span>

    <span class='def def kw'>def</span> <span class='test_dog identifier id'>test_dog</span>
      <span class='assert_equal identifier id'>assert_equal</span> <span class='symbol val'>:grrr</span><span class='comma token'>,</span> <span class='@dog ivar id'>@dog</span><span class='dot token'>.</span><span class='bark identifier id'>bark</span>   <span class='comment val'># Mocked Method</span>
      <span class='assert_equal identifier id'>assert_equal</span> <span class='symbol val'>:happy</span><span class='comma token'>,</span> <span class='@dog ivar id'>@dog</span><span class='dot token'>.</span><span class='wag identifier id'>wag</span>    <span class='comment val'># Normal Method</span>
    <span class='end end kw'>end</span>
  <span class='end end kw'>end</span>
</pre>
<p>
The nice thing about this technique is that after the test is over, the
mocked out methods are returned to their normal state. Outside the test
everything is back to normal.
</p>
<p>
<b>NOTE:</b> In previous versions of FlexMock, partial mocking was called
&quot;stubs&quot; and the <tt>flexstub</tt> method was used to create the
partial mocks. Although partial mocks were often used as stubs, the
terminology was not quite correct. The current version of FlexMock uses the
<tt>flexmock</tt> method to create both regular stubs and partial stubs. A
version of the <tt>flexstub</tt> method is included for backwards
compatibility. See Martin Fowler&#8217;s article <em>Mocks Aren&#8217;t
Stubs</em> (http://www.martinfowler.com/articles/mocksArentStubs.html) for
a better understanding of the difference between mocks and stubs.
</p>
<p>
This partial mocking technique was inspired by the <tt>Stuba</tt> library
in the <tt>Mocha</tt> project.
</p>
<h3>Mocking Class Objects</h3>
<p>
In the previous example we mocked out the <tt>bark</tt> method of a Dog
object to avoid invoking the Woofer object. Perhaps a better technique
would be to mock the Woofer object directly. But Dog uses Woofer explicitly
so we cannot just pass in a mock object for Dog to use.
</p>
<p>
But wait, we can add mock behavior to any existing object, and classes are
objects in Ruby. So why don&#8217;t we just mock out the Woofer class
object to return mocks for us.
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='TestDogBarking constant id'>TestDogBarking</span> <span class='lt op'>&lt;</span> <span class='Test constant id'>Test</span><span class='colon2 op'>::</span><span class='Unit constant id'>Unit</span><span class='colon2 op'>::</span><span class='TestCase constant id'>TestCase</span>
    <span class='include identifier id'>include</span> <span class='FlexMock constant id'>FlexMock</span><span class='colon2 op'>::</span><span class='TestCase constant id'>TestCase</span>

    <span class='comment val'># Setup the tests by mocking the &lt;tt&gt;new&lt;/tt&gt; method of</span>
    <span class='comment val'># Woofer and return a mock woofer.</span>
    <span class='def def kw'>def</span> <span class='setup identifier id'>setup</span>
      <span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='Woofer constant id'>Woofer</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:new</span><span class='rparen token'>)</span><span class='dot token'>.</span>
         <span class='and_return identifier id'>and_return</span><span class='lparen token'>(</span><span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='symbol val'>:woof</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='symbol val'>:grrr</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
      <span class='@dog ivar id'>@dog</span> <span class='assign token'>=</span> <span class='Dog constant id'>Dog</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
    <span class='end end kw'>end</span>

    <span class='def def kw'>def</span> <span class='test_dog identifier id'>test_dog</span>
      <span class='assert_equal identifier id'>assert_equal</span> <span class='symbol val'>:grrrr</span><span class='comma token'>,</span> <span class='@dog ivar id'>@dog</span><span class='dot token'>.</span><span class='bark identifier id'>bark</span>  <span class='comment val'># Calls woof on mock object</span>
                                      <span class='comment val'># returned by Woofer.new</span>
    <span class='end end kw'>end</span>
  <span class='end end kw'>end</span>
</pre>
<h3>Mocking Behavior in All Instances Created by a Class Object</h3>
<p>
Sometimes returning a single mock object is not enough. Occasionally you
want to mock <em>every</em> instance object created by a class. FlexMock
makes this very easy.
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='TestDogBarking constant id'>TestDogBarking</span> <span class='lt op'>&lt;</span> <span class='Test constant id'>Test</span><span class='colon2 op'>::</span><span class='Unit constant id'>Unit</span><span class='colon2 op'>::</span><span class='TestCase constant id'>TestCase</span>
    <span class='include identifier id'>include</span> <span class='FlexMock constant id'>FlexMock</span><span class='colon2 op'>::</span><span class='TestCase constant id'>TestCase</span>

    <span class='comment val'># Setup the tests by mocking Woofer to always</span>
    <span class='comment val'># return partial mocks.</span>
    <span class='def def kw'>def</span> <span class='setup identifier id'>setup</span>
      <span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='Woofer constant id'>Woofer</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='new_instances identifier id'>new_instances</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:woof</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='symbol val'>:grrr</span><span class='rparen token'>)</span>
    <span class='end end kw'>end</span>

    <span class='def def kw'>def</span> <span class='test_dog identifier id'>test_dog</span>
      <span class='assert_equal identifier id'>assert_equal</span> <span class='symbol val'>:grrrr</span><span class='comma token'>,</span> <span class='Dog constant id'>Dog</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='dot token'>.</span><span class='bark identifier id'>bark</span>  <span class='comment val'># All dog objects</span>
      <span class='assert_equal identifier id'>assert_equal</span> <span class='symbol val'>:grrrr</span><span class='comma token'>,</span> <span class='Dog constant id'>Dog</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='dot token'>.</span><span class='bark identifier id'>bark</span>  <span class='comment val'># are mocked.</span>
    <span class='end end kw'>end</span>
  <span class='end end kw'>end</span>
</pre>
<p>
Note that FlexMock adds the mock expectations after the original
<tt>new</tt> method has completed. If the original version of <tt>new</tt>
yields the newly created instance to a block, that block will get an
non-mocked version of the object.
</p>
<p>
Note that <tt>new_instances</tt> will accept a block if you wish to mock
several methods at the same time. E.g.
</p>
<pre class="code">
      <span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='Woofer constant id'>Woofer</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='new_instances identifier id'>new_instances</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='m identifier id'>m</span><span class='bitor op'>|</span>
        <span class='m identifier id'>m</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:woof</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='twice identifier id'>twice</span><span class='dot token'>.</span><span class='and_return identifier id'>and_return</span><span class='lparen token'>(</span><span class='symbol val'>:grrr</span><span class='rparen token'>)</span>
        <span class='m identifier id'>m</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:wag</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='at_least identifier id'>at_least</span><span class='dot token'>.</span><span class='once identifier id'>once</span><span class='dot token'>.</span><span class='and_return identifier id'>and_return</span><span class='lparen token'>(</span><span class='symbol val'>:happy</span><span class='rparen token'>)</span>
      <span class='end end kw'>end</span>
</pre>
<h3>Default Expectations on Mocks</h3>
<p>
Sometimes you want to setup a bunch of default expectations that are pretty
much for a number of different tests. Then in the individual tests, you
would like to override the default behavior on just that one method you are
testing at the moment. You can do that by using the <tt>by_default</tt>
modifier.
</p>
<p>
In your test setup you might have:
</p>
<pre class="code">
  <span class='def def kw'>def</span> <span class='setup identifier id'>setup</span>
    <span class='@mock_dog ivar id'>@mock_dog</span> <span class='assign token'>=</span> <span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='string val'>&quot;Fido&quot;</span><span class='rparen token'>)</span>
    <span class='@mock_dog ivar id'>@mock_dog</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:tail</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='symbol val'>:a_tail</span><span class='comma token'>,</span> <span class='symbol val'>:bark</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>&quot;woof&quot;</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='by_default identifier id'>by_default</span>
  <span class='end end kw'>end</span>
</pre>
<p>
The behaviors for :tail and :bark are good for most of the tests, but
perhaps you wish to verify that :bark is called exactly once in a given
test. Since :bark by default has no count expectations, you can override
the default in the given test.
</p>
<pre class="code">
  <span class='def def kw'>def</span> <span class='test_something_where_bark_must_be_called_once identifier id'>test_something_where_bark_must_be_called_once</span>
    <span class='@mock_dog ivar id'>@mock_dog</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:bark</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>&quot;woof&quot;</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='once identifier id'>once</span>

    <span class='comment val'># At this point, the default for :bark is ignored,</span>
    <span class='comment val'># and the &quot;woof&quot; value will be returned.</span>

    <span class='comment val'># However, the default for :tail (which returns :a_tail)</span>
    <span class='comment val'># is still active.</span>
  <span class='end end kw'>end</span>
</pre>
<p>
By setting defaults, your individual tests don&#8217;t have to concern
themselves with details of all the default setup. But the details of the
overrides are right there in the body of the test.
</p>
<h3>Mocking Law of Demeter Violations</h3>
<p>
The Law of Demeter says that you should only invoke methods on objects to
which you have a direct connection, e.g. parameters, instance variables,
and local variables. You can usually detect Law of Demeter violations by
the excessive number of periods in an expression. For example:
</p>
<pre class="code">
     <span class='car identifier id'>car</span><span class='dot token'>.</span><span class='chassis identifier id'>chassis</span><span class='dot token'>.</span><span class='axle identifier id'>axle</span><span class='dot token'>.</span><span class='universal_joint identifier id'>universal_joint</span><span class='dot token'>.</span><span class='cog identifier id'>cog</span><span class='dot token'>.</span><span class='turn identifier id'>turn</span>
</pre>
<p>
The Law of Demeter has a very big impact on mocking. If you need to mock
the &quot;turn&quot; method on &quot;cog&quot;, you first have to mock
chassis, axle, and universal_joint.
</p>
<pre class="code">
    <span class='comment val'># Manually mocking a Law of Demeter violation</span>
    <span class='cog identifier id'>cog</span> <span class='assign token'>=</span> <span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='string val'>&quot;cog&quot;</span><span class='rparen token'>)</span>
    <span class='cog identifier id'>cog</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:turn</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='once identifier id'>once</span><span class='dot token'>.</span><span class='and_return identifier id'>and_return</span><span class='lparen token'>(</span><span class='symbol val'>:ok</span><span class='rparen token'>)</span>
    <span class='joint identifier id'>joint</span> <span class='assign token'>=</span> <span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='string val'>&quot;gear&quot;</span><span class='comma token'>,</span> <span class='symbol val'>:cog</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='cog identifier id'>cog</span><span class='rparen token'>)</span>
    <span class='axle identifier id'>axle</span> <span class='assign token'>=</span> <span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='string val'>&quot;axle&quot;</span><span class='comma token'>,</span> <span class='symbol val'>:universal_joint</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='joint identifier id'>joint</span><span class='rparen token'>)</span>
    <span class='chassis identifier id'>chassis</span> <span class='assign token'>=</span> <span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='string val'>&quot;chassis&quot;</span><span class='comma token'>,</span> <span class='symbol val'>:axle</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='axle identifier id'>axle</span><span class='rparen token'>)</span>
    <span class='car identifier id'>car</span> <span class='assign token'>=</span> <span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='string val'>&quot;car&quot;</span><span class='comma token'>,</span> <span class='symbol val'>:chassis</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='chassis identifier id'>chassis</span><span class='rparen token'>)</span>
</pre>
<p>
Yuck!
</p>
<p>
The best course of action is to avoid Law of Demeter violations. Then your
mocking exploits will be very simple. However, sometimes you have to deal
with code that already has a Demeter chain of method calls. So for those
cases where you can&#8217;t avoid it, FlexMock will allow you to easily
mock Demeter method chains.
</p>
<p>
Here&#8217;s an example of Demeter chain mocking:
</p>
<pre class="code">
    <span class='comment val'># Demeter chain mocking using the short form.</span>
    <span class='car identifier id'>car</span> <span class='assign token'>=</span> <span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='string val'>&quot;car&quot;</span><span class='rparen token'>)</span>
    <span class='car identifier id'>car</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span> <span class='string val'>&quot;chassis.axle.universal_joint.cog.turn&quot;</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='symbol val'>:ok</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='once identifier id'>once</span>
</pre>
<p>
You can also use the long form:
</p>
<pre class="code">
    <span class='comment val'># Demeter chain mocking using the long form.</span>
    <span class='car identifier id'>car</span> <span class='assign token'>=</span> <span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='string val'>&quot;car&quot;</span><span class='rparen token'>)</span>
    <span class='car identifier id'>car</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='string val'>&quot;chassis.axle.universal_joint.cog.turn&quot;</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='once identifier id'>once</span><span class='dot token'>.</span>
      <span class='and_return identifier id'>and_return</span><span class='lparen token'>(</span><span class='symbol val'>:ok</span><span class='rparen token'>)</span>
</pre>
<p>
That&#8217;s it. Anywhere FlexMock accepts a method name for mocking, you
can use a demeter chain and FlexMock will attempt to do the right thing.
</p>
<p>
But beware, there are a few limitations.
</p>
<p>
The all the methods in the chain, except for the last one, will mocked to
return a mock object. That mock object, in turn, will be mocked so as to
respond to the next method in the chain, returning the following mock. And
so on. If you try to manually mock out any of the chained methods, you
could easily interfer with the mocking specified by the Demeter chain.
FlexMock will attempt to catch problems when it can, but there are
certainly scenarios where it cannot detect the problem beforehand.
</p>
<h2>Examples</h2>
<h3>Create a simple mock object that returns a value for a set of method calls</h3>
<pre class="code">
   <span class='require identifier id'>require</span> <span class='string val'>'flexmock/test_unit'</span>

   <span class='class class kw'>class</span> <span class='TestSimple constant id'>TestSimple</span> <span class='lt op'>&lt;</span> <span class='Test constant id'>Test</span><span class='colon2 op'>::</span><span class='Unit constant id'>Unit</span><span class='colon2 op'>::</span><span class='TestCase constant id'>TestCase</span>
     <span class='def def kw'>def</span> <span class='test_simple_mock identifier id'>test_simple_mock</span>
       <span class='m identifier id'>m</span> <span class='assign token'>=</span> <span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='symbol val'>:pi</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='float val'>3.1416</span><span class='comma token'>,</span> <span class='symbol val'>:e</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='float val'>2.71</span><span class='rparen token'>)</span>
       <span class='assert_equal identifier id'>assert_equal</span> <span class='float val'>3.1416</span><span class='comma token'>,</span> <span class='m identifier id'>m</span><span class='dot token'>.</span><span class='pi identifier id'>pi</span>
       <span class='assert_equal identifier id'>assert_equal</span> <span class='float val'>2.71</span><span class='comma token'>,</span> <span class='m identifier id'>m</span><span class='dot token'>.</span><span class='e identifier id'>e</span>
     <span class='end end kw'>end</span>
   <span class='end end kw'>end</span>
</pre>
<h3>Create a mock object that returns an undefined object for method calls</h3>
<pre class="code">
   <span class='require identifier id'>require</span> <span class='string val'>'flexmock/test_unit'</span>

   <span class='class class kw'>class</span> <span class='TestUndefined constant id'>TestUndefined</span> <span class='lt op'>&lt;</span> <span class='Test constant id'>Test</span><span class='colon2 op'>::</span><span class='Unit constant id'>Unit</span><span class='colon2 op'>::</span><span class='TestCase constant id'>TestCase</span>
     <span class='def def kw'>def</span> <span class='test_undefined_values identifier id'>test_undefined_values</span>
       <span class='m identifier id'>m</span> <span class='assign token'>=</span> <span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='string val'>&quot;mock&quot;</span><span class='rparen token'>)</span>
       <span class='m identifier id'>m</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:divide_by</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='integer val'>0</span><span class='rparen token'>)</span><span class='dot token'>.</span>
         <span class='and_return_undefined identifier id'>and_return_undefined</span>
       <span class='assert_equal identifier id'>assert_equal</span> <span class='FlexMock constant id'>FlexMock</span><span class='dot token'>.</span><span class='undefined identifier id'>undefined</span><span class='comma token'>,</span> <span class='m identifier id'>m</span><span class='dot token'>.</span><span class='divide_by identifier id'>divide_by</span><span class='lparen token'>(</span><span class='integer val'>0</span><span class='rparen token'>)</span>
     <span class='end end kw'>end</span>
   <span class='end end kw'>end</span>
</pre>
<h3>Expect multiple queries and a single update</h3>
<p>
Multiple calls to the query method will be allows, and calls may have any
argument list. Each call to query will return the three element array [1,
2, 3]. The call to update must have a specific argument of 5.
</p>
<pre class="code">
   <span class='require identifier id'>require</span> <span class='string val'>'flexmock/test_unit'</span>

   <span class='class class kw'>class</span> <span class='TestDb constant id'>TestDb</span> <span class='lt op'>&lt;</span> <span class='Test constant id'>Test</span><span class='colon2 op'>::</span><span class='Unit constant id'>Unit</span><span class='colon2 op'>::</span><span class='TestCase constant id'>TestCase</span>
     <span class='def def kw'>def</span> <span class='test_db identifier id'>test_db</span>
       <span class='db identifier id'>db</span> <span class='assign token'>=</span> <span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='string val'>'db'</span><span class='rparen token'>)</span>
       <span class='db identifier id'>db</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:query</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='and_return identifier id'>and_return</span><span class='lparen token'>(</span><span class='lbrack token'>[</span><span class='integer val'>1</span><span class='comma token'>,</span><span class='integer val'>2</span><span class='comma token'>,</span><span class='integer val'>3</span><span class='rbrack token'>]</span><span class='rparen token'>)</span>
       <span class='db identifier id'>db</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:update</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='integer val'>5</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='and_return identifier id'>and_return</span><span class='lparen token'>(</span><span class='nil nil kw'>nil</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='once identifier id'>once</span>
       <span class='comment val'># test code here</span>
     <span class='end end kw'>end</span>
   <span class='end end kw'>end</span>
</pre>
<h3>Expect all queries before any updates</h3>
<p>
(This and following examples assume that the
&#8216;flexmock/test_unit&#8217; file has been required.)
</p>
<p>
All the query message must occur before any of the update messages.
</p>
<pre class="code">
   <span class='def def kw'>def</span> <span class='test_query_and_update identifier id'>test_query_and_update</span>
     <span class='db identifier id'>db</span> <span class='assign token'>=</span> <span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='string val'>'db'</span><span class='rparen token'>)</span>
     <span class='db identifier id'>db</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:query</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='and_return identifier id'>and_return</span><span class='lparen token'>(</span><span class='lbrack token'>[</span><span class='integer val'>1</span><span class='comma token'>,</span><span class='integer val'>2</span><span class='comma token'>,</span><span class='integer val'>3</span><span class='rbrack token'>]</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='ordered identifier id'>ordered</span>
     <span class='db identifier id'>db</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:update</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='and_return identifier id'>and_return</span><span class='lparen token'>(</span><span class='nil nil kw'>nil</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='ordered identifier id'>ordered</span>
     <span class='comment val'># test code here</span>
   <span class='end end kw'>end</span>
</pre>
<h3>Expect several queries with different parameters</h3>
<p>
The queries should happen after startup but before finish. The queries
themselves may happen in any order (because they are in the same order
group). The first two queries should happen exactly once, but the third
query (which matches any query call with a four character parameter) may be
called multiple times (but at least once). Startup and finish must also
happen exactly once.
</p>
<p>
Also note that we use the <tt>with</tt> method to match different argument
values to figure out what value to return.
</p>
<pre class="code">
   <span class='def def kw'>def</span> <span class='test_ordered_queries identifier id'>test_ordered_queries</span>
     <span class='db identifier id'>db</span> <span class='assign token'>=</span> <span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='string val'>'db'</span><span class='rparen token'>)</span>
     <span class='db identifier id'>db</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:startup</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='once identifier id'>once</span><span class='dot token'>.</span><span class='ordered identifier id'>ordered</span>
     <span class='db identifier id'>db</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:query</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='string val'>&quot;CPWR&quot;</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='and_return identifier id'>and_return</span><span class='lparen token'>(</span><span class='float val'>12.3</span><span class='rparen token'>)</span><span class='dot token'>.</span>
       <span class='once identifier id'>once</span><span class='dot token'>.</span><span class='ordered identifier id'>ordered</span><span class='lparen token'>(</span><span class='symbol val'>:queries</span><span class='rparen token'>)</span>
     <span class='db identifier id'>db</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:query</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='string val'>&quot;MSFT&quot;</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='and_return identifier id'>and_return</span><span class='lparen token'>(</span><span class='float val'>10.0</span><span class='rparen token'>)</span><span class='dot token'>.</span>
       <span class='once identifier id'>once</span><span class='dot token'>.</span><span class='ordered identifier id'>ordered</span><span class='lparen token'>(</span><span class='symbol val'>:queries</span><span class='rparen token'>)</span>
     <span class='db identifier id'>db</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:query</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='with identifier id'>with</span><span class='lparen token'>(</span><span class='regexp val'>/^....$/</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='and_return identifier id'>and_return</span><span class='lparen token'>(</span><span class='float val'>3.3</span><span class='rparen token'>)</span><span class='dot token'>.</span>
       <span class='at_least identifier id'>at_least</span><span class='dot token'>.</span><span class='once identifier id'>once</span><span class='dot token'>.</span><span class='ordered identifier id'>ordered</span><span class='lparen token'>(</span><span class='symbol val'>:queries</span><span class='rparen token'>)</span>
     <span class='db identifier id'>db</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:finish</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='once identifier id'>once</span><span class='dot token'>.</span><span class='ordered identifier id'>ordered</span>
     <span class='comment val'># test code here</span>
   <span class='end end kw'>end</span>
</pre>
<h3>Same as above, but using the Record Mode interface</h3>
<p>
The record mode interface offers much the same features as the
<tt>should_receive</tt> interface introduced so far, but it allows the
messages to be sent directly to a recording object rather than be specified
indirectly using a symbol.
</p>
<pre class="code">
   <span class='def def kw'>def</span> <span class='test_ordered_queries_in_record_mode identifier id'>test_ordered_queries_in_record_mode</span>
     <span class='db identifier id'>db</span> <span class='assign token'>=</span> <span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='string val'>'db'</span><span class='rparen token'>)</span>
     <span class='db identifier id'>db</span><span class='dot token'>.</span><span class='should_expect identifier id'>should_expect</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='rec identifier id'>rec</span><span class='bitor op'>|</span>
       <span class='rec identifier id'>rec</span><span class='dot token'>.</span><span class='startup identifier id'>startup</span><span class='dot token'>.</span><span class='once identifier id'>once</span><span class='dot token'>.</span><span class='ordered identifier id'>ordered</span>
       <span class='rec identifier id'>rec</span><span class='dot token'>.</span><span class='query identifier id'>query</span><span class='lparen token'>(</span><span class='string val'>&quot;CPWR&quot;</span><span class='rparen token'>)</span> <span class='lbrace token'>{</span> <span class='float val'>12.3</span> <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='once identifier id'>once</span><span class='dot token'>.</span><span class='ordered identifier id'>ordered</span><span class='lparen token'>(</span><span class='symbol val'>:queries</span><span class='rparen token'>)</span>
       <span class='rec identifier id'>rec</span><span class='dot token'>.</span><span class='query identifier id'>query</span><span class='lparen token'>(</span><span class='string val'>&quot;MSFT&quot;</span><span class='rparen token'>)</span> <span class='lbrace token'>{</span> <span class='float val'>10.0</span> <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='once identifier id'>once</span><span class='dot token'>.</span><span class='ordered identifier id'>ordered</span><span class='lparen token'>(</span><span class='symbol val'>:queries</span><span class='rparen token'>)</span>
       <span class='rec identifier id'>rec</span><span class='dot token'>.</span><span class='query identifier id'>query</span><span class='lparen token'>(</span><span class='regexp val'>/^....$/</span><span class='rparen token'>)</span> <span class='lbrace token'>{</span> <span class='float val'>3.3</span> <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='at_least identifier id'>at_least</span><span class='dot token'>.</span><span class='once identifier id'>once</span><span class='dot token'>.</span><span class='ordered identifier id'>ordered</span><span class='lparen token'>(</span><span class='symbol val'>:queries</span><span class='rparen token'>)</span>
       <span class='rec identifier id'>rec</span><span class='dot token'>.</span><span class='finish identifier id'>finish</span><span class='dot token'>.</span><span class='once identifier id'>once</span><span class='dot token'>.</span><span class='ordered identifier id'>ordered</span>
     <span class='end end kw'>end</span>
     <span class='comment val'># test code here using &lt;tt&gt;db&lt;/tt&gt;.</span>
   <span class='end end kw'>end</span>
</pre>
<h3>Using Record Mode to record a known, good algorithm for testing</h3>
<p>
Record mode is nice when you have a known, good algorithm that can use a
recording mock object to record the steps. Then you compare the execution
of a new algorithm to behavior of the old using the recorded expectations
in the mock. For this you probably want to put the recorder in
<em>strict</em> mode so that the recorded expectations use exact matching
on argument lists, and strict ordering of the method calls.
</p>
<p>
<b>Note:</b> This is most useful when there are no queries on the mock
objects, because the query responses cannot be programmed into the recorder
object.
</p>
<pre class="code">
  <span class='def def kw'>def</span> <span class='test_build_xml identifier id'>test_build_xml</span>
    <span class='builder identifier id'>builder</span> <span class='assign token'>=</span> <span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='string val'>'builder'</span><span class='rparen token'>)</span>
    <span class='builder identifier id'>builder</span><span class='dot token'>.</span><span class='should_expect identifier id'>should_expect</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='rec identifier id'>rec</span><span class='bitor op'>|</span>
      <span class='rec identifier id'>rec</span><span class='dot token'>.</span><span class='should_be_strict identifier id'>should_be_strict</span>
      <span class='known_good_way_to_build_xml identifier id'>known_good_way_to_build_xml</span><span class='lparen token'>(</span><span class='rec identifier id'>rec</span><span class='rparen token'>)</span>  <span class='comment val'># record the messages</span>
    <span class='end end kw'>end</span>
    <span class='new_way_to_build_xml identifier id'>new_way_to_build_xml</span><span class='lparen token'>(</span><span class='builder identifier id'>builder</span><span class='rparen token'>)</span>       <span class='comment val'># compare to new way</span>
  <span class='end end kw'>end</span>
</pre>
<h3>Expect multiple calls, returning a different value each time</h3>
<p>
Sometimes you need to return different values for each call to a mocked
method. This example shifts values out of a list for this effect.
</p>
<pre class="code">
   <span class='def def kw'>def</span> <span class='test_multiple_gets identifier id'>test_multiple_gets</span>
     <span class='file identifier id'>file</span> <span class='assign token'>=</span> <span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='string val'>'file'</span><span class='rparen token'>)</span>
     <span class='file identifier id'>file</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:gets</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='with_no_args identifier id'>with_no_args</span><span class='dot token'>.</span>
        <span class='and_return identifier id'>and_return</span><span class='lparen token'>(</span><span class='string val'>&quot;line 1\n&quot;</span><span class='comma token'>,</span> <span class='string val'>&quot;line 2\n&quot;</span><span class='rparen token'>)</span>
     <span class='comment val'># test code here</span>
   <span class='end end kw'>end</span>
</pre>
<h3>Ignore uninteresting messages</h3>
<p>
Generally you need to mock only those methods that return an interesting
value or wish to assert were sent in a particular manner. Use the
<tt>should_ignore_missing</tt> method to turn on missing method ignoring.
</p>
<pre class="code">
   <span class='def def kw'>def</span> <span class='test_an_important_message identifier id'>test_an_important_message</span>
     <span class='m identifier id'>m</span> <span class='assign token'>=</span> <span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='string val'>'m'</span><span class='rparen token'>)</span>
     <span class='m identifier id'>m</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:an_important_message</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='and_return identifier id'>and_return</span><span class='lparen token'>(</span><span class='integer val'>1</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='once identifier id'>once</span>
     <span class='m identifier id'>m</span><span class='dot token'>.</span><span class='should_ignore_missing identifier id'>should_ignore_missing</span>
     <span class='comment val'># test code here</span>
   <span class='end end kw'>end</span>
</pre>
<p>
When <tt>should_ignore_missing</tt> is enabled, ignored missing methods
will return an undefined object. Any operation on the undefined object will
return the undefined object.
</p>
<h3>Mock just one method on an existing object</h3>
<p>
The Portfolio class calculate the value of a set of stocks by talking to a
quote service via a web service. Since we don&#8217;t want to use a real
web service in our unit tests, we will mock the quote service.
</p>
<pre class="code">
  <span class='def def kw'>def</span> <span class='test_portfolio_value identifier id'>test_portfolio_value</span>
    <span class='flexmock identifier id'>flexmock</span><span class='lparen token'>(</span><span class='QuoteService constant id'>QuoteService</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='new_instances identifier id'>new_instances</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='m identifier id'>m</span><span class='bitor op'>|</span>
      <span class='m identifier id'>m</span><span class='dot token'>.</span><span class='should_receive identifier id'>should_receive</span><span class='lparen token'>(</span><span class='symbol val'>:quote</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='and_return identifier id'>and_return</span><span class='lparen token'>(</span><span class='integer val'>100</span><span class='rparen token'>)</span>
    <span class='end end kw'>end</span>
    <span class='port identifier id'>port</span> <span class='assign token'>=</span> <span class='Portfolio constant id'>Portfolio</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
    <span class='value identifier id'>value</span> <span class='assign token'>=</span> <span class='port identifier id'>port</span><span class='dot token'>.</span><span class='value identifier id'>value</span>     <span class='comment val'># Portfolio calls QuoteService.quote</span>
    <span class='assert_equal identifier id'>assert_equal</span> <span class='integer val'>100</span><span class='comma token'>,</span> <span class='value identifier id'>value</span>
  <span class='end end kw'>end</span>
</pre>
<h2>Other Mock Objects</h2>
<table>
<tr><td valign="top">test-unit-mock :</td><td>http://www.deveiate.org/code/Test-Unit-Mock.shtml

</td></tr>
<tr><td valign="top">mocha/stubba   :</td><td>http://mocha.rubyforge.org/

</td></tr>
<tr><td valign="top">Schmock        :</td><td>http://rubyforge.org/projects/schmock/

</td></tr>
</table>
<h2>License</h2>
<p>
Copyright 2003, 2004, 2005, 2006, 2007 by Jim Weirich
(jim@weirichhouse.org). All rights reserved.
</p>
<p>
Permission is granted for use, copying, modification, distribution, and
distribution of modified versions of this work as long as the above
copyright notice is included.
</p>
<h1>Other stuff</h1>
<table>
<tr><td valign="top">Author:</td><td>Jim Weirich &lt;jim@weirichhouse.org&gt;

</td></tr>
<tr><td valign="top">Requires:</td><td>Ruby 1.8.x or later

</td></tr>
</table>
<h2>Warranty</h2>
<p>
This software is provided &quot;as is&quot; and without any express or
implied warranties, including, without limitation, the implied warranties
of merchantibility and fitness for a particular purpose.
</p>

</div>
          </div>
        </div>
      </div>                    
    </div>

    <div id="footer">
      <div class="site">
        <div class="info">
          <div class="links">
            <a href="http://github.com/blog/148-github-shirts-now-available">Shirts</a> |
            <a href="http://github.com/blog">Blog</a> |
            <a href="http://support.github.com/">Support</a> |
            <a href="http://github.com/training">Training</a> |
            <a href="http://github.com/contact">Contact</a> |
            <a href="http://groups.google.com/group/github/">Google Group</a> |
            <a href="http://develop.github.com/">API</a> |
            <a href="http://twitter.com/github">Status</a>
          </div>
          <div class="company">
            <span id="_rrt" title="0.64509s from xc88-s00039">GitHub</span>
            is <a href="http://logicalawesome.com/">Logical Awesome</a> 2009 | <a href="http://github.com/site/terms">Terms of Service</a> | <a href="http://github.com/site/privacy">Privacy Policy</a>
          </div>
        </div>
        <div class="sponsor">
          <a href="http://engineyard.com/"><img src="http://github.com/images/modules/footer/engine_yard_logo.png" alt="Engine Yard"></a>
          <div>
            Hosting provided by our<br> partners at Engine Yard
          </div>
        </div>
      </div>
    </div>
    
    <div id="coming_soon" style="display: none;">
      This feature is coming soon.  Sit tight!
    </div>

    <div id="facebox" style="display: none;">       
      <div class="popup">         
        <table>           
          <tbody>             
            <tr>               
              <td class="tl"></td>
              <td class="b"></td>
              <td class="tr"></td>             
            </tr>             
          <tr>               
            <td class="b"></td>               
            <td class="body">                 
              <div class="content"></div>                 
              <div class="footer">                   
                <a href="#" class="close"><img src="http://github.com/facebox/closelabel.gif" title="close" class="close_image"></a>                 
              </div>               
            </td>               
            <td class="b"></td>             
          </tr>             
          <tr>               
            <td class="bl"></td>
            <td class="b"></td>
            <td class="br"></td>             
          </tr>           
        </tbody>         
      </table>       
    </div>     


    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
    var pageTracker = _gat._getTracker("UA-8689483-1");
    pageTracker._trackPageview();
    } catch(err) {}</script>

  </body>
</html>