<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="style.css" type="text/css" charset="utf-8" />
<link rel="stylesheet" href="syntax_highlight.css" type="text/css" charset="utf-8" />

    <title>README</title>
  </head>
  <body>
    <div id="content">
      <div class="section docstring readme">
        <p>
Machinist
</p>
<h6>===</h6>
<p>
*Fixtures aren&#8217;t fun. Machinist is.*
</p>
<p>
Machinist lets you construct test data on the fly, but instead of doing
this:
</p>
<pre class="code">
    <span class='describe identifier id'>describe</span> <span class='Comment constant id'>Comment</span> <span class='do do kw'>do</span>
      <span class='before identifier id'>before</span> <span class='do do kw'>do</span>
        <span class='@user ivar id'>@user</span> <span class='assign token'>=</span> <span class='User constant id'>User</span><span class='dot token'>.</span><span class='create! fid id'>create!</span><span class='lparen token'>(</span><span class='symbol val'>:name</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>&quot;Test User&quot;</span><span class='comma token'>,</span> <span class='symbol val'>:email</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>&quot;user@example.com&quot;</span><span class='rparen token'>)</span>
        <span class='@post ivar id'>@post</span> <span class='assign token'>=</span> <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='create! fid id'>create!</span><span class='lparen token'>(</span><span class='symbol val'>:title</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>&quot;Test Post&quot;</span><span class='comma token'>,</span> <span class='symbol val'>:author</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='@user ivar id'>@user</span><span class='comma token'>,</span> <span class='symbol val'>:body</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>&quot;Lorem ipsum...&quot;</span><span class='rparen token'>)</span>
        <span class='@comment ivar id'>@comment</span> <span class='assign token'>=</span> <span class='Comment constant id'>Comment</span><span class='dot token'>.</span><span class='create! fid id'>create!</span><span class='lparen token'>(</span>
          <span class='symbol val'>:post</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='@post ivar id'>@post</span><span class='comma token'>,</span> <span class='symbol val'>:author_name</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>&quot;Test Commenter&quot;</span><span class='comma token'>,</span> <span class='symbol val'>:author_email</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>&quot;commenter@example.com&quot;</span><span class='comma token'>,</span>
          <span class='symbol val'>:spam</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='true true kw'>true</span>
        <span class='rparen token'>)</span>
      <span class='end end kw'>end</span>

      <span class='it identifier id'>it</span> <span class='string val'>&quot;should not include comments marked as spam in the without_spam named scope&quot;</span> <span class='do do kw'>do</span>
        <span class='Comment constant id'>Comment</span><span class='dot token'>.</span><span class='without_spam identifier id'>without_spam</span><span class='dot token'>.</span><span class='should_not identifier id'>should_not</span> <span class='include identifier id'>include</span><span class='lparen token'>(</span><span class='@comment ivar id'>@comment</span><span class='rparen token'>)</span>
      <span class='end end kw'>end</span>
    <span class='end end kw'>end</span>
</pre>
<p>
you can just do this:
</p>
<pre class="code">
    <span class='describe identifier id'>describe</span> <span class='Comment constant id'>Comment</span> <span class='do do kw'>do</span>
      <span class='before identifier id'>before</span> <span class='do do kw'>do</span>
        <span class='@comment ivar id'>@comment</span> <span class='assign token'>=</span> <span class='Comment constant id'>Comment</span><span class='dot token'>.</span><span class='make identifier id'>make</span><span class='lparen token'>(</span><span class='symbol val'>:spam</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='true true kw'>true</span><span class='rparen token'>)</span>
      <span class='end end kw'>end</span>

      <span class='it identifier id'>it</span> <span class='string val'>&quot;should not include comments marked as spam in the without_spam named scope&quot;</span> <span class='do do kw'>do</span>
        <span class='Comment constant id'>Comment</span><span class='dot token'>.</span><span class='without_spam identifier id'>without_spam</span><span class='dot token'>.</span><span class='should_not identifier id'>should_not</span> <span class='include identifier id'>include</span><span class='lparen token'>(</span><span class='@comment ivar id'>@comment</span><span class='rparen token'>)</span>
      <span class='end end kw'>end</span>
    <span class='end end kw'>end</span>
</pre>
<p>
Machinist generates data for the fields you don&#8217;t care about, and
constructs any necessary associated objects, leaving you to only specify
the fields you <b>do</b> care about in your tests.
</p>
<p>
You tell Machinist how to do this with blueprints:
</p>
<pre class="code">
    <span class='require identifier id'>require</span> <span class='string val'>'faker'</span>

    <span class='Sham constant id'>Sham</span><span class='dot token'>.</span><span class='name identifier id'>name</span>  <span class='lbrace token'>{</span> <span class='Faker constant id'>Faker</span><span class='colon2 op'>::</span><span class='Name constant id'>Name</span><span class='dot token'>.</span><span class='name identifier id'>name</span> <span class='rbrace token'>}</span>
    <span class='Sham constant id'>Sham</span><span class='dot token'>.</span><span class='email identifier id'>email</span> <span class='lbrace token'>{</span> <span class='Faker constant id'>Faker</span><span class='colon2 op'>::</span><span class='Internet constant id'>Internet</span><span class='dot token'>.</span><span class='email identifier id'>email</span> <span class='rbrace token'>}</span>
    <span class='Sham constant id'>Sham</span><span class='dot token'>.</span><span class='title identifier id'>title</span> <span class='lbrace token'>{</span> <span class='Faker constant id'>Faker</span><span class='colon2 op'>::</span><span class='Lorem constant id'>Lorem</span><span class='dot token'>.</span><span class='sentence identifier id'>sentence</span> <span class='rbrace token'>}</span>
    <span class='Sham constant id'>Sham</span><span class='dot token'>.</span><span class='body identifier id'>body</span>  <span class='lbrace token'>{</span> <span class='Faker constant id'>Faker</span><span class='colon2 op'>::</span><span class='Lorem constant id'>Lorem</span><span class='dot token'>.</span><span class='paragraph identifier id'>paragraph</span> <span class='rbrace token'>}</span>

    <span class='User constant id'>User</span><span class='dot token'>.</span><span class='blueprint identifier id'>blueprint</span> <span class='do do kw'>do</span>
      <span class='name identifier id'>name</span>
      <span class='email identifier id'>email</span>
    <span class='end end kw'>end</span>

    <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='blueprint identifier id'>blueprint</span> <span class='do do kw'>do</span>
      <span class='title identifier id'>title</span>
      <span class='author identifier id'>author</span>
      <span class='body identifier id'>body</span>
    <span class='end end kw'>end</span>

    <span class='Comment constant id'>Comment</span><span class='dot token'>.</span><span class='blueprint identifier id'>blueprint</span> <span class='do do kw'>do</span>
      <span class='post identifier id'>post</span>
      <span class='author_name identifier id'>author_name</span>  <span class='lbrace token'>{</span> <span class='Sham constant id'>Sham</span><span class='dot token'>.</span><span class='name identifier id'>name</span> <span class='rbrace token'>}</span>
      <span class='author_email identifier id'>author_email</span> <span class='lbrace token'>{</span> <span class='Sham constant id'>Sham</span><span class='dot token'>.</span><span class='email identifier id'>email</span> <span class='rbrace token'>}</span>
      <span class='body identifier id'>body</span>
    <span class='end end kw'>end</span>
</pre>
<p>
Installation
</p>
<hr size="10"></hr><p>
Install the plugin:
</p>
<pre class="code">
    <span class='dot token'>.</span><span class='div op'>/</span><span class='script identifier id'>script</span><span class='div op'>/</span><span class='plugin identifier id'>plugin</span> <span class='install identifier id'>install</span> <span class='git identifier id'>git</span><span class='symbol val'>:/</span><span class='regexp val'>/github.com/n</span><span class='otahat identifier id'>otahat</span><span class='div op'>/</span><span class='machinist identifier id'>machinist</span><span class='dot token'>.</span><span class='git identifier id'>git</span>
</pre>
<p>
Create a blueprints.rb in your test (or spec) directory, and require it in
your test_helper.rb (or spec_helper.rb):
</p>
<pre class="code">
    <span class='require identifier id'>require</span> <span class='File constant id'>File</span><span class='dot token'>.</span><span class='expand_path identifier id'>expand_path</span><span class='lparen token'>(</span><span class='File constant id'>File</span><span class='dot token'>.</span><span class='dirname identifier id'>dirname</span><span class='lparen token'>(</span><span class='__FILE__ __file__ kw'>__FILE__</span><span class='rparen token'>)</span> <span class='plus op'>+</span> <span class='string val'>&quot;/blueprints&quot;</span><span class='rparen token'>)</span>
</pre>
<p>
Set Sham to reset before each test. In the `class Test::Unit::TestCase`
block in your test_helper.rb, add:
</p>
<pre class="code">
    <span class='setup identifier id'>setup</span> <span class='lbrace token'>{</span> <span class='Sham constant id'>Sham</span><span class='dot token'>.</span><span class='reset identifier id'>reset</span> <span class='rbrace token'>}</span>
</pre>
<p>
or, if you&#8217;re on RSpec, in the `Spec::Runner.configure` block in your
spec_helper.rb, add:
</p>
<pre class="code">
    <span class='config identifier id'>config</span><span class='dot token'>.</span><span class='before identifier id'>before</span><span class='lparen token'>(</span><span class='symbol val'>:each</span><span class='rparen token'>)</span> <span class='lbrace token'>{</span> <span class='Sham constant id'>Sham</span><span class='dot token'>.</span><span class='reset identifier id'>reset</span> <span class='rbrace token'>}</span>
</pre>
<p>
### Installing as a Gem
</p>
<p>
If you&#8217;d prefer, you can install Machinist as a gem:
</p>
<pre class="code">
    <span class='sudo identifier id'>sudo</span> <span class='gem identifier id'>gem</span> <span class='install identifier id'>install</span> <span class='notahat identifier id'>notahat</span><span class='minus op'>-</span><span class='machinist identifier id'>machinist</span> <span class='minus op'>-</span><span class='minus op'>-</span><span class='source identifier id'>source</span> <span class='http identifier id'>http</span><span class='symbol val'>:/</span><span class='regexp val'>/gems.github.com
</span></pre>
<p>
From there, create the blueprints.rb file as described above, and make sure
you require machinist and sham.
</p>
<p>
Sham - Generating Attribute Values
</p>
<hr size="10"></hr><p>
Sham lets you generate random but repeatable unique attributes values.
</p>
<p>
For example, you could define a way to generate random names as:
</p>
<pre class="code">
    <span class='Sham constant id'>Sham</span><span class='dot token'>.</span><span class='name identifier id'>name</span> <span class='lbrace token'>{</span> <span class='lparen token'>(</span><span class='float val'>1</span><span class='dot2 op'>..</span><span class='integer val'>10</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='map identifier id'>map</span> <span class='lbrace token'>{</span> <span class='lparen token'>(</span><span class='string val'>'a'</span><span class='dot2 op'>..</span><span class='string val'>'z'</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='to_a identifier id'>to_a</span><span class='dot token'>.</span><span class='rand identifier id'>rand</span> <span class='rbrace token'>}</span> <span class='rbrace token'>}</span>
</pre>
<p>
Then, to generate a name, call:
</p>
<pre class="code">
    <span class='Sham constant id'>Sham</span><span class='dot token'>.</span><span class='name identifier id'>name</span>
</pre>
<p>
So why not just define a helper method to do this? Sham ensures two things
for you:
</p>
<ol>
<li>You get the same sequence of values each time your test is run

</li>
<li>You don&#8217;t get any duplicate values

</li>
</ol>
<p>
Sham works very well with the excellent [Faker
gem](http://faker.rubyforge.org/) by Benjamin Curtis. Using this, a much
nicer way to generate names is:
</p>
<pre class="code">
    <span class='Sham constant id'>Sham</span><span class='dot token'>.</span><span class='name identifier id'>name</span> <span class='lbrace token'>{</span> <span class='Faker constant id'>Faker</span><span class='colon2 op'>::</span><span class='Name constant id'>Name</span><span class='dot token'>.</span><span class='name identifier id'>name</span> <span class='rbrace token'>}</span>
</pre>
<p>
Sham also supports generating numbered sequences if you prefer.
</p>
<pre class="code">
    <span class='Sham constant id'>Sham</span><span class='dot token'>.</span><span class='name identifier id'>name</span> <span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='index identifier id'>index</span><span class='bitor op'>|</span> <span class='dstring node'>&quot;Name #{index}&quot;</span> <span class='rbrace token'>}</span>
</pre>
<p>
If you want to allow duplicate values for a sham, you can pass the
`:unique` option:
</p>
<pre class="code">
    <span class='Sham constant id'>Sham</span><span class='dot token'>.</span><span class='coin_toss identifier id'>coin_toss</span><span class='lparen token'>(</span><span class='symbol val'>:unique</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='false false kw'>false</span><span class='rparen token'>)</span> <span class='lbrace token'>{</span> <span class='rand identifier id'>rand</span><span class='lparen token'>(</span><span class='integer val'>2</span><span class='rparen token'>)</span> <span class='eq op'>==</span> <span class='integer val'>0</span> <span class='question op'>?</span> <span class='string val'>'heads'</span> <span class='colon op'>:</span> <span class='string val'>'tails'</span> <span class='rbrace token'>}</span>
</pre>
<p>
You can create a bunch of sham definitions in one hit like this:
</p>
<pre class="code">
    <span class='Sham constant id'>Sham</span><span class='dot token'>.</span><span class='define identifier id'>define</span> <span class='do do kw'>do</span>
      <span class='title identifier id'>title</span> <span class='lbrace token'>{</span> <span class='Faker constant id'>Faker</span><span class='colon2 op'>::</span><span class='Lorem constant id'>Lorem</span><span class='dot token'>.</span><span class='words identifier id'>words</span><span class='lparen token'>(</span><span class='integer val'>5</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='join identifier id'>join</span><span class='lparen token'>(</span><span class='string val'>' '</span><span class='rparen token'>)</span> <span class='rbrace token'>}</span>
      <span class='name identifier id'>name</span>  <span class='lbrace token'>{</span> <span class='Faker constant id'>Faker</span><span class='colon2 op'>::</span><span class='Name constant id'>Name</span><span class='dot token'>.</span><span class='name identifier id'>name</span> <span class='rbrace token'>}</span>
      <span class='body identifier id'>body</span>  <span class='lbrace token'>{</span> <span class='Faker constant id'>Faker</span><span class='colon2 op'>::</span><span class='Lorem constant id'>Lorem</span><span class='dot token'>.</span><span class='paragraphs identifier id'>paragraphs</span><span class='lparen token'>(</span><span class='integer val'>3</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='join identifier id'>join</span><span class='lparen token'>(</span><span class='string val'>&quot;\n\n&quot;</span><span class='rparen token'>)</span> <span class='rbrace token'>}</span>
    <span class='end end kw'>end</span>
</pre>
<p>
Blueprints - Generating ActiveRecord Objects
</p>
<hr size="10"></hr><p>
A blueprint describes how to generate an ActiveRecord object. The idea is
that you let the blueprint take care of making up values for attributes
that you don&#8217;t care about in your test, leaving you to focus on the
just the things that you&#8217;re testing.
</p>
<p>
A simple blueprint might look like this:
</p>
<pre class="code">
    <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='blueprint identifier id'>blueprint</span> <span class='do do kw'>do</span>
      <span class='title identifier id'>title</span>  <span class='lbrace token'>{</span> <span class='Sham constant id'>Sham</span><span class='dot token'>.</span><span class='title identifier id'>title</span> <span class='rbrace token'>}</span>
      <span class='author identifier id'>author</span> <span class='lbrace token'>{</span> <span class='Sham constant id'>Sham</span><span class='dot token'>.</span><span class='name identifier id'>name</span> <span class='rbrace token'>}</span>
      <span class='body identifier id'>body</span>   <span class='lbrace token'>{</span> <span class='Sham constant id'>Sham</span><span class='dot token'>.</span><span class='body identifier id'>body</span> <span class='rbrace token'>}</span>
    <span class='end end kw'>end</span>
</pre>
<p>
You can then construct a Post from this blueprint with:
</p>
<pre class="code">
    <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='make identifier id'>make</span>
</pre>
<p>
When you call `make`, Machinist calls Post.new, then runs through the
attributes in your blueprint, calling the block for each attribute to
generate a value. It then calls `save!` and `reload` on the Post.
</p>
<p>
You can override values defined in the blueprint by passing a hash to make:
</p>
<pre class="code">
    <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='make identifier id'>make</span><span class='lparen token'>(</span><span class='symbol val'>:title</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>&quot;A Specific Title&quot;</span><span class='rparen token'>)</span>
</pre>
<p>
`make` doesn&#8217;t call the blueprint blocks of any attributes that are
passed in.
</p>
<p>
If you don&#8217;t supply a block for an attribute in the blueprint,
Machinist will look for a Sham definition with the same name as the
attribute, so you can shorten the above blueprint to:
</p>
<pre class="code">
    <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='blueprint identifier id'>blueprint</span> <span class='do do kw'>do</span>
      <span class='title identifier id'>title</span>
      <span class='author identifier id'>author</span> <span class='lbrace token'>{</span> <span class='Sham constant id'>Sham</span><span class='dot token'>.</span><span class='name identifier id'>name</span> <span class='rbrace token'>}</span>
      <span class='body identifier id'>body</span>
    <span class='end end kw'>end</span>
</pre>
<p>
If you want to generate an object without saving it to the database,
replace `make` with `make_unsaved`. (`make_unsaved` also ensures that any
associated objects that need to be generated are not saved. See the section
on associations below.)
</p>
<p>
### Belongs_to Associations
</p>
<p>
You can generate an associated object like this:
</p>
<pre class="code">
    <span class='Comment constant id'>Comment</span><span class='dot token'>.</span><span class='blueprint identifier id'>blueprint</span> <span class='do do kw'>do</span>
      <span class='post identifier id'>post</span> <span class='lbrace token'>{</span> <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='make identifier id'>make</span> <span class='rbrace token'>}</span>
    <span class='end end kw'>end</span>
</pre>
<p>
Calling `Comment.make` will construct a Comment and its associated Post,
and save both.
</p>
<p>
If you want to override the value for post when constructing the comment,
you can:
</p>
<pre class="code">
    <span class='post identifier id'>post</span> <span class='assign token'>=</span> <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='make identifier id'>make</span><span class='lparen token'>(</span><span class='symbol val'>:title</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>&quot;A particular title)
    comment = Comment.make(:post =&gt; post)
</span></pre>
<p>
Machinist will not call the blueprint block for the post attribute, so this
won&#8217;t generate two posts.
</p>
<p>
Machinist is smart enough to look at the association and work out what sort
of object it needs to create, so you can shorten the above blueprint to:
</p>
<pre class="code">
    <span class='Comment constant id'>Comment</span><span class='dot token'>.</span><span class='blueprint identifier id'>blueprint</span> <span class='do do kw'>do</span>
      <span class='post identifier id'>post</span>
    <span class='end end kw'>end</span>
</pre>
<p>
You can refer to already assigned attributes when constructing a new
attribute:
</p>
<pre class="code">
    <span class='Comment constant id'>Comment</span><span class='dot token'>.</span><span class='blueprint identifier id'>blueprint</span> <span class='do do kw'>do</span>
      <span class='post identifier id'>post</span>
      <span class='body identifier id'>body</span> <span class='lbrace token'>{</span> <span class='string val'>&quot;Comment on &quot;</span> <span class='plus op'>+</span> <span class='post identifier id'>post</span><span class='dot token'>.</span><span class='title identifier id'>title</span> <span class='rbrace token'>}</span>
    <span class='end end kw'>end</span>
</pre>
<p>
### Other Associations
</p>
<p>
For has_many and has_and_belongs_to_many associations, ActiveRecord insists
that the object be saved before any associated objects can be saved. That
means you can&#8217;t generate the associated objects from within the
blueprint.
</p>
<p>
The simplest solution is to write a test helper:
</p>
<pre class="code">
    <span class='def def kw'>def</span> <span class='make_post_with_comments identifier id'>make_post_with_comments</span><span class='lparen token'>(</span><span class='attributes identifier id'>attributes</span> <span class='assign token'>=</span> <span class='lbrace token'>{</span><span class='rbrace token'>}</span><span class='rparen token'>)</span>
      <span class='post identifier id'>post</span> <span class='assign token'>=</span> <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='make identifier id'>make</span><span class='lparen token'>(</span><span class='attributes identifier id'>attributes</span><span class='rparen token'>)</span>
      <span class='float val'>3</span><span class='dot token'>.</span><span class='times identifier id'>times</span> <span class='lbrace token'>{</span> <span class='post identifier id'>post</span><span class='dot token'>.</span><span class='comments identifier id'>comments</span><span class='dot token'>.</span><span class='make identifier id'>make</span> <span class='rbrace token'>}</span>
      <span class='post identifier id'>post</span>
    <span class='end end kw'>end</span>
</pre>
<p>
Note here that you can call `make` on a has_many association.
</p>
<p>
Make can take a block, into which it passes the constructed object, so the
above can be written as:
</p>
<pre class="code">
    <span class='def def kw'>def</span> <span class='make_post_with_comments identifier id'>make_post_with_comments</span>
      <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='make identifier id'>make</span><span class='lparen token'>(</span><span class='attributes identifier id'>attributes</span><span class='rparen token'>)</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='post identifier id'>post</span><span class='bitor op'>|</span>
        <span class='float val'>3</span><span class='dot token'>.</span><span class='times identifier id'>times</span> <span class='lbrace token'>{</span> <span class='post identifier id'>post</span><span class='dot token'>.</span><span class='comments identifier id'>comments</span><span class='dot token'>.</span><span class='make identifier id'>make</span> <span class='rbrace token'>}</span>
      <span class='end end kw'>end</span>
    <span class='end end kw'>end</span>
</pre>
<p>
### Using Blueprints in Rails Controller Tests
</p>
<p>
The `plan` method behaves like `make`, except it returns a hash of
attributes, and doesn&#8217;t save the object. This is useful for passing
in to controller tests:
</p>
<pre class="code">
    <span class='test identifier id'>test</span> <span class='string val'>&quot;should create post&quot;</span> <span class='do do kw'>do</span>
      <span class='assert_difference identifier id'>assert_difference</span><span class='lparen token'>(</span><span class='string val'>'Post.count'</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
        <span class='post identifier id'>post</span> <span class='symbol val'>:create</span><span class='comma token'>,</span> <span class='symbol val'>:post</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='plan identifier id'>plan</span>
      <span class='end end kw'>end</span>
      <span class='assert_redirected_to identifier id'>assert_redirected_to</span> <span class='post_path identifier id'>post_path</span><span class='lparen token'>(</span><span class='assigns identifier id'>assigns</span><span class='lparen token'>(</span><span class='symbol val'>:post</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
    <span class='end end kw'>end</span>
</pre>
<p>
`plan` will save any associated objects. In this example, it will create an
Author, and it knows that the controller expects an `author_id` attribute,
rather than an `author` attribute, and makes this translation for you.
</p>
<p>
You can also call plan on has_many associations, making it easy to test
nested controllers:
</p>
<pre class="code">
    <span class='test identifier id'>test</span> <span class='string val'>&quot;should create comment&quot;</span> <span class='do do kw'>do</span>
      <span class='post identifier id'>post</span> <span class='assign token'>=</span> <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='make identifier id'>make</span>
      <span class='assert_difference identifier id'>assert_difference</span><span class='lparen token'>(</span><span class='string val'>'Comment.count'</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
        <span class='post identifier id'>post</span> <span class='symbol val'>:create</span><span class='comma token'>,</span> <span class='symbol val'>:post_id</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='post identifier id'>post</span><span class='dot token'>.</span><span class='id identifier id'>id</span><span class='comma token'>,</span> <span class='symbol val'>:comment</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='post identifier id'>post</span><span class='dot token'>.</span><span class='comments identifier id'>comments</span><span class='dot token'>.</span><span class='plan identifier id'>plan</span>
      <span class='end end kw'>end</span>
      <span class='assert_redirected_to identifier id'>assert_redirected_to</span> <span class='post_comment_path identifier id'>post_comment_path</span><span class='lparen token'>(</span><span class='post identifier id'>post</span><span class='comma token'>,</span> <span class='assigns identifier id'>assigns</span><span class='lparen token'>(</span><span class='symbol val'>:comment</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
    <span class='end end kw'>end</span>
</pre>
<p>
### Named Blueprints
</p>
<p>
Named blueprints let you define variations on an object. For example,
suppose some of your Users are administrators:
</p>
<pre class="code">
    <span class='User constant id'>User</span><span class='dot token'>.</span><span class='blueprint identifier id'>blueprint</span> <span class='do do kw'>do</span>
      <span class='name identifier id'>name</span>
      <span class='email identifier id'>email</span>
    <span class='end end kw'>end</span>

    <span class='User constant id'>User</span><span class='dot token'>.</span><span class='blueprint identifier id'>blueprint</span><span class='lparen token'>(</span><span class='symbol val'>:admin</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
      <span class='name identifier id'>name</span>  <span class='lbrace token'>{</span> <span class='Sham constant id'>Sham</span><span class='dot token'>.</span><span class='name identifier id'>name</span> <span class='plus op'>+</span> <span class='string val'>&quot; (admin)&quot;</span> <span class='rbrace token'>}</span>
      <span class='admin identifier id'>admin</span> <span class='lbrace token'>{</span> <span class='true true kw'>true</span> <span class='rbrace token'>}</span>
    <span class='end end kw'>end</span>
</pre>
<p>
Calling:
</p>
<pre class="code">
    <span class='User constant id'>User</span><span class='dot token'>.</span><span class='make identifier id'>make</span><span class='lparen token'>(</span><span class='symbol val'>:admin</span><span class='rparen token'>)</span>
</pre>
<p>
will use the `:admin` blueprint.
</p>
<p>
Named blueprints call the default blueprint to set any attributes not
specifically provided, so in this example the `email` attribute will still
be generated even for an admin user.
</p>
<p>
FAQ
</p>
<hr size="1"></hr><p>
### My blueprint is giving me really weird errors. Any ideas?
</p>
<p>
If your object has an attribute that happens to correspond to a Ruby
standard function, it won&#8217;t work properly in a blueprint.
</p>
<p>
For example:
</p>
<pre class="code">
    <span class='OpeningHours constant id'>OpeningHours</span><span class='dot token'>.</span><span class='blueprint identifier id'>blueprint</span> <span class='do do kw'>do</span>
      <span class='open identifier id'>open</span> <span class='lbrace token'>{</span> <span class='Time constant id'>Time</span><span class='dot token'>.</span><span class='now identifier id'>now</span> <span class='rbrace token'>}</span>
    <span class='end end kw'>end</span>
</pre>
<p>
This will result in Machinist attempting to run ruby&#8217;s open command.
To work around this use self.open instead.
</p>
<pre class="code">
    <span class='OpeningHours constant id'>OpeningHours</span><span class='dot token'>.</span><span class='blueprint identifier id'>blueprint</span> <span class='do do kw'>do</span>
      <span class='self self kw'>self</span><span class='dot token'>.</span><span class='open identifier id'>open</span> <span class='lbrace token'>{</span> <span class='Time constant id'>Time</span><span class='dot token'>.</span><span class='now identifier id'>now</span> <span class='rbrace token'>}</span>
    <span class='end end kw'>end</span>
</pre>
<p>
Credits
</p>
<hr size="5"></hr><p>
Written by [Pete Yandell](http://notahat.com/).
</p>
<p>
Contributors:
</p>
<ul>
<li>[Clinton Forbes](http://github.com/clinton)

</li>
<li>[Jon Guymon](http://github.com/gnarg)

</li>
<li>[Evan David Light](http://github.com/elight)

</li>
<li>[Kyle Neath](http://github.com/kneath)

</li>
<li>[T.J. Sheehy](http://github.com/tjsheehy)

</li>
<li>[Roland Swingler](http://github.com/knaveofdiamonds)

</li>
<li>[Matt Wastrodowski](http://github.com/towski)

</li>
<li>[Ian White](http://github.com/ianwhite)

</li>
</ul>
<p>
Thanks to Thoughtbot&#8217;s [Factory
Girl](http://github.com/thoughtbot/factory_girl/tree/master). Machinist was
written because I loved the idea behind Factory Girl, but I thought the
philosophy wasn&#8217;t quite right, and I hated the syntax.
</p>
<hr size="1"></hr><p>
Copyright &#169; 2008 Peter Yandell, released under the MIT license
</p>

      </div>
    </div>
  </body>
</html>