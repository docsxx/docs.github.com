<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <title>nathansobo's treetop - GitHub Documentation</title>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="description" content="">

<link rel="search" type="application/opensearchdescription+xml" href="http://github.com/opensearch.xml" title="GitHub">
<link rel="fluid-icon" href="http://github.com/fluidicon.png" title="GitHub">
<link href="http://assets0.github.com/stylesheets/bundle.css" media="screen" rel="stylesheet" type="text/css">
<link href="http://github.com/feeds/nathansobo/commits/treetop/master" rel="alternate" title="Recent Commits to treetop:master" type="application/atom+xml">

<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js"></script>
<script type="text/javascript" src="http://assets3.github.com/javascripts/bundle.js"></script>              
<script src="app.js" type="text/javascript" charset="utf-8"></script>

<script type="text/javascript" src="http://docs.github.com/javascripts/md5.js"></script>
<script type="text/javascript" src="http://docs.github.com/javascripts/repos.js"></script>
<script type="text/javascript" src="http://docs.github.com/javascripts/commits.js"></script>
<script type="text/javascript">
  $(document).ready(function(){
    if (typeof skipHeaders != 'undefined') return;
    
    GitHubRepo.init("nathansobo", "treetop", function(){ 
      GitHubRepo.links = " <a id='namespaces_button' rel='nathansobo/treetop/blob/4b0b91f4c4866291753cfd7ab16a86f999473f7a' href='#'><img class='button' src='http://docs.github.com/namespaces_button.png' alt='Modules and Classes'/></a> ";
      GitHubRepo.links += " <a id='methods_button' rel='nathansobo/treetop/blob/4b0b91f4c4866291753cfd7ab16a86f999473f7a' href='#'><img class='button' src='http://docs.github.com/methods_button.png' alt='Methods'/></a> ";
      $("#repo").html(GitHubRepo.content());
      $('#namespaces_button').click(function(){
        var url="/"+$(this).attr('rel')+"/namespaces/";
        $.gitbox(url);
        return false;
      });    
      $('#methods_button').click(function(){
        var url="/"+$(this).attr('rel')+"/methods/";
        $.gitbox(url);
        return false;
      });        
    });
    GitHubCommit.init("nathansobo", "treetop", "4b0b91f4c4866291753cfd7ab16a86f999473f7a", function(){ 
      $("#commit").html(GitHubCommit.content());
    });
  });
</script>

    <link rel="stylesheet" href="style.css" type="text/css" charset="utf-8" />
  </head>
  <body>    
    
    
        <div id="main" style="padding-bottom:8em;">
      <div id="header">
        <div class="site">
          <div class="logo">
            <a href="http://github.com/"><img src="http://github.com/images/modules/header/logov3.png" alt="github"></a>
          </div>          
          <div class="topsearch">
            <form action="http://github.com/search" id="top_search_form" method="get">
              <input class="search" name="q" type="search"> <input value="Search" type="submit">
            </form>
            <div class="links">
              <a href="http://github.com/repositories">Browse</a> | <a href="http://github.com/guides">Guides</a> | <a href="http://github.com/search">Advanced</a>
            </div>
          </div>
          <div class="actions">
            <a href="http://github.com">Home</a>
            <a href="http://github.com/plans"><b><u>Pricing and Signup</u></b></a>
            <a href="http://docs.github.com/">Documentation</a>
            <a href="https://github.com/login">Login</a>
          </div>                  
        </div>
      </div>    
                                                  
      <div id="repo_menu">
        <div class="site">
          <ul>          
            <li class=""><a href="http://github.com/nathansobo/treetop/tree/">Source</a></li>
            <li class=""><a href="http://github.com/nathansobo/treetop/commits/">Commits</a></li>            
            <li class=""><a href="http://github.com/nathansobo/treetop/network">Network</a></li>            
            <li class=""><a href="http://github.com/nathansobo/treetop/issues">Issues</a></li>
            <li class=""><a href="http://wiki.github.com/nathansobo/treetop">Wiki</a></li>
            <li class=""><a href="http://github.com/nathansobo/treetop/graphs">Graphs</a></li>                    
            <li class="active"><a href="/nathansobo/treetop">Documentation</a></li>
          </ul>
        </div>
      </div>

      <div id="repo_sub_menu">
        <div class="site">
          <div class="joiner"></div>      
        </div>
      </div>

      <div class="site">  
        <div id="repos">
          <div id="repo" class="repo public">
            <div class="title">
              <div class="path">
                <a href="http://github.com/nathansobo">nathansobo</a> / <b><a href="http://github.com/nathansobo/treetop/tree">treetop</a></b>        
                <a id="namespaces_button" rel="nathansobo/treetop/blob/4b0b91f4c4866291753cfd7ab16a86f999473f7a" href="#"><img class="button" src="http://docs.github.com/namespaces_button.png" alt="Modules and Classes"/></a>
                <a id="methods_button" rel="nathansobo/treetop/blob/4b0b91f4c4866291753cfd7ab16a86f999473f7a" href="#"><img class="button" src="http://docs.github.com/methods_button.png" alt="Methods"/></a>
              </div>
            </div>            
          </div>
          <div id="commit">
          </div> 
          <br/>                                       
          <div id="content">
            <div class="section docstring readme wikistyle">
  <p>
Tutorial
</p>
<h6>==</h6>
<p>
Languages can be split into two components, their <b>syntax</b> and their
<b>semantics</b>. It&#8217;s your understanding of English syntax that
tells you the stream of words &quot;Sleep furiously green ideas
colorless&quot; is not a valid sentence. Semantics is deeper. Even if we
rearrange the above sentence to be &quot;Colorless green ideas sleep
furiously&quot;, which is syntactically correct, it remains nonsensical on
a semantic level. With Treetop, you&#8217;ll be dealing with languages that
are much simpler than English, but these basic concepts apply. Your
programs will need to address both the syntax and the semantics of the
languages they interpret.
</p>
<p>
Treetop equips you with powerful tools for each of these two aspects of
interpreter writing. You&#8217;ll describe the syntax of your language with
a *parsing expression grammar*. From this description, Treetop will
generate a Ruby parser that transforms streams of characters written into
your language into *abstract syntax trees* representing their structure.
You&#8217;ll then describe the semantics of your language in Ruby by
defining methods on the syntax trees the parser generates.
</p>
<p>
Parsing Expression Grammars, The Basics
</p>
<h6>=================================</h6>
<p>
The first step in using Treetop is defining a grammar in a file with the
`.treetop` extension. Here&#8217;s a grammar that&#8217;s useless because
it&#8217;s empty:
</p>
<pre class="code">
    <span class='comment val'># my_grammar.treetop</span>
    <span class='grammar identifier id'>grammar</span> <span class='MyGrammar constant id'>MyGrammar</span>
    <span class='end end kw'>end</span>
</pre>
<p>
Next, you start filling your grammar with rules. Each rule associates a
name with a parsing expression, like the following:
</p>
<pre class="code">
    <span class='comment val'># my_grammar.treetop</span>
    <span class='comment val'># You can use a .tt extension instead if you wish</span>
    <span class='grammar identifier id'>grammar</span> <span class='MyGrammar constant id'>MyGrammar</span>
      <span class='rule identifier id'>rule</span> <span class='hello identifier id'>hello</span>
        <span class='string val'>'hello chomsky'</span>
      <span class='end end kw'>end</span>
    <span class='end end kw'>end</span>
</pre>
<p>
The first rule becomes the <b>root</b> of the grammar, causing its
expression to be matched when a parser for the grammar is fed a string. The
above grammar can now be used in a Ruby program. Notice how a string
matching the first rule parses successfully, but a second nonmatching
string does not.
</p>
<pre class="code">
    <span class='comment val'># use_grammar.rb</span>
    <span class='require identifier id'>require</span> <span class='string val'>'rubygems'</span>
    <span class='require identifier id'>require</span> <span class='string val'>'treetop'</span>
    <span class='Treetop constant id'>Treetop</span><span class='dot token'>.</span><span class='load identifier id'>load</span> <span class='string val'>'my_grammar'</span>
    <span class='comment val'># or just:</span>
    <span class='comment val'># require 'my_grammar'                     # This works because Polyglot hooks &quot;require&quot; to find and load Treetop files</span>

    <span class='parser identifier id'>parser</span> <span class='assign token'>=</span> <span class='MyGrammarParser constant id'>MyGrammarParser</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
    <span class='puts identifier id'>puts</span> <span class='parser identifier id'>parser</span><span class='dot token'>.</span><span class='parse identifier id'>parse</span><span class='lparen token'>(</span><span class='string val'>'hello chomsky'</span><span class='rparen token'>)</span>         <span class='comment val'># =&gt; Treetop::Runtime::SyntaxNode</span>
    <span class='puts identifier id'>puts</span> <span class='parser identifier id'>parser</span><span class='dot token'>.</span><span class='parse identifier id'>parse</span><span class='lparen token'>(</span><span class='string val'>'silly generativists!'</span><span class='rparen token'>)</span>  <span class='comment val'># =&gt; nil</span>
</pre>
<p>
Users of *regular expressions* will find parsing expressions familiar. They
share the same basic purpose, matching strings against patterns. However,
parsing expressions can recognize a broader category of languages than
their less expressive brethren. Before we get into demonstrating that, lets
cover some basics. At first parsing expressions won&#8217;t seem much
different. Trust that they are.
</p>
<p>
Terminal Symbols
</p>
<hr size="10"></hr><p>
The expression in the grammar above is a terminal symbol. It will only
match a string that matches it exactly. There are two other kinds of
terminal symbols, which we&#8217;ll revisit later. Terminals are called
*atomic expressions* because they aren&#8217;t composed of smaller
expressions.
</p>
<p>
Ordered Choices
</p>
<hr size="10"></hr><p>
Ordered choices are *composite expressions*, which allow for any of several
subexpressions to be matched. These should be familiar from regular
expressions, but in parsing expressions, they are delimited by the `/`
character. Its important to note that the choices are prioritized in the
order they appear. If an earlier expression is matched, no subsequent
expressions are tried. Here&#8217;s an example:
</p>
<pre class="code">
    <span class='comment val'># my_grammar.treetop</span>
    <span class='grammar identifier id'>grammar</span> <span class='MyGrammar constant id'>MyGrammar</span>
      <span class='rule identifier id'>rule</span> <span class='hello identifier id'>hello</span>
        <span class='string val'>'hello chomsky'</span> <span class='div op'>/</span> <span class='string val'>'hello lambek'</span>
      <span class='end end kw'>end</span>
    <span class='end end kw'>end</span>

    <span class='comment val'># fragment of use_grammar.rb</span>
    <span class='puts identifier id'>puts</span> <span class='parser identifier id'>parser</span><span class='dot token'>.</span><span class='parse identifier id'>parse</span><span class='lparen token'>(</span><span class='string val'>'hello chomsky'</span><span class='rparen token'>)</span>         <span class='comment val'># =&gt; Treetop::Runtime::SyntaxNode</span>
    <span class='puts identifier id'>puts</span> <span class='parser identifier id'>parser</span><span class='dot token'>.</span><span class='parse identifier id'>parse</span><span class='lparen token'>(</span><span class='string val'>'hello lambek'</span><span class='rparen token'>)</span>          <span class='comment val'># =&gt; Treetop::Runtime::SyntaxNode</span>
    <span class='puts identifier id'>puts</span> <span class='parser identifier id'>parser</span><span class='dot token'>.</span><span class='parse identifier id'>parse</span><span class='lparen token'>(</span><span class='string val'>'silly generativists!'</span><span class='rparen token'>)</span>  <span class='comment val'># =&gt; nil</span>
</pre>
<p>
Note that once a choice rule has matched the text using a particular
alternative at a particular location in the input and hence has succeeded,
that choice will never be reconsidered, even if the chosen alternative
causes another rule to fail where a later alternative wouldn&#8217;t have.
It&#8217;s always a later alternative, since the first to succeed is final
- why keep looking when you&#8217;ve found what you wanted? This is a
feature of PEG parsers that you need to understand if you&#8217;re going to
succeed in using Treetop. In order to memoize success and failures, such
decisions cannot be reversed. Luckily Treetop provides a variety of clever
ways you can tell it to avoid making the wrong decisions. But more on that
later.
</p>
<p>
Sequences
</p>
<hr size="7"></hr><p>
Sequences are composed of other parsing expressions separated by spaces.
Using sequences, we can tighten up the above grammar.
</p>
<pre class="code">
    <span class='comment val'># my_grammar.treetop</span>
    <span class='grammar identifier id'>grammar</span> <span class='MyGrammar constant id'>MyGrammar</span>
      <span class='rule identifier id'>rule</span> <span class='hello identifier id'>hello</span>
        <span class='string val'>'hello '</span> <span class='lparen token'>(</span><span class='string val'>'chomsky'</span> <span class='div op'>/</span> <span class='string val'>'lambek'</span><span class='rparen token'>)</span>
      <span class='end end kw'>end</span>
    <span class='end end kw'>end</span>
</pre>
<p>
Note the use of parentheses to override the default precedence rules, which
bind sequences more tightly than choices.
</p>
<p>
Once the whole sequence has been matched, the result is memoized and the
details of the match will not be reconsidered for that location in the
input.
</p>
<p>
Nonterminal Symbols
</p>
<hr size="10"></hr><p>
Here we leave regular expressions behind. Nonterminals allow expressions to
refer to other expressions by name. A trivial use of this facility would
allow us to make the above grammar more readable should the list of names
grow longer.
</p>
<pre class="code">
    <span class='comment val'># my_grammar.treetop</span>
    <span class='grammar identifier id'>grammar</span> <span class='MyGrammar constant id'>MyGrammar</span>
      <span class='rule identifier id'>rule</span> <span class='hello identifier id'>hello</span>
        <span class='string val'>'hello '</span> <span class='linguist identifier id'>linguist</span>
      <span class='end end kw'>end</span>

      <span class='rule identifier id'>rule</span> <span class='linguist identifier id'>linguist</span>
        <span class='string val'>'chomsky'</span> <span class='div op'>/</span> <span class='string val'>'lambek'</span> <span class='div op'>/</span> <span class='string val'>'jacobsen'</span> <span class='div op'>/</span> <span class='string val'>'frege'</span>
      <span class='end end kw'>end</span>
    <span class='end end kw'>end</span>
</pre>
<p>
The true power of this facility, however, is unleashed when writing
*recursive expressions*. Here is a self-referential expression that can
match any number of open parentheses followed by any number of closed
parentheses. This is theoretically impossible with regular expressions due
to the *pumping lemma*.
</p>
<pre class="code">
    <span class='comment val'># parentheses.treetop</span>
    <span class='grammar identifier id'>grammar</span> <span class='Parentheses constant id'>Parentheses</span>
      <span class='rule identifier id'>rule</span> <span class='parens identifier id'>parens</span>
        <span class='string val'>'('</span> <span class='parens identifier id'>parens</span> <span class='string val'>')'</span> <span class='div op'>/</span> <span class='string val'>''</span>
      <span class='end end kw'>end</span>
    <span class='end end kw'>end</span>
</pre>
<p>
The `parens` expression simply states that a `parens` is a set of
parentheses surrounding another `parens` expression or, if that
doesn&#8217;t match, the empty string. If you are uncomfortable with
recursion, its time to get comfortable, because it is the basis of
language. Here&#8217;s a tip: Don&#8217;t try and imagine the parser
circling round and round through the same rule. Instead, imagine the rule
is <b>already</b> defined while you are defining it. If you imagine that
`parens` already matches a string of matching parentheses, then its easy to
think of `parens` as an open and closing parentheses around another set of
matching parentheses, which conveniently, you happen to be defining. You
know that `parens` is supposed to represent a string of matched
parentheses, so trust in that meaning, even if you haven&#8217;t fully
implemented it yet.
</p>
<p>
Repetition
</p>
<hr size="8"></hr><p>
Any item in a rule may be followed by a &#8217;+&#8217; or a
&#8217;*&#8217; character, signifying one-or-more and zero-or-more
occurrences of that item. Beware though; the match is greedy, and if it
matches too many items and causes subsequent items in the sequence to fail,
the number matched will never be reconsidered. Here&#8217;s a simple
example of a rule that will never succeed:
</p>
<pre class="code">
    <span class='comment val'># toogreedy.treetop</span>
    <span class='grammar identifier id'>grammar</span> <span class='TooGreedy constant id'>TooGreedy</span>
      <span class='rule identifier id'>rule</span> <span class='a_s identifier id'>a_s</span>
        <span class='string val'>'a'</span><span class='mult op'>*</span> <span class='string val'>'a'</span>
      <span class='end end kw'>end</span>
    <span class='end end kw'>end</span>
</pre>
<p>
The &#8216;a&#8217;* will always eat up any &#8216;a&#8217;s that follow,
and the subsequent &#8216;a&#8217; will find none there, so the whole rule
will fail. You might need to use lookahead to avoid matching too much.
</p>
<p>
Negative Lookahead
</p>
<hr size="10"></hr><p>
When you need to ensure that the following item *doesn&#8217;t* match in
some case where it might otherwise, you can use negat!ve lookahead, which
is an item preceeded by a ! - here&#8217;s an example:
</p>
<pre class="code">
    <span class='comment val'># postcondition.treetop</span>
    <span class='grammar identifier id'>grammar</span> <span class='PostCondition constant id'>PostCondition</span>
      <span class='rule identifier id'>rule</span> <span class='conditional_sentence identifier id'>conditional_sentence</span>
        <span class='lparen token'>(</span> <span class='notop op'>!</span><span class='conditional_keyword identifier id'>conditional_keyword</span> <span class='word identifier id'>word</span> <span class='rparen token'>)</span><span class='plus op'>+</span> <span class='conditional_keyword identifier id'>conditional_keyword</span> <span class='lbrack token'>[</span> \<span class='t identifier id'>t</span><span class='rbrack token'>]</span><span class='plus op'>+</span> <span class='word identifier id'>word</span><span class='mult op'>*</span>
      <span class='end end kw'>end</span>

      <span class='rule identifier id'>rule</span> <span class='word identifier id'>word</span>
        <span class='lparen token'>(</span><span class='lbrack token'>[</span><span class='a identifier id'>a</span><span class='minus op'>-</span><span class='zA identifier id'>zA</span><span class='minus op'>-</span><span class='Z constant id'>Z</span><span class='rbrack token'>]</span><span class='plus op'>+</span> <span class='lbrack token'>[</span> \<span class='t identifier id'>t</span><span class='rbrack token'>]</span><span class='plus op'>+</span><span class='rparen token'>)</span>
      <span class='end end kw'>end</span>

      <span class='rule identifier id'>rule</span> <span class='conditional_keyword identifier id'>conditional_keyword</span>
        <span class='string val'>'if'</span> <span class='div op'>/</span> <span class='string val'>'while'</span> <span class='div op'>/</span> <span class='string val'>'until'</span>
      <span class='end end kw'>end</span>
    <span class='end end kw'>end</span>
</pre>
<p>
Even though the rule `word` would match any of the conditional keywords,
the first words of a conditional_sentence must not be conditional_keywords.
The negative lookahead prevents that matching, and prevents the repetition
from matching too much input. Note that the lookahead may be a grammar rule
of any complexity, including one that isn&#8217;t used elsewhere in your
grammar.
</p>
<p>
Positive lookahead
</p>
<hr size="10"></hr><p>
Sometimes you want an item to match, but only if the <b>following</b> text
would match some pattern. You don&#8217;t want to consume that following
text, but if it&#8217;s not there, you want this rule to fail. You can
append a positive lookahead like this to a rule by appending the lookahead
rule preceeded by an &amp; character.
</p>
<p>
Features to cover in the talk
</p>
<h6>=======================</h6>
<ul>
<li>Treetop files

</li>
<li>Grammar definition

</li>
<li>Rules

</li>
<li>Loading a grammar

</li>
<li>Compiling a grammar with the `tt` command

</li>
<li>Accessing a parser for the grammar from Ruby

</li>
<li>Parsing Expressions of all kinds

</li>
</ul>
<p>
? Left recursion and factorization
</p>
<pre class="code">
  <span class='minus op'>-</span> <span class='Here constant id'>Here</span> <span class='I constant id'>I</span> <span class='can identifier id'>can</span> <span class='talk identifier id'>talk</span> <span class='about identifier id'>about</span> <span class='function identifier id'>function</span> <span class='application identifier id'>application</span><span class='comma token'>,</span> <span class='discussing identifier id'>discussing</span> <span class='how identifier id'>how</span> <span class='the identifier id'>the</span> <span class='operator identifier id'>operator</span>
    <span class='could identifier id'>could</span> <span class='be identifier id'>be</span> <span class='an identifier id'>an</span> <span class='arbitrary identifier id'>arbitrary</span> <span class='expression identifier id'>expression</span>
</pre>
<ul>
<li>Inline node class eval blocks

</li>
<li>Node class declarations

</li>
<li>Labels

</li>
<li>Use of super within within labels

</li>
<li>Grammar composition with include

</li>
<li>Use of super with grammar composition

</li>
</ul>

</div>
          </div>
        </div>
      </div>                    
    </div>

    <div id="footer">
      <div class="site">
        <div class="info">
          <div class="links">
            <a href="http://github.com/blog/148-github-shirts-now-available">Shirts</a> |
            <a href="http://github.com/blog">Blog</a> |
            <a href="http://support.github.com/">Support</a> |
            <a href="http://github.com/training">Training</a> |
            <a href="http://github.com/contact">Contact</a> |
            <a href="http://groups.google.com/group/github/">Google Group</a> |
            <a href="http://develop.github.com/">API</a> |
            <a href="http://twitter.com/github">Status</a>
          </div>
          <div class="company">
            <span id="_rrt" title="0.64509s from xc88-s00039">GitHub</span>
            is <a href="http://logicalawesome.com/">Logical Awesome</a> ©2009 | <a href="http://github.com/site/terms">Terms of Service</a> | <a href="http://github.com/site/privacy">Privacy Policy</a>
          </div>
        </div>
        <div class="sponsor">
          <a href="http://engineyard.com/"><img src="http://github.com/images/modules/footer/engine_yard_logo.png" alt="Engine Yard"></a>
          <div>
            Hosting provided by our<br> partners at Engine Yard
          </div>
        </div>
      </div>
    </div>
    
    <div id="coming_soon" style="display: none;">
      This feature is coming soon.  Sit tight!
    </div>

    <div id="facebox" style="display: none;">       
      <div class="popup">         
        <table>           
          <tbody>             
            <tr>               
              <td class="tl"></td>
              <td class="b"></td>
              <td class="tr"></td>             
            </tr>             
          <tr>               
            <td class="b"></td>               
            <td class="body">                 
              <div class="content"></div>                 
              <div class="footer">                   
                <a href="#" class="close"><img src="http://github.com/facebox/closelabel.gif" title="close" class="close_image"></a>                 
              </div>               
            </td>               
            <td class="b"></td>             
          </tr>             
          <tr>               
            <td class="bl"></td>
            <td class="b"></td>
            <td class="br"></td>             
          </tr>           
        </tbody>         
      </table>       
    </div>     


    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
    var pageTracker = _gat._getTracker("UA-8689483-1");
    pageTracker._trackPageview();
    } catch(err) {}</script>

  </body>
</html>