<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <title>jeremyevans's sequel - GitHub Documentation</title>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="description" content="">

<link rel="search" type="application/opensearchdescription+xml" href="http://github.com/opensearch.xml" title="GitHub">
<link rel="fluid-icon" href="http://github.com/fluidicon.png" title="GitHub">
<link href="http://assets0.github.com/stylesheets/bundle.css" media="screen" rel="stylesheet" type="text/css">
<link href="http://github.com/feeds/jeremyevans/commits/sequel/master" rel="alternate" title="Recent Commits to sequel:master" type="application/atom+xml">

<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js"></script>
<script type="text/javascript" src="http://assets3.github.com/javascripts/bundle.js"></script>              
<script src="app.js" type="text/javascript" charset="utf-8"></script>

<script type="text/javascript" src="http://docs.github.com/javascripts/md5.js"></script>
<script type="text/javascript" src="http://docs.github.com/javascripts/repos.js"></script>
<script type="text/javascript" src="http://docs.github.com/javascripts/commits.js"></script>
<script type="text/javascript">
  $(document).ready(function(){
    if (typeof skipHeaders != 'undefined') return;
    
    GitHubRepo.init("jeremyevans", "sequel", function(){ 
      GitHubRepo.links = " <a id='namespaces_button' rel='jeremyevans/sequel/blob/359941f44fdc643ef462ae07fb3aa08d2e3b8d97' href='#'><img class='button' src='http://docs.github.com/namespaces_button.png' alt='Modules and Classes'/></a> ";
      GitHubRepo.links += " <a id='methods_button' rel='jeremyevans/sequel/blob/359941f44fdc643ef462ae07fb3aa08d2e3b8d97' href='#'><img class='button' src='http://docs.github.com/methods_button.png' alt='Methods'/></a> ";
      $("#repo").html(GitHubRepo.content());
      $('#namespaces_button').click(function(){
        var url="/"+$(this).attr('rel')+"/namespaces/";
        $.gitbox(url);
        return false;
      });    
      $('#methods_button').click(function(){
        var url="/"+$(this).attr('rel')+"/methods/";
        $.gitbox(url);
        return false;
      });        
    });
    GitHubCommit.init("jeremyevans", "sequel", "359941f44fdc643ef462ae07fb3aa08d2e3b8d97", function(){ 
      $("#commit").html(GitHubCommit.content());
    });
  });
</script>

    <link rel="stylesheet" href="style.css" type="text/css" charset="utf-8" />
  </head>
  <body>    
    
    
        <div id="main" style="padding-bottom:8em;">
      <div id="header">
        <div class="site">
          <div class="logo">
            <a href="http://github.com/"><img src="http://github.com/images/modules/header/logov3.png" alt="github"></a>
          </div>          
          <div class="topsearch">
            <form action="http://github.com/search" id="top_search_form" method="get">
              <input class="search" name="q" type="search"> <input value="Search" type="submit">
            </form>
            <div class="links">
              <a href="http://github.com/repositories">Browse</a> | <a href="http://github.com/guides">Guides</a> | <a href="http://github.com/search">Advanced</a>
            </div>
          </div>
          <div class="actions">
            <a href="http://github.com">Home</a>
            <a href="http://github.com/plans"><b><u>Pricing and Signup</u></b></a>
            <a href="http://docs.github.com/">Documentation</a>
            <a href="https://github.com/login">Login</a>
          </div>                  
        </div>
      </div>    
                                                  
      <div id="repo_menu">
        <div class="site">
          <ul>          
            <li class=""><a href="http://github.com/jeremyevans/sequel/tree/">Source</a></li>
            <li class=""><a href="http://github.com/jeremyevans/sequel/commits/">Commits</a></li>            
            <li class=""><a href="http://github.com/jeremyevans/sequel/network">Network</a></li>            
            <li class=""><a href="http://github.com/jeremyevans/sequel/issues">Issues</a></li>
            <li class=""><a href="http://wiki.github.com/jeremyevans/sequel">Wiki</a></li>
            <li class=""><a href="http://github.com/jeremyevans/sequel/graphs">Graphs</a></li>                    
            <li class="active"><a href="/jeremyevans/sequel">Documentation</a></li>
          </ul>
        </div>
      </div>

      <div id="repo_sub_menu">
        <div class="site">
          <div class="joiner"></div>      
        </div>
      </div>

      <div class="site">  
        <div id="repos">
          <div id="repo" class="repo public">
            <div class="title">
              <div class="path">
                <a href="http://github.com/jeremyevans">jeremyevans</a> / <b><a href="http://github.com/jeremyevans/sequel/tree">sequel</a></b>        
                <a id="namespaces_button" rel="jeremyevans/sequel/blob/359941f44fdc643ef462ae07fb3aa08d2e3b8d97" href="#"><img class="button" src="http://docs.github.com/namespaces_button.png" alt="Modules and Classes"/></a>
                <a id="methods_button" rel="jeremyevans/sequel/blob/359941f44fdc643ef462ae07fb3aa08d2e3b8d97" href="#"><img class="button" src="http://docs.github.com/methods_button.png" alt="Methods"/></a>
              </div>
            </div>            
          </div>
          <div id="commit">
          </div> 
          <br/>                                       
          <div id="content">
            <div class="section docstring readme wikistyle">
  <h2>Sequel: The Database Toolkit for Ruby</h2>
<p>
Sequel is a lightweight database access toolkit for Ruby.
</p>
<ul>
<li>Sequel provides thread safety, connection pooling and a concise DSL for
constructing database queries and table schemas.

</li>
<li>Sequel also includes a lightweight but comprehensive ORM layer for mapping
records to Ruby objects and handling associated records.

</li>
<li>Sequel supports advanced database features such as prepared statements,
bound variables, stored procedures, master/slave configurations, and
database sharding.

</li>
<li>Sequel makes it easy to deal with multiple records without having to break
your teeth on SQL.

</li>
<li>Sequel currently has adapters for ADO, Amalgalite, DataObjects, DB2, DBI,
Firebird, Informix, JDBC, MySQL, ODBC, OpenBase, Oracle, PostgreSQL and
SQLite3.

</li>
</ul>
<h2>Resources</h2>
<ul>
<li><tt>Website</tt>[http://sequel.rubyforge.org]

</li>
<li><tt>code</tt>[http://github.com/jeremyevans/sequel]

</li>
<li><tt>tracking</tt>[http://code.google.com/p/ruby-sequel/issues/list]

</li>
<li><tt>group</tt>[http://groups.google.com/group/sequel-talk]

</li>
<li><tt>RDoc</tt>[http://sequel.rubyforge.org/rdoc]

</li>
</ul>
<p>
To check out the source code:
</p>
<pre class="code">
  <span class='git identifier id'>git</span> <span class='clone identifier id'>clone</span> <span class='git identifier id'>git</span><span class='symbol val'>:/</span><span class='regexp val'>/github.com/</span><span class='jeremyevans identifier id'>jeremyevans</span><span class='div op'>/</span><span class='sequel identifier id'>sequel</span><span class='dot token'>.</span><span class='git identifier id'>git</span>
</pre>
<h3>Contact</h3>
<p>
If you have any comments or suggestions please post to the Google group.
</p>
<h2>Installation</h2>
<pre class="code">
  <span class='sudo identifier id'>sudo</span> <span class='gem identifier id'>gem</span> <span class='install identifier id'>install</span> <span class='sequel identifier id'>sequel</span>
</pre>
<h2>A Short Example</h2>
<pre class="code">
  <span class='require identifier id'>require</span> <span class='string val'>'rubygems'</span>
  <span class='require identifier id'>require</span> <span class='string val'>'sequel'</span>

  <span class='DB constant id'>DB</span> <span class='assign token'>=</span> <span class='Sequel constant id'>Sequel</span><span class='dot token'>.</span><span class='sqlite identifier id'>sqlite</span> <span class='comment val'># memory database</span>

  <span class='DB constant id'>DB</span><span class='dot token'>.</span><span class='create_table identifier id'>create_table</span> <span class='symbol val'>:items</span> <span class='do do kw'>do</span>
    <span class='primary_key identifier id'>primary_key</span> <span class='symbol val'>:id</span>
    <span class='String constant id'>String</span> <span class='symbol val'>:name</span>
    <span class='Float constant id'>Float</span> <span class='symbol val'>:price</span>
  <span class='end end kw'>end</span>

  <span class='items identifier id'>items</span> <span class='assign token'>=</span> <span class='DB constant id'>DB</span><span class='lbrack token'>[</span><span class='symbol val'>:items</span><span class='rbrack token'>]</span> <span class='comment val'># Create a dataset</span>

  <span class='comment val'># Populate the table</span>
  <span class='items identifier id'>items</span><span class='dot token'>.</span><span class='insert identifier id'>insert</span><span class='lparen token'>(</span><span class='symbol val'>:name</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'abc'</span><span class='comma token'>,</span> <span class='symbol val'>:price</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='rand identifier id'>rand</span> <span class='mult op'>*</span> <span class='integer val'>100</span><span class='rparen token'>)</span>
  <span class='items identifier id'>items</span><span class='dot token'>.</span><span class='insert identifier id'>insert</span><span class='lparen token'>(</span><span class='symbol val'>:name</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'def'</span><span class='comma token'>,</span> <span class='symbol val'>:price</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='rand identifier id'>rand</span> <span class='mult op'>*</span> <span class='integer val'>100</span><span class='rparen token'>)</span>
  <span class='items identifier id'>items</span><span class='dot token'>.</span><span class='insert identifier id'>insert</span><span class='lparen token'>(</span><span class='symbol val'>:name</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'ghi'</span><span class='comma token'>,</span> <span class='symbol val'>:price</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='rand identifier id'>rand</span> <span class='mult op'>*</span> <span class='integer val'>100</span><span class='rparen token'>)</span>

  <span class='comment val'># Print out the number of records</span>
  <span class='puts identifier id'>puts</span> <span class='dstring node'>&quot;Item count: #{items.count}&quot;</span>

  <span class='comment val'># Print out the average price</span>
  <span class='puts identifier id'>puts</span> <span class='dstring node'>&quot;The average price is: #{items.avg(:price)}&quot;</span>
</pre>
<h2>The Sequel Console</h2>
<p>
Sequel includes an IRB console for quick access to databases. You can use
it like this:
</p>
<pre class="code">
  <span class='sequel identifier id'>sequel</span> <span class='sqlite identifier id'>sqlite</span><span class='symbol val'>:/</span><span class='regexp val'>/test.db # test.db in current directory
</span></pre>
<p>
You get an IRB session with the database object stored in DB.
</p>
<h2>An Introduction</h2>
<p>
Sequel is designed to take the hassle away from connecting to databases and
manipulating them. Sequel deals with all the boring stuff like maintaining
connections, formatting SQL correctly and fetching records so you can
concentrate on your application.
</p>
<p>
Sequel uses the concept of datasets to retrieve data. A Dataset object
encapsulates an SQL query and supports chainability, letting you fetch data
using a convenient Ruby DSL that is both concise and flexible.
</p>
<p>
For example, the following one-liner returns the average GDP for the five
biggest countries in the middle east region:
</p>
<pre class="code">
  <span class='DB constant id'>DB</span><span class='lbrack token'>[</span><span class='symbol val'>:countries</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lparen token'>(</span><span class='symbol val'>:region</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'Middle East'</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='reverse_order identifier id'>reverse_order</span><span class='lparen token'>(</span><span class='symbol val'>:area</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='limit identifier id'>limit</span><span class='lparen token'>(</span><span class='integer val'>5</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='avg identifier id'>avg</span><span class='lparen token'>(</span><span class='symbol val'>:GDP</span><span class='rparen token'>)</span>
</pre>
<p>
Which is equivalent to:
</p>
<pre class="code">
  <span class='SELECT constant id'>SELECT</span> <span class='avg identifier id'>avg</span><span class='lparen token'>(</span><span class='GDP constant id'>GDP</span><span class='rparen token'>)</span> <span class='FROM constant id'>FROM</span> <span class='countries identifier id'>countries</span> <span class='WHERE constant id'>WHERE</span> <span class='region identifier id'>region</span> <span class='assign token'>=</span> <span class='string val'>'Middle East'</span> <span class='ORDER constant id'>ORDER</span> <span class='BY constant id'>BY</span> <span class='area identifier id'>area</span> <span class='DESC constant id'>DESC</span> <span class='LIMIT constant id'>LIMIT</span> <span class='integer val'>5</span>
</pre>
<p>
Since datasets retrieve records only when needed, they can be stored and
later reused. Records are fetched as hashes (or custom model objects), and
are accessed using an Enumerable interface:
</p>
<pre class="code">
  <span class='middle_east identifier id'>middle_east</span> <span class='assign token'>=</span> <span class='DB constant id'>DB</span><span class='lbrack token'>[</span><span class='symbol val'>:countries</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lparen token'>(</span><span class='symbol val'>:region</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'Middle East'</span><span class='rparen token'>)</span>
  <span class='middle_east identifier id'>middle_east</span><span class='dot token'>.</span><span class='order identifier id'>order</span><span class='lparen token'>(</span><span class='symbol val'>:name</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='each identifier id'>each</span><span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='r identifier id'>r</span><span class='bitor op'>|</span> <span class='puts identifier id'>puts</span> <span class='r identifier id'>r</span><span class='lbrack token'>[</span><span class='symbol val'>:name</span><span class='rbrack token'>]</span><span class='rbrace token'>}</span>
</pre>
<p>
Sequel also offers convenience methods for extracting data from Datasets,
such as an extended map method:
</p>
<pre class="code">
  <span class='middle_east identifier id'>middle_east</span><span class='dot token'>.</span><span class='map identifier id'>map</span><span class='lparen token'>(</span><span class='symbol val'>:name</span><span class='rparen token'>)</span> <span class='comment val'>#=&gt; ['Egypt', 'Greece', 'Israel', ...]</span>
</pre>
<p>
Or getting results as a transposed hash, with one column as key and another
as value:
</p>
<pre class="code">
  <span class='middle_east identifier id'>middle_east</span><span class='dot token'>.</span><span class='to_hash identifier id'>to_hash</span><span class='lparen token'>(</span><span class='symbol val'>:name</span><span class='comma token'>,</span> <span class='symbol val'>:area</span><span class='rparen token'>)</span> <span class='comment val'>#=&gt; &lt;tt&gt;=&amp;gt; 20000, 'Greece' =&amp;gt; 120000, ...&lt;/tt&gt;</span>
</pre>
<h2>Getting Started</h2>
<h3>Connecting to a database</h3>
<p>
To connect to a database you simply provide Sequel with a URL:
</p>
<pre class="code">
  <span class='require identifier id'>require</span> <span class='string val'>'sequel'</span>
  <span class='DB constant id'>DB</span> <span class='assign token'>=</span> <span class='Sequel constant id'>Sequel</span><span class='dot token'>.</span><span class='connect identifier id'>connect</span><span class='lparen token'>(</span><span class='string val'>'sqlite://blog.db'</span><span class='rparen token'>)</span>
</pre>
<p>
The connection URL can also include such stuff as the user name and
password:
</p>
<pre class="code">
  <span class='DB constant id'>DB</span> <span class='assign token'>=</span> <span class='Sequel constant id'>Sequel</span><span class='dot token'>.</span><span class='connect identifier id'>connect</span><span class='lparen token'>(</span><span class='string val'>'postgres://cico:12345@localhost:5432/mydb'</span><span class='rparen token'>)</span>
</pre>
<p>
You can also specify optional parameters, such as the connection pool size,
or loggers for logging SQL queries:
</p>
<pre class="code">
  <span class='DB constant id'>DB</span> <span class='assign token'>=</span> <span class='Sequel constant id'>Sequel</span><span class='dot token'>.</span><span class='connect identifier id'>connect</span><span class='lparen token'>(</span><span class='string val'>&quot;postgres://postgres:postgres@localhost/my_db&quot;</span><span class='comma token'>,</span>
    <span class='symbol val'>:max_connections</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='integer val'>10</span><span class='comma token'>,</span> <span class='symbol val'>:loggers</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='lbrack token'>[</span><span class='Logger constant id'>Logger</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='string val'>'log/db.log'</span><span class='rbrack token'>]</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
</pre>
<p>
You can specify a block to connect, which will disconnect from the database
after it completes:
</p>
<pre class="code">
  <span class='Sequel constant id'>Sequel</span><span class='dot token'>.</span><span class='connect identifier id'>connect</span><span class='lparen token'>(</span><span class='string val'>'postgres://cico:12345@localhost:5432/mydb'</span><span class='rparen token'>)</span><span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='db identifier id'>db</span><span class='bitor op'>|</span> <span class='db identifier id'>db</span><span class='lbrack token'>[</span><span class='symbol val'>:posts</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='delete identifier id'>delete</span><span class='rbrace token'>}</span>
</pre>
<h3>Arbitrary SQL queries</h3>
<pre class="code">
  <span class='DB constant id'>DB</span> <span class='lshft op'>&lt;&lt;</span> <span class='string val'>&quot;create table t (a text, b text)&quot;</span>
  <span class='DB constant id'>DB</span> <span class='lshft op'>&lt;&lt;</span> <span class='string val'>&quot;insert into t values ('a', 'b')&quot;</span>
</pre>
<p>
You can also create datasets based on raw SQL:
</p>
<pre class="code">
  <span class='dataset identifier id'>dataset</span> <span class='assign token'>=</span> <span class='DB constant id'>DB</span><span class='lbrack token'>[</span><span class='string val'>'select id from items'</span><span class='rbrack token'>]</span>
  <span class='dataset identifier id'>dataset</span><span class='dot token'>.</span><span class='count identifier id'>count</span> <span class='comment val'># will return the number of records in the result set</span>
  <span class='dataset identifier id'>dataset</span><span class='dot token'>.</span><span class='map identifier id'>map</span><span class='lparen token'>(</span><span class='symbol val'>:id</span><span class='rparen token'>)</span> <span class='comment val'># will return an array containing all values of the id column in the result set</span>
</pre>
<p>
You can also fetch records with raw SQL through the dataset:
</p>
<pre class="code">
  <span class='DB constant id'>DB</span><span class='lbrack token'>[</span><span class='string val'>'select * from items'</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='each identifier id'>each</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='row identifier id'>row</span><span class='bitor op'>|</span>
    <span class='p identifier id'>p</span> <span class='row identifier id'>row</span>
  <span class='end end kw'>end</span>
</pre>
<p>
You can use placeholders in your SQL string as well:
</p>
<pre class="code">
  <span class='DB constant id'>DB</span><span class='lbrack token'>[</span><span class='string val'>'select * from items where name = ?'</span><span class='comma token'>,</span> <span class='name identifier id'>name</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='each identifier id'>each</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='row identifier id'>row</span><span class='bitor op'>|</span>
    <span class='p identifier id'>p</span> <span class='row identifier id'>row</span>
  <span class='end end kw'>end</span>
</pre>
<h3>Getting Dataset Instances</h3>
<p>
Datasets are the primary way records are retrieved and manipulated. They
are generally created via the Database#from or Database#[] methods:
</p>
<pre class="code">
  <span class='posts identifier id'>posts</span> <span class='assign token'>=</span> <span class='DB constant id'>DB</span><span class='dot token'>.</span><span class='from identifier id'>from</span><span class='lparen token'>(</span><span class='symbol val'>:posts</span><span class='rparen token'>)</span>
  <span class='posts identifier id'>posts</span> <span class='assign token'>=</span> <span class='DB constant id'>DB</span><span class='lbrack token'>[</span><span class='symbol val'>:posts</span><span class='rbrack token'>]</span> <span class='comment val'># same</span>
</pre>
<p>
Datasets will only fetch records when you tell them to. They can be
manipulated to filter records, change ordering, join tables, etc..
</p>
<h3>Retrieving Records</h3>
<p>
You can retrieve all records by using the all method:
</p>
<pre class="code">
  <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='all identifier id'>all</span>
</pre>
<p>
The all method returns an array of hashes, where each hash corresponds to a
record.
</p>
<p>
You can also iterate through records one at a time:
</p>
<pre class="code">
  <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='each identifier id'>each</span><span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='row identifier id'>row</span><span class='bitor op'>|</span> <span class='p identifier id'>p</span> <span class='row identifier id'>row</span><span class='rbrace token'>}</span>
</pre>
<p>
Or perform more advanced stuff:
</p>
<pre class="code">
  <span class='names_and_dates identifier id'>names_and_dates</span> <span class='assign token'>=</span> <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='map identifier id'>map</span><span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='r identifier id'>r</span><span class='bitor op'>|</span> <span class='lbrack token'>[</span><span class='r identifier id'>r</span><span class='lbrack token'>[</span><span class='symbol val'>:name</span><span class='rbrack token'>]</span><span class='comma token'>,</span> <span class='r identifier id'>r</span><span class='lbrack token'>[</span><span class='symbol val'>:date</span><span class='rbrack token'>]</span><span class='rbrack token'>]</span><span class='rbrace token'>}</span>
  <span class='old_posts identifier id'>old_posts</span><span class='comma token'>,</span> <span class='recent_posts identifier id'>recent_posts</span> <span class='assign token'>=</span> <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='partition identifier id'>partition</span><span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='r identifier id'>r</span><span class='bitor op'>|</span> <span class='r identifier id'>r</span><span class='lbrack token'>[</span><span class='symbol val'>:date</span><span class='rbrack token'>]</span> <span class='lt op'>&lt;</span> <span class='Date constant id'>Date</span><span class='dot token'>.</span><span class='today identifier id'>today</span> <span class='minus op'>-</span> <span class='integer val'>7</span><span class='rbrace token'>}</span>
</pre>
<p>
You can also retrieve the first record in a dataset:
</p>
<pre class="code">
  <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='first identifier id'>first</span>
</pre>
<p>
Or retrieve a single record with a specific value:
</p>
<pre class="code">
  <span class='posts identifier id'>posts</span><span class='lbrack token'>[</span><span class='symbol val'>:id</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='integer val'>1</span><span class='rbrack token'>]</span>
</pre>
<p>
If the dataset is ordered, you can also ask for the last record:
</p>
<pre class="code">
  <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='order identifier id'>order</span><span class='lparen token'>(</span><span class='symbol val'>:stamp</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='last identifier id'>last</span>
</pre>
<h3>Filtering Records</h3>
<p>
An easy way to filter records is to provide a hash of values to match:
</p>
<pre class="code">
  <span class='my_posts identifier id'>my_posts</span> <span class='assign token'>=</span> <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lparen token'>(</span><span class='symbol val'>:category</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'ruby'</span><span class='comma token'>,</span> <span class='symbol val'>:author</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'david'</span><span class='rparen token'>)</span>
</pre>
<p>
You can also specify ranges:
</p>
<pre class="code">
  <span class='my_posts identifier id'>my_posts</span> <span class='assign token'>=</span> <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lparen token'>(</span><span class='symbol val'>:stamp</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='lparen token'>(</span><span class='Date constant id'>Date</span><span class='dot token'>.</span><span class='today identifier id'>today</span> <span class='minus op'>-</span> <span class='integer val'>14</span><span class='rparen token'>)</span><span class='dot2 op'>..</span><span class='lparen token'>(</span><span class='Date constant id'>Date</span><span class='dot token'>.</span><span class='today identifier id'>today</span> <span class='minus op'>-</span> <span class='integer val'>7</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
</pre>
<p>
Or arrays of values:
</p>
<pre class="code">
  <span class='my_posts identifier id'>my_posts</span> <span class='assign token'>=</span> <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lparen token'>(</span><span class='symbol val'>:category</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='lbrack token'>[</span><span class='string val'>'ruby'</span><span class='comma token'>,</span> <span class='string val'>'postgres'</span><span class='comma token'>,</span> <span class='string val'>'linux'</span><span class='rbrack token'>]</span><span class='rparen token'>)</span>
</pre>
<p>
Sequel also accepts expressions:
</p>
<pre class="code">
  <span class='my_posts identifier id'>my_posts</span> <span class='assign token'>=</span> <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='o identifier id'>o</span><span class='bitor op'>|</span> <span class='o identifier id'>o</span><span class='dot token'>.</span><span class='stamp identifier id'>stamp</span> <span class='gt op'>&gt;</span> <span class='Date constant id'>Date</span><span class='dot token'>.</span><span class='today identifier id'>today</span> <span class='lshft op'>&lt;&lt;</span> <span class='integer val'>1</span><span class='rbrace token'>}</span>
</pre>
<p>
Some adapters will also let you specify Regexps:
</p>
<pre class="code">
  <span class='my_posts identifier id'>my_posts</span> <span class='assign token'>=</span> <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lparen token'>(</span><span class='symbol val'>:category</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='regexp val'>/ruby/i</span><span class='rparen token'>)</span>
</pre>
<p>
You can also use an inverse filter:
</p>
<pre class="code">
  <span class='my_posts identifier id'>my_posts</span> <span class='assign token'>=</span> <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='exclude identifier id'>exclude</span><span class='lparen token'>(</span><span class='symbol val'>:category</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='regexp val'>/ruby/i</span><span class='rparen token'>)</span>
</pre>
<p>
You can also specify a custom WHERE clause using a string:
</p>
<pre class="code">
  <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lparen token'>(</span><span class='string val'>'stamp IS NOT NULL'</span><span class='rparen token'>)</span>
</pre>
<p>
You can use parameters in your string, as well:
</p>
<pre class="code">
  <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lparen token'>(</span><span class='string val'>'(stamp &lt; ?) AND (author != ?)'</span><span class='comma token'>,</span> <span class='Date constant id'>Date</span><span class='dot token'>.</span><span class='today identifier id'>today</span> <span class='minus op'>-</span> <span class='integer val'>3</span><span class='comma token'>,</span> <span class='author_name identifier id'>author_name</span><span class='rparen token'>)</span>
  <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='o identifier id'>o</span><span class='bitor op'>|</span> <span class='lparen token'>(</span><span class='o identifier id'>o</span><span class='dot token'>.</span><span class='stamp identifier id'>stamp</span> <span class='lt op'>&lt;</span> <span class='Date constant id'>Date</span><span class='dot token'>.</span><span class='today identifier id'>today</span> <span class='minus op'>-</span> <span class='integer val'>3</span><span class='rparen token'>)</span> <span class='bitand op'>&amp;</span> <span class='bitnot op'>~</span><span class='lbrace token'>{</span><span class='symbol val'>:author</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='author_name identifier id'>author_name</span><span class='rbrace token'>}</span><span class='rbrace token'>}</span> <span class='comment val'># same as above</span>
</pre>
<p>
Datasets can also be used as subqueries:
</p>
<pre class="code">
  <span class='DB constant id'>DB</span><span class='lbrack token'>[</span><span class='symbol val'>:items</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lparen token'>(</span><span class='string val'>'price &gt; ?'</span><span class='comma token'>,</span> <span class='DB constant id'>DB</span><span class='lbrack token'>[</span><span class='symbol val'>:items</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='select identifier id'>select</span><span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='o identifier id'>o</span><span class='bitor op'>|</span> <span class='o identifier id'>o</span><span class='dot token'>.</span><span class='avg identifier id'>avg</span><span class='lparen token'>(</span><span class='symbol val'>:price</span><span class='rparen token'>)</span> <span class='plus op'>+</span> <span class='integer val'>100</span><span class='rbrace token'>}</span><span class='rparen token'>)</span>
</pre>
<p>
After filtering you can retrieve the matching records by using any of the
retrieval methods:
</p>
<pre class="code">
  <span class='my_posts identifier id'>my_posts</span><span class='dot token'>.</span><span class='each identifier id'>each</span><span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='row identifier id'>row</span><span class='bitor op'>|</span> <span class='p identifier id'>p</span> <span class='row identifier id'>row</span><span class='rbrace token'>}</span>
</pre>
<p>
See the doc/dataset_filtering.rdoc file for more details.
</p>
<h3>Summarizing Records</h3>
<p>
Counting records is easy:
</p>
<pre class="code">
  <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lparen token'>(</span><span class='symbol val'>:category</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='regexp val'>/ruby/i</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='count identifier id'>count</span>
</pre>
<p>
And you can also query maximum/minimum values:
</p>
<pre class="code">
  <span class='max identifier id'>max</span> <span class='assign token'>=</span> <span class='DB constant id'>DB</span><span class='lbrack token'>[</span><span class='symbol val'>:history</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='max identifier id'>max</span><span class='lparen token'>(</span><span class='symbol val'>:value</span><span class='rparen token'>)</span>
  <span class='min identifier id'>min</span> <span class='assign token'>=</span> <span class='DB constant id'>DB</span><span class='lbrack token'>[</span><span class='symbol val'>:history</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='min identifier id'>min</span><span class='lparen token'>(</span><span class='symbol val'>:value</span><span class='rparen token'>)</span>
</pre>
<p>
Or calculate a sum or average:
</p>
<pre class="code">
  <span class='sum identifier id'>sum</span> <span class='assign token'>=</span> <span class='DB constant id'>DB</span><span class='lbrack token'>[</span><span class='symbol val'>:items</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='sum identifier id'>sum</span><span class='lparen token'>(</span><span class='symbol val'>:price</span><span class='rparen token'>)</span>
  <span class='avg identifier id'>avg</span> <span class='assign token'>=</span> <span class='DB constant id'>DB</span><span class='lbrack token'>[</span><span class='symbol val'>:items</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='avg identifier id'>avg</span><span class='lparen token'>(</span><span class='symbol val'>:price</span><span class='rparen token'>)</span>
</pre>
<h3>Ordering Records</h3>
<p>
Ordering datasets is simple:
</p>
<pre class="code">
  <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='order identifier id'>order</span><span class='lparen token'>(</span><span class='symbol val'>:stamp</span><span class='rparen token'>)</span> <span class='comment val'># ORDER BY stamp</span>
  <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='order identifier id'>order</span><span class='lparen token'>(</span><span class='symbol val'>:stamp</span><span class='comma token'>,</span> <span class='symbol val'>:name</span><span class='rparen token'>)</span> <span class='comment val'># ORDER BY stamp, name</span>
</pre>
<p>
Chaining order doesn&#8217;t work the same as filter:
</p>
<pre class="code">
  <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='order identifier id'>order</span><span class='lparen token'>(</span><span class='symbol val'>:stamp</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='order identifier id'>order</span><span class='lparen token'>(</span><span class='symbol val'>:name</span><span class='rparen token'>)</span> <span class='comment val'># ORDER BY name</span>
</pre>
<p>
The order_more method chains this way, though:
</p>
<pre class="code">
  <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='order identifier id'>order</span><span class='lparen token'>(</span><span class='symbol val'>:stamp</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='order_more identifier id'>order_more</span><span class='lparen token'>(</span><span class='symbol val'>:name</span><span class='rparen token'>)</span> <span class='comment val'># ORDER BY stamp, name</span>
</pre>
<p>
You can also specify descending order:
</p>
<pre class="code">
  <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='order identifier id'>order</span><span class='lparen token'>(</span><span class='symbol val'>:stamp</span><span class='dot token'>.</span><span class='desc identifier id'>desc</span><span class='rparen token'>)</span> <span class='comment val'># ORDER BY stamp DESC</span>
</pre>
<h3>Selecting Columns</h3>
<p>
Selecting specific columns to be returned is also simple:
</p>
<pre class="code">
  <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='select identifier id'>select</span><span class='lparen token'>(</span><span class='symbol val'>:stamp</span><span class='rparen token'>)</span> <span class='comment val'># SELECT stamp FROM posts</span>
  <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='select identifier id'>select</span><span class='lparen token'>(</span><span class='symbol val'>:stamp</span><span class='comma token'>,</span> <span class='symbol val'>:name</span><span class='rparen token'>)</span> <span class='comment val'># SELECT stamp, name FROM posts</span>
</pre>
<p>
Chaining select works like order, not filter:
</p>
<pre class="code">
  <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='select identifier id'>select</span><span class='lparen token'>(</span><span class='symbol val'>:stamp</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='select identifier id'>select</span><span class='lparen token'>(</span><span class='symbol val'>:name</span><span class='rparen token'>)</span> <span class='comment val'># SELECT name FROM posts</span>
</pre>
<p>
As you might expect, there is an order_more equivalent for select:
</p>
<pre class="code">
  <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='select identifier id'>select</span><span class='lparen token'>(</span><span class='symbol val'>:stamp</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='select_more identifier id'>select_more</span><span class='lparen token'>(</span><span class='symbol val'>:name</span><span class='rparen token'>)</span> <span class='comment val'># SELECT stamp, name FROM posts</span>
</pre>
<h3>Deleting Records</h3>
<p>
Deleting records from the table is done with delete:
</p>
<pre class="code">
  <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lparen token'>(</span><span class='string val'>'stamp &lt; ?'</span><span class='comma token'>,</span> <span class='Date constant id'>Date</span><span class='dot token'>.</span><span class='today identifier id'>today</span> <span class='minus op'>-</span> <span class='integer val'>3</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='delete identifier id'>delete</span>
</pre>
<p>
Be very careful when deleting, as delete affects all rows in the dataset.
Filter first, delete second, unless you want to empty the table.
</p>
<h3>Inserting Records</h3>
<p>
Inserting records into the table is done with insert:
</p>
<pre class="code">
  <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='insert identifier id'>insert</span><span class='lparen token'>(</span><span class='symbol val'>:category</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'ruby'</span><span class='comma token'>,</span> <span class='symbol val'>:author</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'david'</span><span class='rparen token'>)</span>
</pre>
<h3>Updating Records</h3>
<p>
Updating records in the table is done with update:
</p>
<pre class="code">
  <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lparen token'>(</span><span class='string val'>'stamp &lt; ?'</span><span class='comma token'>,</span> <span class='Date constant id'>Date</span><span class='dot token'>.</span><span class='today identifier id'>today</span> <span class='minus op'>-</span> <span class='integer val'>7</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='update identifier id'>update</span><span class='lparen token'>(</span><span class='symbol val'>:state</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'archived'</span><span class='rparen token'>)</span>
</pre>
<p>
You can reference table columns when choosing what values to set:
</p>
<pre class="code">
  <span class='posts identifier id'>posts</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='o identifier id'>o</span><span class='bitor op'>|</span> <span class='o identifier id'>o</span><span class='dot token'>.</span><span class='stamp identifier id'>stamp</span> <span class='lt op'>&lt;</span> <span class='Date constant id'>Date</span><span class='dot token'>.</span><span class='today identifier id'>today</span> <span class='minus op'>-</span> <span class='integer val'>7</span><span class='rbrace token'>}</span><span class='dot token'>.</span><span class='update identifier id'>update</span><span class='lparen token'>(</span><span class='symbol val'>:backup_number</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='symbol val'>:backup_number</span> <span class='plus op'>+</span> <span class='integer val'>1</span><span class='rparen token'>)</span>
</pre>
<p>
As with delete, this affects all rows in the dataset, so filter first,
update second, unless you want to update all rows.
</p>
<h3>Joining Tables</h3>
<p>
Sequel makes it easy to join tables:
</p>
<pre class="code">
  <span class='order_items identifier id'>order_items</span> <span class='assign token'>=</span> <span class='DB constant id'>DB</span><span class='lbrack token'>[</span><span class='symbol val'>:items</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='join identifier id'>join</span><span class='lparen token'>(</span><span class='symbol val'>:order_items</span><span class='comma token'>,</span> <span class='symbol val'>:item_id</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='symbol val'>:id</span><span class='rparen token'>)</span><span class='dot token'>.</span>
    <span class='filter identifier id'>filter</span><span class='lparen token'>(</span><span class='symbol val'>:order_items__order_id</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='integer val'>1234</span><span class='rparen token'>)</span>
</pre>
<p>
This is equivalent to the SQL:
</p>
<pre class="code">
  <span class='SELECT constant id'>SELECT</span> <span class='mult op'>*</span> <span class='FROM constant id'>FROM</span> <span class='items identifier id'>items</span> <span class='INNER constant id'>INNER</span> <span class='JOIN constant id'>JOIN</span> <span class='order_items identifier id'>order_items</span>
  <span class='ON constant id'>ON</span> <span class='order_items identifier id'>order_items</span><span class='dot token'>.</span><span class='item_id identifier id'>item_id</span> <span class='assign token'>=</span> <span class='items identifier id'>items</span><span class='dot token'>.</span><span class='id identifier id'>id</span>
  <span class='WHERE constant id'>WHERE</span> <span class='order_items identifier id'>order_items</span><span class='dot token'>.</span><span class='order_id identifier id'>order_id</span> <span class='assign token'>=</span> <span class='integer val'>1234</span>
</pre>
<p>
You can then do anything you like with the dataset:
</p>
<pre class="code">
  <span class='order_total identifier id'>order_total</span> <span class='assign token'>=</span> <span class='order_items identifier id'>order_items</span><span class='dot token'>.</span><span class='sum identifier id'>sum</span><span class='lparen token'>(</span><span class='symbol val'>:price</span><span class='rparen token'>)</span>
</pre>
<p>
Which is equivalent to the SQL:
</p>
<pre class="code">
  <span class='SELECT constant id'>SELECT</span> <span class='sum identifier id'>sum</span><span class='lparen token'>(</span><span class='price identifier id'>price</span><span class='rparen token'>)</span> <span class='FROM constant id'>FROM</span> <span class='items identifier id'>items</span> <span class='INNER constant id'>INNER</span> <span class='JOIN constant id'>JOIN</span> <span class='order_items identifier id'>order_items</span>
  <span class='ON constant id'>ON</span> <span class='order_items identifier id'>order_items</span><span class='dot token'>.</span><span class='item_id identifier id'>item_id</span> <span class='assign token'>=</span> <span class='items identifier id'>items</span><span class='dot token'>.</span><span class='id identifier id'>id</span>
  <span class='WHERE constant id'>WHERE</span> <span class='order_items identifier id'>order_items</span><span class='dot token'>.</span><span class='order_id identifier id'>order_id</span> <span class='assign token'>=</span> <span class='integer val'>1234</span>
</pre>
<h3>Graphing Datasets</h3>
<p>
When retrieving records from joined datasets, you get the results in a
single hash, which is subject to clobbering if you have columns with the
same name in multiple tables:
</p>
<pre class="code">
  <span class='DB constant id'>DB</span><span class='lbrack token'>[</span><span class='symbol val'>:items</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='join identifier id'>join</span><span class='lparen token'>(</span><span class='symbol val'>:order_items</span><span class='comma token'>,</span> <span class='symbol val'>:item_id</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='symbol val'>:id</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='first identifier id'>first</span>
  <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='lt op'>&lt;</span><span class='tt identifier id'>tt</span><span class='gt op'>&gt;</span><span class='symbol val'>:item_id=</span><span class='bitand op'>&amp;</span><span class='gt identifier id'>gt</span><span class='semicolon token'>;</span><span class='order_items identifier id'>order_items</span><span class='dot token'>.</span><span class='item_id identifier id'>item_id</span><span class='lt op'>&lt;</span><span class='regexp val'>/tt&gt;
</span></pre>
<p>
Using graph, you can split the result hashes into subhashes, one per join:
</p>
<pre class="code">
  <span class='DB constant id'>DB</span><span class='lbrack token'>[</span><span class='symbol val'>:items</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='graph identifier id'>graph</span><span class='lparen token'>(</span><span class='symbol val'>:order_items</span><span class='comma token'>,</span> <span class='symbol val'>:item_id</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='symbol val'>:id</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='first identifier id'>first</span>
  <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='lt op'>&lt;</span><span class='tt identifier id'>tt</span><span class='gt op'>&gt;</span><span class='symbol val'>:items=</span><span class='bitand op'>&amp;</span><span class='gt identifier id'>gt</span><span class='semicolon token'>;</span><span class='lbrace token'>{</span><span class='symbol val'>:id=</span><span class='bitand op'>&amp;</span><span class='gt identifier id'>gt</span><span class='semicolon token'>;</span><span class='items identifier id'>items</span><span class='dot token'>.</span><span class='id identifier id'>id</span><span class='lt op'>&lt;</span><span class='regexp val'>/tt&gt;, :order_items=&gt;{:id=&gt;order_items.id, :item_id=&gt;order_items.item_id}}
</span></pre>
<h2>An aside: column references in Sequel</h2>
<p>
Sequel expects column names to be specified using symbols. In addition,
returned hashes always use symbols as their keys. This allows you to freely
mix literal values and column references. For example, the two following
lines produce equivalent SQL:
</p>
<pre class="code">
  <span class='items identifier id'>items</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lparen token'>(</span><span class='symbol val'>:x</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='integer val'>1</span><span class='rparen token'>)</span> <span class='comment val'>#=&gt; &quot;SELECT * FROM items WHERE (x = 1)&quot;</span>
  <span class='items identifier id'>items</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lparen token'>(</span><span class='integer val'>1</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='symbol val'>:x</span><span class='rparen token'>)</span> <span class='comment val'>#=&gt; &quot;SELECT * FROM items WHERE (1 = x)&quot;</span>
</pre>
<p>
Ruby strings are generally treated as SQL strings:
</p>
<pre class="code">
  <span class='items identifier id'>items</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lparen token'>(</span><span class='symbol val'>:x</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'x'</span><span class='rparen token'>)</span> <span class='comment val'>#=&gt; &quot;SELECT * FROM items WHERE (x = 'x')&quot;</span>
</pre>
<h3>Qualifying column names</h3>
<p>
Column references can be qualified by using the double underscore special
notation :table__column:
</p>
<pre class="code">
  <span class='items identifier id'>items</span><span class='dot token'>.</span><span class='literal identifier id'>literal</span><span class='lparen token'>(</span><span class='symbol val'>:items__price</span><span class='rparen token'>)</span> <span class='comment val'>#=&gt; &quot;items.price&quot;</span>
</pre>
<h3>Column aliases</h3>
<p>
You can also alias columns by using the triple undersecore special notation
:column___alias or :table__column___alias:
</p>
<pre class="code">
  <span class='items identifier id'>items</span><span class='dot token'>.</span><span class='literal identifier id'>literal</span><span class='lparen token'>(</span><span class='symbol val'>:price___p</span><span class='rparen token'>)</span> <span class='comment val'>#=&gt; &quot;price AS p&quot;</span>
  <span class='items identifier id'>items</span><span class='dot token'>.</span><span class='literal identifier id'>literal</span><span class='lparen token'>(</span><span class='symbol val'>:items__price___p</span><span class='rparen token'>)</span> <span class='comment val'>#=&gt; &quot;items.price AS p&quot;</span>
</pre>
<p>
Another way to alias columns is to use the #as method:
</p>
<pre class="code">
  <span class='items identifier id'>items</span><span class='dot token'>.</span><span class='literal identifier id'>literal</span><span class='lparen token'>(</span><span class='symbol val'>:price</span><span class='dot token'>.</span><span class='as identifier id'>as</span><span class='lparen token'>(</span><span class='symbol val'>:p</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='comment val'>#=&gt; &quot;price AS p&quot;</span>
</pre>
<h2>Sequel Models</h2>
<p>
A model class wraps a dataset, and an instance of that class wraps a single
record in the dataset.
</p>
<p>
Model classes are defined as regular Ruby classes:
</p>
<pre class="code">
  <span class='DB constant id'>DB</span> <span class='assign token'>=</span> <span class='Sequel constant id'>Sequel</span><span class='dot token'>.</span><span class='connect identifier id'>connect</span><span class='lparen token'>(</span><span class='string val'>'sqlite://blog.db'</span><span class='rparen token'>)</span>
  <span class='class class kw'>class</span> <span class='Post constant id'>Post</span> <span class='lt op'>&lt;</span> <span class='Sequel constant id'>Sequel</span><span class='colon2 op'>::</span><span class='Model constant id'>Model</span>
  <span class='end end kw'>end</span>
</pre>
<p>
Just like in DataMapper or ActiveRecord, Sequel model classes assume that
the table name is a plural of the class name:
</p>
<pre class="code">
  <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='table_name identifier id'>table_name</span> <span class='comment val'>#=&gt; :posts</span>
</pre>
<p>
You can, however, explicitly set the table name or even the dataset used:
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='Post constant id'>Post</span> <span class='lt op'>&lt;</span> <span class='Sequel constant id'>Sequel</span><span class='colon2 op'>::</span><span class='Model constant id'>Model</span><span class='lparen token'>(</span><span class='symbol val'>:my_posts</span><span class='rparen token'>)</span>
  <span class='end end kw'>end</span>
  <span class='comment val'># or:</span>
  <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='set_dataset identifier id'>set_dataset</span> <span class='symbol val'>:my_posts</span>
</pre>
<p>
If you use a symbol, it assumes you are referring to the table with the
same name. You can also give it a dataset:
</p>
<pre class="code">
  <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='set_dataset identifier id'>set_dataset</span> <span class='DB constant id'>DB</span><span class='lbrack token'>[</span><span class='symbol val'>:my_posts</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lparen token'>(</span><span class='symbol val'>:category</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'ruby'</span><span class='rparen token'>)</span>
  <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='set_dataset identifier id'>set_dataset</span> <span class='DB constant id'>DB</span><span class='lbrack token'>[</span><span class='symbol val'>:my_posts</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='select identifier id'>select</span><span class='lparen token'>(</span><span class='symbol val'>:id</span><span class='comma token'>,</span> <span class='symbol val'>:name</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='order identifier id'>order</span><span class='lparen token'>(</span><span class='symbol val'>:date</span><span class='rparen token'>)</span>
</pre>
<h3>Model instances</h3>
<p>
Model instance are identified by a primary key. By default, Sequel assumes
the primary key column to be :id, unless it can get the primary key
information from the database. The Model.[] method can be used to fetch
records by their primary key:
</p>
<pre class="code">
  <span class='post identifier id'>post</span> <span class='assign token'>=</span> <span class='Post constant id'>Post</span><span class='lbrack token'>[</span><span class='integer val'>123</span><span class='rbrack token'>]</span>
</pre>
<p>
The Model#pk method is used to retrieve the record&#8217;s primary key
value:
</p>
<pre class="code">
  <span class='post identifier id'>post</span><span class='dot token'>.</span><span class='pk identifier id'>pk</span> <span class='comment val'>#=&gt; 123</span>
</pre>
<p>
Sequel models allow you to use any column as a primary key, and even
composite keys made from multiple columns:
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='Post constant id'>Post</span> <span class='lt op'>&lt;</span> <span class='Sequel constant id'>Sequel</span><span class='colon2 op'>::</span><span class='Model constant id'>Model</span>
    <span class='set_primary_key identifier id'>set_primary_key</span> <span class='lbrack token'>[</span><span class='symbol val'>:category</span><span class='comma token'>,</span> <span class='symbol val'>:title</span><span class='rbrack token'>]</span>
  <span class='end end kw'>end</span>

  <span class='post identifier id'>post</span> <span class='assign token'>=</span> <span class='Post constant id'>Post</span><span class='lbrack token'>[</span><span class='string val'>'ruby'</span><span class='comma token'>,</span> <span class='string val'>'hello world'</span><span class='rbrack token'>]</span>
  <span class='post identifier id'>post</span><span class='dot token'>.</span><span class='pk identifier id'>pk</span> <span class='comment val'>#=&gt; ['ruby', 'hello world']</span>
</pre>
<p>
You can also define a model class that does not have a primary key, but
then you lose the ability to update records.
</p>
<p>
A model instance can also be fetched by specifying a condition:
</p>
<pre class="code">
  <span class='post identifier id'>post</span> <span class='assign token'>=</span> <span class='Post constant id'>Post</span><span class='lbrack token'>[</span><span class='symbol val'>:title</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'hello world'</span><span class='rbrack token'>]</span>
  <span class='post identifier id'>post</span> <span class='assign token'>=</span> <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='find identifier id'>find</span><span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='o identifier id'>o</span><span class='bitor op'>|</span> <span class='o identifier id'>o</span><span class='dot token'>.</span><span class='num_comments identifier id'>num_comments</span> <span class='lt op'>&lt;</span> <span class='integer val'>10</span><span class='rbrace token'>}</span>
</pre>
<h3>Iterating over records</h3>
<p>
A model class lets you iterate over subsets of records by proxying many
methods to the underlying dataset. This means that you can use most of the
Dataset API to create customized queries that return model instances, e.g.:
</p>
<pre class="code">
  <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lparen token'>(</span><span class='symbol val'>:category</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'ruby'</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='each identifier id'>each</span><span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='post identifier id'>post</span><span class='bitor op'>|</span> <span class='p identifier id'>p</span> <span class='post identifier id'>post</span><span class='rbrace token'>}</span>
</pre>
<p>
You can also manipulate the records in the dataset:
</p>
<pre class="code">
  <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='o identifier id'>o</span><span class='bitor op'>|</span> <span class='o identifier id'>o</span><span class='dot token'>.</span><span class='num_comments identifier id'>num_comments</span> <span class='lt op'>&lt;</span> <span class='integer val'>7</span><span class='rbrace token'>}</span><span class='dot token'>.</span><span class='delete identifier id'>delete</span>
  <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lparen token'>(</span><span class='symbol val'>:title</span><span class='dot token'>.</span><span class='like identifier id'>like</span><span class='lparen token'>(</span><span class='regexp val'>/ruby/</span><span class='rparen token'>)</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='update identifier id'>update</span><span class='lparen token'>(</span><span class='symbol val'>:category</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'ruby'</span><span class='rparen token'>)</span>
</pre>
<h3>Accessing record values</h3>
<p>
A model instances stores its values as a hash:
</p>
<pre class="code">
  <span class='post identifier id'>post</span><span class='dot token'>.</span><span class='values identifier id'>values</span> <span class='comment val'>#=&gt; &lt;tt&gt;=&amp;gt; 123, :category =&amp;gt; 'ruby', :title =&amp;gt; 'hello world'&lt;/tt&gt;</span>
</pre>
<p>
You can read the record values as object attributes (assuming the attribute
names are valid columns in the model&#8217;s dataset):
</p>
<pre class="code">
  <span class='post identifier id'>post</span><span class='dot token'>.</span><span class='id identifier id'>id</span> <span class='comment val'>#=&gt; 123</span>
  <span class='post identifier id'>post</span><span class='dot token'>.</span><span class='title identifier id'>title</span> <span class='comment val'>#=&gt; 'hello world'</span>
</pre>
<p>
You can also change record values:
</p>
<pre class="code">
  <span class='post identifier id'>post</span><span class='dot token'>.</span><span class='title identifier id'>title</span> <span class='assign token'>=</span> <span class='string val'>'hey there'</span>
  <span class='post identifier id'>post</span><span class='dot token'>.</span><span class='save identifier id'>save</span>
</pre>
<p>
Another way to change values by using the #update method:
</p>
<pre class="code">
  <span class='post identifier id'>post</span><span class='dot token'>.</span><span class='update identifier id'>update</span><span class='lparen token'>(</span><span class='symbol val'>:title</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'hey there'</span><span class='rparen token'>)</span>
</pre>
<h3>Creating new records</h3>
<p>
New records can be created by calling Model.create:
</p>
<pre class="code">
  <span class='post identifier id'>post</span> <span class='assign token'>=</span> <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='create identifier id'>create</span><span class='lparen token'>(</span><span class='symbol val'>:title</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'hello world'</span><span class='rparen token'>)</span>
</pre>
<p>
Another way is to construct a new instance and save it:
</p>
<pre class="code">
  <span class='post identifier id'>post</span> <span class='assign token'>=</span> <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
  <span class='post identifier id'>post</span><span class='dot token'>.</span><span class='title identifier id'>title</span> <span class='assign token'>=</span> <span class='string val'>'hello world'</span>
  <span class='post identifier id'>post</span><span class='dot token'>.</span><span class='save identifier id'>save</span>
</pre>
<p>
You can also supply a block to Model.new and Model.create:
</p>
<pre class="code">
  <span class='post identifier id'>post</span> <span class='assign token'>=</span> <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='create identifier id'>create</span><span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='p identifier id'>p</span><span class='bitor op'>|</span> <span class='p identifier id'>p</span><span class='dot token'>.</span><span class='title identifier id'>title</span> <span class='assign token'>=</span> <span class='string val'>'hello world'</span><span class='rbrace token'>}</span>

  <span class='post identifier id'>post</span> <span class='assign token'>=</span> <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='new identifier id'>new</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='p identifier id'>p</span><span class='bitor op'>|</span>
    <span class='p identifier id'>p</span><span class='dot token'>.</span><span class='title identifier id'>title</span> <span class='assign token'>=</span> <span class='string val'>'hello world'</span>
    <span class='p identifier id'>p</span><span class='dot token'>.</span><span class='save identifier id'>save</span>
  <span class='end end kw'>end</span>
</pre>
<h3>Hooks</h3>
<p>
You can execute custom code when creating, updating, or deleting records by
defining hook methods. The before_create and after_create hook methods wrap
record creation. The before_update and after_update hook methods wrap
record updating. The before_save and after_save hook methods wrap record
creation and updating. The before_destroy and after_destroy hook methods
wrap destruction. The before_validation and after_validation hook methods
wrap validation. Example:
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='Post constant id'>Post</span> <span class='lt op'>&lt;</span> <span class='Sequel constant id'>Sequel</span><span class='colon2 op'>::</span><span class='Model constant id'>Model</span>
    <span class='def def kw'>def</span> <span class='after_create identifier id'>after_create</span>
      <span class='author identifier id'>author</span><span class='dot token'>.</span><span class='increase_post_count identifier id'>increase_post_count</span>
    <span class='end end kw'>end</span>

    <span class='def def kw'>def</span> <span class='after_destroy identifier id'>after_destroy</span>
      <span class='author identifier id'>author</span><span class='dot token'>.</span><span class='decrease_post_count identifier id'>decrease_post_count</span>
    <span class='end end kw'>end</span>
  <span class='end end kw'>end</span>
</pre>
<p>
For the example above, you should probably use a database trigger if you
can. Hooks can be used for data integrity, but they will only enforce that
integrity when you are using the model. If you plan on allowing any other
access to the database, it&#8217;s best to use database triggers for data
integrity.
</p>
<h3>Deleting records</h3>
<p>
You can delete individual records by calling #delete or #destroy. The only
difference between the two methods is that #destroy invokes before_destroy
and after_destroy hook methods, while #delete does not:
</p>
<pre class="code">
  <span class='post identifier id'>post</span><span class='dot token'>.</span><span class='delete identifier id'>delete</span> <span class='comment val'>#=&gt; bypasses hooks</span>
  <span class='post identifier id'>post</span><span class='dot token'>.</span><span class='destroy identifier id'>destroy</span> <span class='comment val'>#=&gt; runs hooks</span>
</pre>
<p>
Records can also be deleted en-masse by invoking Model.delete and
Model.destroy. As stated above, you can specify filters for the deleted
records:
</p>
<pre class="code">
  <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lparen token'>(</span><span class='symbol val'>:category</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='integer val'>32</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='delete identifier id'>delete</span> <span class='comment val'>#=&gt; bypasses hooks</span>
  <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lparen token'>(</span><span class='symbol val'>:category</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='integer val'>32</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='destroy identifier id'>destroy</span> <span class='comment val'>#=&gt; runs hooks</span>
</pre>
<p>
Please note that if Model.destroy is called, each record is deleted
separately, but Model.delete deletes all relevant records with a single SQL
statement.
</p>
<h3>Associations</h3>
<p>
Associations are used in order to specify relationships between model
classes that reflect relations between tables in the database using foreign
keys.
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='Post constant id'>Post</span> <span class='lt op'>&lt;</span> <span class='Sequel constant id'>Sequel</span><span class='colon2 op'>::</span><span class='Model constant id'>Model</span>
    <span class='many_to_one identifier id'>many_to_one</span> <span class='symbol val'>:author</span>
    <span class='one_to_many identifier id'>one_to_many</span> <span class='symbol val'>:comments</span>
    <span class='many_to_many identifier id'>many_to_many</span> <span class='symbol val'>:tags</span>
  <span class='end end kw'>end</span>
</pre>
<p>
many_to_one creates a getter and setter for each model object:
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='Post constant id'>Post</span> <span class='lt op'>&lt;</span> <span class='Sequel constant id'>Sequel</span><span class='colon2 op'>::</span><span class='Model constant id'>Model</span>
    <span class='many_to_one identifier id'>many_to_one</span> <span class='symbol val'>:author</span>
  <span class='end end kw'>end</span>

  <span class='post identifier id'>post</span> <span class='assign token'>=</span> <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='create identifier id'>create</span><span class='lparen token'>(</span><span class='symbol val'>:name</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'hi!'</span><span class='rparen token'>)</span>
  <span class='post identifier id'>post</span><span class='dot token'>.</span><span class='author identifier id'>author</span> <span class='assign token'>=</span> <span class='Author constant id'>Author</span><span class='lbrack token'>[</span><span class='symbol val'>:name</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'Sharon'</span><span class='rbrack token'>]</span>
  <span class='post identifier id'>post</span><span class='dot token'>.</span><span class='author identifier id'>author</span>
</pre>
<p>
one_to_many and many_to_many create a getter method, a method for adding an
object to the association, a method for removing an object from the
association, and a method for removing all associated objected from the
association:
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='Post constant id'>Post</span> <span class='lt op'>&lt;</span> <span class='Sequel constant id'>Sequel</span><span class='colon2 op'>::</span><span class='Model constant id'>Model</span>
    <span class='one_to_many identifier id'>one_to_many</span> <span class='symbol val'>:comments</span>
    <span class='many_to_many identifier id'>many_to_many</span> <span class='symbol val'>:tags</span>
  <span class='end end kw'>end</span>

  <span class='post identifier id'>post</span> <span class='assign token'>=</span> <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='create identifier id'>create</span><span class='lparen token'>(</span><span class='symbol val'>:name</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'hi!'</span><span class='rparen token'>)</span>
  <span class='post identifier id'>post</span><span class='dot token'>.</span><span class='comments identifier id'>comments</span>
  <span class='comment identifier id'>comment</span> <span class='assign token'>=</span> <span class='Comment constant id'>Comment</span><span class='dot token'>.</span><span class='create identifier id'>create</span><span class='lparen token'>(</span><span class='symbol val'>:text=</span><span class='gt op'>&gt;</span><span class='string val'>'hi'</span><span class='rparen token'>)</span>
  <span class='post identifier id'>post</span><span class='dot token'>.</span><span class='add_comment identifier id'>add_comment</span><span class='lparen token'>(</span><span class='comment identifier id'>comment</span><span class='rparen token'>)</span>
  <span class='post identifier id'>post</span><span class='dot token'>.</span><span class='remove_comment identifier id'>remove_comment</span><span class='lparen token'>(</span><span class='comment identifier id'>comment</span><span class='rparen token'>)</span>
  <span class='post identifier id'>post</span><span class='dot token'>.</span><span class='remove_all_comments identifier id'>remove_all_comments</span>
  <span class='tag identifier id'>tag</span> <span class='assign token'>=</span> <span class='Tag constant id'>Tag</span><span class='dot token'>.</span><span class='create identifier id'>create</span><span class='lparen token'>(</span><span class='symbol val'>:tag=</span><span class='gt op'>&gt;</span><span class='string val'>'interesting'</span><span class='rparen token'>)</span>
  <span class='post identifier id'>post</span><span class='dot token'>.</span><span class='add_tag identifier id'>add_tag</span><span class='lparen token'>(</span><span class='tag identifier id'>tag</span><span class='rparen token'>)</span>
  <span class='post identifier id'>post</span><span class='dot token'>.</span><span class='remove_tag identifier id'>remove_tag</span><span class='lparen token'>(</span><span class='tag identifier id'>tag</span><span class='rparen token'>)</span>
  <span class='post identifier id'>post</span><span class='dot token'>.</span><span class='remove_all_tags identifier id'>remove_all_tags</span>
</pre>
<p>
All associations add a dataset method that can be used to further filter or
reorder the returned objects, or modify all of them:
</p>
<pre class="code">
  <span class='comment val'># Delete all of this post's comments from the database</span>
  <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='comments_dataset identifier id'>comments_dataset</span><span class='dot token'>.</span><span class='destroy identifier id'>destroy</span>

  <span class='comment val'># Return all tags related to this post with no subscribers, ordered by the tag's name</span>
  <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='tags_dataset identifier id'>tags_dataset</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lparen token'>(</span><span class='symbol val'>:subscribers=</span><span class='gt op'>&gt;</span><span class='integer val'>0</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='order identifier id'>order</span><span class='lparen token'>(</span><span class='symbol val'>:name</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='all identifier id'>all</span>
</pre>
<h3>Eager Loading</h3>
<p>
Associations can be eagerly loaded via .eager and the :eager association
option. Eager loading is used when loading a group of objects. It loads all
associated objects for all of the current objects in one query, instead of
using a separate query to get the associated objects for each current
object. Eager loading requires that you retrieve all model objects at once
via .all (instead of individually by .each). Eager loading can be cascaded,
loading association&#8217;s associated objects.
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='Person constant id'>Person</span> <span class='lt op'>&lt;</span> <span class='Sequel constant id'>Sequel</span><span class='colon2 op'>::</span><span class='Model constant id'>Model</span>
    <span class='one_to_many identifier id'>one_to_many</span> <span class='symbol val'>:posts</span><span class='comma token'>,</span> <span class='symbol val'>:eager=</span><span class='gt op'>&gt;</span><span class='lbrack token'>[</span><span class='symbol val'>:tags</span><span class='rbrack token'>]</span>
  <span class='end end kw'>end</span>

  <span class='class class kw'>class</span> <span class='Post constant id'>Post</span> <span class='lt op'>&lt;</span> <span class='Sequel constant id'>Sequel</span><span class='colon2 op'>::</span><span class='Model constant id'>Model</span>
    <span class='many_to_one identifier id'>many_to_one</span> <span class='symbol val'>:person</span>
    <span class='one_to_many identifier id'>one_to_many</span> <span class='symbol val'>:replies</span>
    <span class='many_to_many identifier id'>many_to_many</span> <span class='symbol val'>:tags</span>
  <span class='end end kw'>end</span>

  <span class='class class kw'>class</span> <span class='Tag constant id'>Tag</span> <span class='lt op'>&lt;</span> <span class='Sequel constant id'>Sequel</span><span class='colon2 op'>::</span><span class='Model constant id'>Model</span>
    <span class='many_to_many identifier id'>many_to_many</span> <span class='symbol val'>:posts</span>
    <span class='many_to_many identifier id'>many_to_many</span> <span class='symbol val'>:replies</span>
  <span class='end end kw'>end</span>

  <span class='class class kw'>class</span> <span class='Reply constant id'>Reply</span> <span class='lt op'>&lt;</span> <span class='Sequel constant id'>Sequel</span><span class='colon2 op'>::</span><span class='Model constant id'>Model</span>
    <span class='many_to_one identifier id'>many_to_one</span> <span class='symbol val'>:person</span>
    <span class='many_to_one identifier id'>many_to_one</span> <span class='symbol val'>:post</span>
    <span class='many_to_many identifier id'>many_to_many</span> <span class='symbol val'>:tags</span>
  <span class='end end kw'>end</span>

  <span class='comment val'># Eager loading via .eager</span>
  <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='eager identifier id'>eager</span><span class='lparen token'>(</span><span class='symbol val'>:person</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='all identifier id'>all</span>

  <span class='comment val'># eager is a dataset method, so it works with filters/orders/limits/etc.</span>
  <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='o identifier id'>o</span><span class='bitor op'>|</span> <span class='o identifier id'>o</span><span class='dot token'>.</span><span class='topic identifier id'>topic</span> <span class='gt op'>&gt;</span> <span class='string val'>'M'</span><span class='rbrace token'>}</span><span class='dot token'>.</span><span class='order identifier id'>order</span><span class='lparen token'>(</span><span class='symbol val'>:date</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='limit identifier id'>limit</span><span class='lparen token'>(</span><span class='integer val'>5</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='eager identifier id'>eager</span><span class='lparen token'>(</span><span class='symbol val'>:person</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='all identifier id'>all</span>

  <span class='person identifier id'>person</span> <span class='assign token'>=</span> <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='first identifier id'>first</span>
  <span class='comment val'># Eager loading via :eager (will eagerly load the tags for this person's posts)</span>
  <span class='person identifier id'>person</span><span class='dot token'>.</span><span class='posts identifier id'>posts</span>

  <span class='comment val'># These are equivalent</span>
  <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='eager identifier id'>eager</span><span class='lparen token'>(</span><span class='symbol val'>:person</span><span class='comma token'>,</span> <span class='symbol val'>:tags</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='all identifier id'>all</span>
  <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='eager identifier id'>eager</span><span class='lparen token'>(</span><span class='symbol val'>:person</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='eager identifier id'>eager</span><span class='lparen token'>(</span><span class='symbol val'>:tags</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='all identifier id'>all</span>

  <span class='comment val'># Cascading via .eager</span>
  <span class='Tag constant id'>Tag</span><span class='dot token'>.</span><span class='eager identifier id'>eager</span><span class='lparen token'>(</span><span class='symbol val'>:posts=</span><span class='gt op'>&gt;</span><span class='symbol val'>:replies</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='all identifier id'>all</span>

  <span class='comment val'># Will also grab all associated posts' tags (because of :eager)</span>
  <span class='Reply constant id'>Reply</span><span class='dot token'>.</span><span class='eager identifier id'>eager</span><span class='lparen token'>(</span><span class='symbol val'>:person=</span><span class='gt op'>&gt;</span><span class='symbol val'>:posts</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='all identifier id'>all</span>

  <span class='comment val'># No depth limit (other than memory/stack), and will also grab posts' tags</span>
  <span class='comment val'># Loads all people, their posts, their posts' tags, replies to those posts,</span>
  <span class='comment val'># the person for each reply, the tag for each reply, and all posts and</span>
  <span class='comment val'># replies that have that tag.  Uses a total of 8 queries.</span>
  <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='eager identifier id'>eager</span><span class='lparen token'>(</span><span class='symbol val'>:posts=</span><span class='gt op'>&gt;</span><span class='lbrace token'>{</span><span class='symbol val'>:replies=</span><span class='gt op'>&gt;</span><span class='lbrack token'>[</span><span class='symbol val'>:person</span><span class='comma token'>,</span> <span class='lt op'>&lt;</span><span class='tt identifier id'>tt</span><span class='gt op'>&gt;</span><span class='symbol val'>:replies</span><span class='lt op'>&lt;</span><span class='regexp val'>/tt&gt;}]}).all
</span></pre>
<p>
In addition to using eager, you can also use eager_graph, which will use a
single query to get the object and all associated objects. This may be
necessary if you want to filter or order the result set based on columns in
associated tables. It works with cascading as well, the syntax is exactly
the same. Note that using eager_graph to eagerly load multiple *_to_many
associations will cause the result set to be a cartesian product, so you
should be very careful with your filters when using it in that case.
</p>
<h3>Extending the underlying dataset</h3>
<p>
The obvious way to add table-wide logic is to define class methods to the
model class definition. That way you can define subsets of the underlying
dataset, change the ordering, or perform actions on multiple records:
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='Post constant id'>Post</span> <span class='lt op'>&lt;</span> <span class='Sequel constant id'>Sequel</span><span class='colon2 op'>::</span><span class='Model constant id'>Model</span>
    <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='posts_with_few_comments identifier id'>posts_with_few_comments</span>
      <span class='filter identifier id'>filter</span><span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='o identifier id'>o</span><span class='bitor op'>|</span> <span class='o identifier id'>o</span><span class='dot token'>.</span><span class='num_comments identifier id'>num_comments</span> <span class='lt op'>&lt;</span> <span class='integer val'>30</span><span class='rbrace token'>}</span>
    <span class='end end kw'>end</span>

    <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='clean_posts_with_few_comments identifier id'>clean_posts_with_few_comments</span>
      <span class='posts_with_few_comments identifier id'>posts_with_few_comments</span><span class='dot token'>.</span><span class='delete identifier id'>delete</span>
    <span class='end end kw'>end</span>
  <span class='end end kw'>end</span>
</pre>
<p>
You can also implement table-wide logic by defining methods on the dataset:
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='Post constant id'>Post</span> <span class='lt op'>&lt;</span> <span class='Sequel constant id'>Sequel</span><span class='colon2 op'>::</span><span class='Model constant id'>Model</span>
    <span class='def_dataset_method identifier id'>def_dataset_method</span><span class='lparen token'>(</span><span class='symbol val'>:posts_with_few_comments</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
      <span class='filter identifier id'>filter</span><span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='o identifier id'>o</span><span class='bitor op'>|</span> <span class='o identifier id'>o</span><span class='dot token'>.</span><span class='num_comments identifier id'>num_comments</span> <span class='lt op'>&lt;</span> <span class='integer val'>30</span><span class='rbrace token'>}</span>
    <span class='end end kw'>end</span>

    <span class='def_dataset_method identifier id'>def_dataset_method</span><span class='lparen token'>(</span><span class='symbol val'>:clean_posts_with_few_comments</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
      <span class='posts_with_few_comments identifier id'>posts_with_few_comments</span><span class='dot token'>.</span><span class='delete identifier id'>delete</span>
    <span class='end end kw'>end</span>
  <span class='end end kw'>end</span>
</pre>
<p>
This is the recommended way of implementing table-wide operations, and
allows you to have access to your model API from filtered datasets as well:
</p>
<pre class="code">
  <span class='Post constant id'>Post</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span><span class='lparen token'>(</span><span class='symbol val'>:category</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'ruby'</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='clean_posts_with_few_comments identifier id'>clean_posts_with_few_comments</span>
</pre>
<p>
Sequel models also provide a short hand notation for filters:
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='Post constant id'>Post</span> <span class='lt op'>&lt;</span> <span class='Sequel constant id'>Sequel</span><span class='colon2 op'>::</span><span class='Model constant id'>Model</span>
    <span class='subset identifier id'>subset</span><span class='lparen token'>(</span><span class='symbol val'>:posts_with_few_comments</span><span class='rparen token'>)</span><span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='o identifier id'>o</span><span class='bitor op'>|</span> <span class='o identifier id'>o</span><span class='dot token'>.</span><span class='num_comments identifier id'>num_comments</span> <span class='lt op'>&lt;</span> <span class='integer val'>30</span><span class='rbrace token'>}</span>
    <span class='subset identifier id'>subset</span> <span class='symbol val'>:invisible</span><span class='comma token'>,</span> <span class='bitnot op'>~</span><span class='symbol val'>:visible</span>
  <span class='end end kw'>end</span>
</pre>
<h3>Model Validations</h3>
<p>
You can define a validate method for your model, which save will check
before attempting to save the model in the database. If an attribute of the
model isn&#8217;t valid, you should add a error message for that attribute
to the model object&#8217;s errors. If an object has any errors added by
the validate method, save will raise an error or return false depending on
how it is configured.
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='Post constant id'>Post</span> <span class='lt op'>&lt;</span> <span class='Sequel constant id'>Sequel</span><span class='colon2 op'>::</span><span class='Model constant id'>Model</span>
    <span class='def def kw'>def</span> <span class='validate identifier id'>validate</span>
      <span class='errors identifier id'>errors</span><span class='lbrack token'>[</span><span class='symbol val'>:name</span><span class='rbrack token'>]</span> <span class='lshft op'>&lt;&lt;</span> <span class='string val'>&quot;can't be empty&quot;</span> <span class='if if_mod kw'>if</span> <span class='name identifier id'>name</span><span class='dot token'>.</span><span class='empty? fid id'>empty?</span>
      <span class='errors identifier id'>errors</span><span class='lbrack token'>[</span><span class='symbol val'>:written_on</span><span class='rbrack token'>]</span> <span class='lshft op'>&lt;&lt;</span> <span class='string val'>&quot;should be in the past&quot;</span> <span class='if if_mod kw'>if</span> <span class='written_on identifier id'>written_on</span> <span class='geq op'>&gt;=</span> <span class='Time constant id'>Time</span><span class='dot token'>.</span><span class='now identifier id'>now</span>
    <span class='end end kw'>end</span>
  <span class='end end kw'>end</span>
</pre>

</div>
          </div>
        </div>
      </div>                    
    </div>

    <div id="footer">
      <div class="site">
        <div class="info">
          <div class="links">
            <a href="http://github.com/blog/148-github-shirts-now-available">Shirts</a> |
            <a href="http://github.com/blog">Blog</a> |
            <a href="http://support.github.com/">Support</a> |
            <a href="http://github.com/training">Training</a> |
            <a href="http://github.com/contact">Contact</a> |
            <a href="http://groups.google.com/group/github/">Google Group</a> |
            <a href="http://develop.github.com/">API</a> |
            <a href="http://twitter.com/github">Status</a>
          </div>
          <div class="company">
            <span id="_rrt" title="0.64509s from xc88-s00039">GitHub</span>
            is <a href="http://logicalawesome.com/">Logical Awesome</a> ©2009 | <a href="http://github.com/site/terms">Terms of Service</a> | <a href="http://github.com/site/privacy">Privacy Policy</a>
          </div>
        </div>
        <div class="sponsor">
          <a href="http://engineyard.com/"><img src="http://github.com/images/modules/footer/engine_yard_logo.png" alt="Engine Yard"></a>
          <div>
            Hosting provided by our<br> partners at Engine Yard
          </div>
        </div>
      </div>
    </div>
    
    <div id="coming_soon" style="display: none;">
      This feature is coming soon.  Sit tight!
    </div>

    <div id="facebox" style="display: none;">       
      <div class="popup">         
        <table>           
          <tbody>             
            <tr>               
              <td class="tl"></td>
              <td class="b"></td>
              <td class="tr"></td>             
            </tr>             
          <tr>               
            <td class="b"></td>               
            <td class="body">                 
              <div class="content"></div>                 
              <div class="footer">                   
                <a href="#" class="close"><img src="http://github.com/facebox/closelabel.gif" title="close" class="close_image"></a>                 
              </div>               
            </td>               
            <td class="b"></td>             
          </tr>             
          <tr>               
            <td class="bl"></td>
            <td class="b"></td>
            <td class="br"></td>             
          </tr>           
        </tbody>         
      </table>       
    </div>     


    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
    var pageTracker = _gat._getTracker("UA-8689483-1");
    pageTracker._trackPageview();
    } catch(err) {}</script>

  </body>
</html>