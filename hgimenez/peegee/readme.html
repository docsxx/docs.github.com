<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="style.css" type="text/css" charset="utf-8" />
<link rel="stylesheet" href="syntax_highlight.css" type="text/css" charset="utf-8" />

    <title>README</title>
  </head>
  <body>
    <div id="content">
      <div class="section docstring readme">
        <p>
h1. What?
</p>
<p>
Peegee (pronounced &quot;Pee - Gee&quot;, as in the letters PG, for
Postgres) is a utility that provides an abstraction for performing
PostgreSQL related tasks from Ruby, or your Rails application.
</p>
<p>
h1. Why?
</p>
<p>
This project started with the need to improve the performance of
PostgreSQL&#8217;s CLUSTER command. While clustering your database tables
improves query performance significantly, the actual process of clustering
takes unacceptable amounts of time. For instance, it may take roughly 20
hours on a moderately big set of tables (around 60GB). Your milage may
vary, of course. Refactoring the clustering functionality surfaced a clean
set of utilities that resulted in the creation of this gem. Some are
useful, and some are just pointless.
</p>
<p>
h1. Installation
</p>
<p>
&lt;pre&gt;<tt>gem sources -a http://gems.github.com #if you haven&#8217;t
already sudo gem install hgimenez-peegee</tt>&lt;/pre&gt;
</p>
<p>
h1. Example usage
</p>
<p>
Assuming we&#8217;re in a Rails app, you can simply do:
</p>
<p>
&lt;pre&gt;<tt>people_table = Peegee::Table.new(:table_name =&gt;
&#8216;people&#8217;) people_table.ddl # a string containing this
table&#8217;s DDL people_table.indexes people_table.foreign_keys
people_table.dependent_foreign_keys</tt>&lt;/pre&gt; The three commands
above return arrays of Peegee::Index and Peegee::ForeignKey objects, which
all respond to drop and create. For example, you could drop and recreate
the first dependent foreign key (some other table referencing people) with:
&lt;pre&gt;<tt>people_table.dependent_foreign_keys.first.drop
people_table.dependent_foreign_keys.first.create</tt>&lt;/pre&gt; After the
call to drop, the @dependent_foreign_keys instance variable on the
people_table object remains cached, and calling create will simply execute
the cached SQL required to recreate the database object.
</p>
<p>
The strategy used for clustering a table is to store all dependencies in
order to restore them later (as viewed above), and move all of the
table&#8217;s data on the order given by a certain index. This is all
executed in a database transaction in case it blows up. The result should
be just like the pgsql native CLUSTER command:
&lt;pre&gt;<tt>people_table.cluster(&#8216;people_pk&#8217;) #must specify
an index by which to cluster</tt>&lt;/pre&gt;
</p>
<p>
h1. Todo
</p>
<p>
The first order of business will be to create specs where applicable.
</p>
<p>
Then, the idea is to keep adding functionality that may be useful for DBAs
or application developers and other PostgreSQL users. Some that come to
mind are:
</p>
<ul>
<li>Ability to clean out all of table&#8217;s index and foreign key names,
following a given pattern. On occasions, table names are altered leaving
behind pesky legacy names for related objects.

</li>
<li>Ability to identify database stinks. For instance:

</li>
</ul>
<p>
** tables without primary keys, or indexes (which are not pure join tables)
** foreign keys without indexes (useful for manually identifying and fixing
if applicable), ** report on columns that look like foreign keys, but
aren&#8217;t (based on rails conventions). ** columns that are nullable,
and are flagged as unique ** tables with incrementing columns names,
indiciating a possible denormalization ** columns with a default value of
&#8216;NULL&#8217; (the varchar), where NULL may have been intended. (much
of these are stolen from the excellent
&quot;SchemaSpy&quot;:http://schemaspy.sourceforge.net/)
</p>
<p>
There&#8217;s also a bunch of #TODO tags in the code, where there&#8217;s
clearly room for improvement.
</p>
<p>
I would also like to make this code ORM agnostic. Right now, it depends on
ActiveRecord to retrieve a connection and execute commands.
</p>
<p>
Please fork away and help improve it.
</p>
<p>
h1. Revision History
</p>
<ul>
<li>Version 0.1.1 (April 13th, 2009):

</li>
</ul>
<p>
** Set up RSpec testing environment. Started creating test suite. ** Added
the Configuration singleton class, which for now allows the user to specify
which indexes to cluster each table by. ** Added exists? class method to
Peegee::Table class. Creating a Peegee::Table instance now fails if the
table does not exist in the database. ** Added bang (!) methods to
Peegee::Table class, which force the lookup of foreign_keys!, constraints!,
indexes!, etc, even when they&#8217;re already cached. ** Fixed bug in
cluster method.
</p>
<ul>
<li>Version 0.1.0 (April 10th, 2009):

</li>
</ul>
<p>
** First release.
</p>
<p>
h1. License
</p>
<p>
Copyright &#169; 2009 Harold A. Gimenez, released under the MIT license.
</p>

      </div>
    </div>
  </body>
</html>