<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <title>andreasronge's neo4j - GitHub Documentation</title>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="description" content="">

<link rel="search" type="application/opensearchdescription+xml" href="http://github.com/opensearch.xml" title="GitHub">
<link rel="fluid-icon" href="http://github.com/fluidicon.png" title="GitHub">
<link href="http://assets0.github.com/stylesheets/bundle.css" media="screen" rel="stylesheet" type="text/css">
<link href="http://github.com/feeds/andreasronge/commits/neo4j/master" rel="alternate" title="Recent Commits to neo4j:master" type="application/atom+xml">

<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js"></script>
<script type="text/javascript" src="http://assets3.github.com/javascripts/bundle.js"></script>              
<script src="app.js" type="text/javascript" charset="utf-8"></script>

<script type="text/javascript" src="http://docs.github.com/javascripts/md5.js"></script>
<script type="text/javascript" src="http://docs.github.com/javascripts/repos.js"></script>
<script type="text/javascript" src="http://docs.github.com/javascripts/commits.js"></script>
<script type="text/javascript">
  $(document).ready(function(){
    if (typeof skipHeaders != 'undefined') return;
    
    GitHubRepo.init("andreasronge", "neo4j", function(){ 
      GitHubRepo.links = " <a id='namespaces_button' rel='andreasronge/neo4j/blob/469d0b093c69ea542c0a63a499b5395b7d8544d6' href='#'><img class='button' src='http://docs.github.com/namespaces_button.png' alt='Modules and Classes'/></a> ";
      GitHubRepo.links += " <a id='methods_button' rel='andreasronge/neo4j/blob/469d0b093c69ea542c0a63a499b5395b7d8544d6' href='#'><img class='button' src='http://docs.github.com/methods_button.png' alt='Methods'/></a> ";
      $("#repo").html(GitHubRepo.content());
      $('#namespaces_button').click(function(){
        var url="/"+$(this).attr('rel')+"/namespaces/";
        $.gitbox(url);
        return false;
      });    
      $('#methods_button').click(function(){
        var url="/"+$(this).attr('rel')+"/methods/";
        $.gitbox(url);
        return false;
      });        
    });
    GitHubCommit.init("andreasronge", "neo4j", "469d0b093c69ea542c0a63a499b5395b7d8544d6", function(){ 
      $("#commit").html(GitHubCommit.content());
    });
  });
</script>

    <link rel="stylesheet" href="style.css" type="text/css" charset="utf-8" />
  </head>
  <body>    
    
    
        <div id="main" style="padding-bottom:8em;">
      <div id="header">
        <div class="site">
          <div class="logo">
            <a href="http://github.com/"><img src="http://github.com/images/modules/header/logov3.png" alt="github"></a>
          </div>          
          <div class="topsearch">
            <form action="http://github.com/search" id="top_search_form" method="get">
              <input class="search" name="q" type="search"> <input value="Search" type="submit">
            </form>
            <div class="links">
              <a href="http://github.com/repositories">Browse</a> | <a href="http://github.com/guides">Guides</a> | <a href="http://github.com/search">Advanced</a>
            </div>
          </div>
          <div class="actions">
            <a href="http://github.com">Home</a>
            <a href="http://github.com/plans"><b><u>Pricing and Signup</u></b></a>
            <a href="http://docs.github.com/">Documentation</a>
            <a href="https://github.com/login">Login</a>
          </div>                  
        </div>
      </div>    
                                                  
      <div id="repo_menu">
        <div class="site">
          <ul>          
            <li class=""><a href="http://github.com/andreasronge/neo4j/tree/">Source</a></li>
            <li class=""><a href="http://github.com/andreasronge/neo4j/commits/">Commits</a></li>            
            <li class=""><a href="http://github.com/andreasronge/neo4j/network">Network</a></li>            
            <li class=""><a href="http://github.com/andreasronge/neo4j/issues">Issues</a></li>
            <li class=""><a href="http://wiki.github.com/andreasronge/neo4j">Wiki</a></li>
            <li class=""><a href="http://github.com/andreasronge/neo4j/graphs">Graphs</a></li>                    
            <li class="active"><a href="/andreasronge/neo4j">Documentation</a></li>
          </ul>
        </div>
      </div>

      <div id="repo_sub_menu">
        <div class="site">
          <div class="joiner"></div>      
        </div>
      </div>

      <div class="site">  
        <div id="repos">
          <div id="repo" class="repo public">
            <div class="title">
              <div class="path">
                <a href="http://github.com/andreasronge">andreasronge</a> / <b><a href="http://github.com/andreasronge/neo4j/tree">neo4j</a></b>        
                <a id="namespaces_button" rel="andreasronge/neo4j/blob/469d0b093c69ea542c0a63a499b5395b7d8544d6" href="#"><img class="button" src="http://docs.github.com/namespaces_button.png" alt="Modules and Classes"/></a>
                <a id="methods_button" rel="andreasronge/neo4j/blob/469d0b093c69ea542c0a63a499b5395b7d8544d6" href="#"><img class="button" src="http://docs.github.com/methods_button.png" alt="Methods"/></a>
              </div>
            </div>            
          </div>
          <div id="commit">
          </div> 
          <br/>                                       
          <div id="content">
            <div class="section docstring readme wikistyle">
  <h1>Neo4j.rb</h1>
<p>
Neo4j.rb is a graph database for JRuby.
</p>
<p>
It provides:
</p>
<ul>
<li>Mapping of ruby objects to nodes in networks rather than in tables.

</li>
<li>Dynamic, and schema-free - no need to declare
nodes/properties/relationships in advance.

</li>
<li>Storage of ruby object to a file system.

</li>
<li>Fast traversal of relationships between nodes in a huge node space.

</li>
<li>Transaction with rollbacks support.

</li>
<li>Indexing and querying of ruby objects.

</li>
<li>Can be used instead of ActiveRecord in Ruby on Rails or Merb

</li>
<li>Can be accessible as REST resources.

</li>
</ul>
<p>
It uses two powerful and mature java libraries:
</p>
<ul>
<li>Neo4J (http://www.neo4j.org/) - for persistance and traversal of the graph

</li>
<li>Lucene (http://lucene.apache.org/java/docs/index.html) for quering and
indexing.

</li>
</ul>
<h3>Status</h3>
<ul>
<li>There are over 300 RSpecs.

</li>
<li>Has been tested with a simple rails application, used Neo4j.rb instead of
ActiveRecord

</li>
<li>Has been load tested (loaded 18000 nodes and done queries/traversal in
several threads.)

</li>
<li>Has not been used in production yet (as far as I know).

</li>
</ul>
<h3>Project information</h3>
<ul>
<li>GitHub - http://github.com/andreasronge/neo4j/tree/master

</li>
<li>Issue Tracking - http://neo4j.lighthouseapp.com

</li>
<li>Twitter - http://twitter.com/ronge

</li>
<li>API Documentation - http://neo4j.rubyforge.org/ (of the released version)

</li>
<li>Source repo - git://github.com/andreasronge/neo4j.git

</li>
<li>Mailing list - https://lists.neo4j.org/mailman/listinfo/user

</li>
</ul>
<h3>Presentation Materials and other URLs</h3>
<ul>
<li>Ruby Manor 2008 - Jonathan Conway:
http://jaikoo.com/assets/presentations/neo4j.pdf

</li>
<li>Neo4j wiki - http://wiki.neo4j.org/content/Main_Page (check the guidelines
and domain modeling gallery pages)

</li>
</ul>
<h3>Contributing</h3>
<p>
Have you found a bug, need help or have a patch ? Just clone neo4j.rb and
send me a pull request or email me. Do you need help - send me an email
(andreas.ronge at gmail dot com). Please also check/add issues at
lighthouse, http://neo4j.lighthouseapp.com
</p>
<h3>License</h3>
<ul>
<li>Neo4j.rb - MIT, see the LICENSE file
http://github.com/andreasronge/neo4j/tree/master/LICENSE.

</li>
<li>Lucene - Apache, see http://lucene.apache.org/java/docs/features.html

</li>
<li>Neo4j - Dual free software/commercial license, see http://neo4j.org/

</li>
</ul>
<h3>Content</h3>
<p>
This page contains the following information:
</p>
<ul>
<li>Installation guide

</li>
<li>Three Minute Tutorial

</li>
<li>Ten Minute Tutorial

</li>
<li>Lucene API Documentation

</li>
<li>Neo4j API Documentation

</li>
<li>Extensions: REST (see Neo4j::RestMixin)

</li>
<li>Ruby on Rails with Neo4j.rb

</li>
</ul>
<h2>Installation</h2>
<p>
To install it:
</p>
<pre class="code">
   <span class='gem identifier id'>gem</span> <span class='install identifier id'>install</span> <span class='neo4j identifier id'>neo4j</span>
</pre>
<p>
To install from the latest source:
</p>
<pre class="code">
  <span class='git identifier id'>git</span> <span class='clone identifier id'>clone</span> <span class='git identifier id'>git</span><span class='symbol val'>:/</span><span class='regexp val'>/github.com/</span><span class='andreasronge identifier id'>andreasronge</span><span class='div op'>/</span><span class='neo4j identifier id'>neo4j</span><span class='dot token'>.</span><span class='git identifier id'>git</span>
  <span class='cd identifier id'>cd</span> <span class='neo4j identifier id'>neo4j</span>
  <span class='rake identifier id'>rake</span> <span class='gem identifier id'>gem</span><span class='symbol val'>:install</span>
</pre>
<p>
This has been verified to work on JRuby 1.3.0
</p>
<h4>Running all RSpecs</h4>
<p>
To check that neo4j.rb is working:
</p>
<pre class="code">
  <span class='cd identifier id'>cd</span> <span class='neo4j identifier id'>neo4j</span> <span class='comment val'># the folder containing the Rakefile</span>
  <span class='rake identifier id'>rake</span>     <span class='comment val'># you may have to type jruby -S rake depending how you installed JRuby</span>
</pre>
<h2>Three Minute Tutorial</h2>
<p>
Neo node space consists of three basic elements: nodes, relationships that
connect nodes and properties attached to both nodes and relationships. All
relationships have a type, for example if the node space represents a
social network, a relationship type could be KNOWS. If a relationship of
the type KNOWS connects two nodes, that probably represents two people that
know each other. A lot of the semantics, the meaning, of a node space is
encoded in the relationship types of the application.
</p>
<h3>Creating Nodes</h3>
<p>
Example of creating a neo4j node:
</p>
<pre class="code">
  <span class='require identifier id'>require</span> <span class='string val'>&quot;rubygems&quot;</span>
  <span class='require identifier id'>require</span> <span class='string val'>'neo4j'</span>

  <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='Transaction constant id'>Transaction</span><span class='dot token'>.</span><span class='run identifier id'>run</span> <span class='do do kw'>do</span>
    <span class='node identifier id'>node</span> <span class='assign token'>=</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='Node constant id'>Node</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
  <span class='end end kw'>end</span>
</pre>
<h3>Transactions</h3>
<p>
Almost all Neo4j operation must be wrapped in a transaction as shown above.
In the following examples we assume that the operations are inside an Neo4j
transaction. Neo4j.rb supports auto commits without wrapping Neo4j
operations in Neo4j::Transactions. To enable that require the file
&#8216;neo4j/auto_tx&#8217; instead of &#8216;neo4j&#8217;
</p>
<p>
Example
</p>
<pre class="code">
  <span class='require identifier id'>require</span> <span class='string val'>'neo4j/auto_tx'</span>

  <span class='comment val'># no need to wrap operations in Neo4j::Transaction.run do .. end</span>
  <span class='Node constant id'>Node</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
</pre>
<p>
This feature should be used for testing and development purpose.
</p>
<h3>Setting Properties</h3>
<p>
Example of setting properties
</p>
<pre class="code">
  <span class='node identifier id'>node</span> <span class='assign token'>=</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='Node constant id'>Node</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
  <span class='node identifier id'>node</span><span class='lbrack token'>[</span><span class='symbol val'>:name</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='string val'>'foo'</span>
  <span class='node identifier id'>node</span><span class='lbrack token'>[</span><span class='symbol val'>:age</span><span class='rbrack token'>]</span>  <span class='assign token'>=</span> <span class='integer val'>123</span>
  <span class='node identifier id'>node</span><span class='lbrack token'>[</span><span class='symbol val'>:hungry</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='false false kw'>false</span>
  <span class='node identifier id'>node</span><span class='lbrack token'>[</span><span class='integer val'>4</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='float val'>3.14</span>
</pre>
<h3>Getting Properties</h3>
<p>
Example of getting properties
</p>
<pre class="code">
  <span class='node identifier id'>node</span><span class='lbrack token'>[</span><span class='symbol val'>:name</span><span class='rbrack token'>]</span> <span class='comment val'># =&gt; 'foo'</span>
</pre>
<h3>Creating Relationships</h3>
<p>
Example of creating a relationship
</p>
<pre class="code">
  <span class='node1 identifier id'>node1</span> <span class='assign token'>=</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='Node constant id'>Node</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
  <span class='node2 identifier id'>node2</span> <span class='assign token'>=</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='Node constant id'>Node</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
  <span class='node1 identifier id'>node1</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='dot token'>.</span><span class='outgoing identifier id'>outgoing</span><span class='lparen token'>(</span><span class='symbol val'>:friends</span><span class='rparen token'>)</span> <span class='lshft op'>&lt;&lt;</span> <span class='node2 identifier id'>node2</span>  <span class='comment val'># connects node1 to node2 with relationship type 'friends'</span>
</pre>
<h3>Accessing Relationships</h3>
<p>
Example of getting relationships
</p>
<pre class="code">
  <span class='node1 identifier id'>node1</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='dot token'>.</span><span class='empty? fid id'>empty?</span> <span class='comment val'># =&gt; false</span>

  <span class='comment val'># The relationships method returns an enumeration of relationship objects.</span>
  <span class='comment val'># The nodes method on the relationships returns the nodes instead.</span>
  <span class='node1 identifier id'>node1</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='dot token'>.</span><span class='nodes identifier id'>nodes</span><span class='dot token'>.</span><span class='include? fid id'>include?</span><span class='lparen token'>(</span><span class='node2 identifier id'>node2</span><span class='rparen token'>)</span> <span class='comment val'># =&gt; true</span>

  <span class='node1 identifier id'>node1</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='dot token'>.</span><span class='first identifier id'>first</span> <span class='comment val'># =&gt; the first relationship this node1 has which is between node1 and node2 of any type</span>
  <span class='node1 identifier id'>node1</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='dot token'>.</span><span class='nodes identifier id'>nodes</span><span class='dot token'>.</span><span class='first identifier id'>first</span> <span class='comment val'># =&gt; node2  first node of any relationship type</span>
  <span class='node1 identifier id'>node1</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='dot token'>.</span><span class='incoming identifier id'>incoming</span><span class='lparen token'>(</span><span class='symbol val'>:friends</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='nodes identifier id'>nodes</span><span class='dot token'>.</span><span class='first identifier id'>first</span> <span class='comment val'># =&gt; node1  first node of relationship type 'friends'</span>
  <span class='node2 identifier id'>node2</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='dot token'>.</span><span class='incoming identifier id'>incoming</span><span class='lparen token'>(</span><span class='symbol val'>:friends</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='first identifier id'>first</span> <span class='comment val'># =&gt; a relationship object between node1 and node2</span>
</pre>
<h3>Properties on Relationships</h3>
<p>
Example of setting properties on relationships
</p>
<pre class="code">
  <span class='rel identifier id'>rel</span> <span class='assign token'>=</span> <span class='node1 identifier id'>node1</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='lparen token'>(</span><span class='symbol val'>:friends</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='first identifier id'>first</span>
  <span class='rel identifier id'>rel</span><span class='lbrack token'>[</span><span class='symbol val'>:since</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='integer val'>1982</span>
  <span class='node1 identifier id'>node1</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='dot token'>.</span><span class='first identifier id'>first</span><span class='lbrack token'>[</span><span class='symbol val'>:since</span><span class='rbrack token'>]</span> <span class='comment val'># =&gt; 1982 (there is only one relationship defined on node1 in this example)</span>
</pre>
<h3>The Node and NodeMixin</h3>
<p>
Here is the complete implemenation of the Neo4j::Node class
</p>
<pre class="code">
  <span class='module module kw'>module</span> <span class='Neo4j constant id'>Neo4j</span>
    <span class='class class kw'>class</span> <span class='Node constant id'>Node</span>
      <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='NodeMixin constant id'>NodeMixin</span>
    <span class='end end kw'>end</span>
  <span class='end end kw'>end</span>
</pre>
<p>
In the next tutorial you will learn how to use this Neo4j::NodeMixin in
your own domain model classes.
</p>
<h2>Ten Minute Tutorial</h2>
<h3>Creating a Model</h3>
<p>
The following example specifies how to map a Neo4j node to a Ruby Person
instance.
</p>
<pre class="code">
  <span class='require identifier id'>require</span> <span class='string val'>&quot;rubygems&quot;</span>
  <span class='require identifier id'>require</span> <span class='string val'>&quot;neo4j&quot;</span>

  <span class='class class kw'>class</span> <span class='Person constant id'>Person</span>
    <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='NodeMixin constant id'>NodeMixin</span>

    <span class='comment val'># define Neo4j properties</span>
    <span class='property identifier id'>property</span> <span class='symbol val'>:name</span><span class='comma token'>,</span> <span class='symbol val'>:salary</span><span class='dot token'>.</span>

    <span class='comment val'># define an one way relationship to any other node</span>
    <span class='has_n identifier id'>has_n</span> <span class='symbol val'>:friends</span>

    <span class='comment val'># adds a lucene index on the following properties</span>
    <span class='index identifier id'>index</span> <span class='symbol val'>:name</span><span class='comma token'>,</span> <span class='symbol val'>:salary</span>
    <span class='index identifier id'>index</span> <span class='string val'>'friends.age'</span> <span class='comment val'># index each friend age as well</span>
  <span class='end end kw'>end</span>
</pre>
<p>
Neo properties and relationships are declared using the
&#8216;property&#8217; and &#8216;has_n&#8217;/&#8217;has_one&#8217;
NodeMixin class method. Adding new types of properties and relationships
can also be done without declaring those propertie/relationships by using
the operator &#8217;[]&#8217; on Neo4j::NodeMixin and the
</p>
<pre class="code">
 <span class='string val'>'&lt;&lt;'</span> <span class='on identifier id'>on</span> <span class='the identifier id'>the</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='Relationships constant id'>Relationships</span><span class='colon2 op'>::</span><span class='RelationshipTraverser constant id'>RelationshipTraverser</span><span class='dot token'>.</span>
</pre>
<p>
By using the NodeMixin all instances of the Person class can now be stored
in the Neo4j node space and be retrieved/queried by traversing the node
space or performing Lucene queries.
</p>
<p>
A lucene index will be updated when the name or salary property changes.
The salary of all friends are also indexed which means we can query for
people who has friends with a certain salary.
</p>
<h3>Creating a node</h3>
<p>
Creating a Person node instance
</p>
<pre class="code">
  <span class='person identifier id'>person</span> <span class='assign token'>=</span> <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
</pre>
<h3>Setting properties</h3>
<p>
Setting a property:
</p>
<pre class="code">
  <span class='person identifier id'>person</span><span class='dot token'>.</span><span class='name identifier id'>name</span> <span class='assign token'>=</span> <span class='string val'>'kalle'</span>
  <span class='person identifier id'>person</span><span class='dot token'>.</span><span class='salary identifier id'>salary</span>  <span class='assign token'>=</span> <span class='integer val'>10000</span>
</pre>
<p>
If a transaction is not specified then the operation will automatically be
wrapped in a transaction.
</p>
<h3>Dynamic Properties</h3>
<p>
Notice that it is not required to specify which attributes should be
available on a node. Any attributes can be set using the [] operator.
</p>
<p>
Example:
</p>
<pre class="code">
  <span class='person identifier id'>person</span><span class='lbrack token'>[</span><span class='string val'>'a_not_defined_property'</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='string val'>'hello'</span>
</pre>
<h3>Dynamic Relationships</h3>
<p>
Like dynamic properties, relationships does not have to be defined using
has_n or has_one for a class. A relationship can be added at any time on
any node.
</p>
<p>
Example:
</p>
<pre class="code">
  <span class='person identifier id'>person</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='dot token'>.</span><span class='outgoing identifier id'>outgoing</span><span class='lparen token'>(</span><span class='symbol val'>:best_friends</span><span class='rparen token'>)</span> <span class='lshft op'>&lt;&lt;</span> <span class='other_node identifier id'>other_node</span>
  <span class='person identifier id'>person</span><span class='dot token'>.</span><span class='relationship identifier id'>relationship</span><span class='lparen token'>(</span><span class='symbol val'>:best_friend</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='end_node identifier id'>end_node</span> <span class='comment val'># =&gt; other_node (if there is only one relationship of type 'best_friend' on person)</span>
</pre>
<h3>Finding Nodes and Queries</h3>
<p>
There are three ways of finding/quering nodes in neo4j - by doing a
traversal or by using lucene queries or using the unique neo4j id
(Neo4j::NodeMixin#neo_node_id). When doing a traversal one start from a
node and travers one or more relationships (one or more levels deep). This
start node can be either the reference node which is always found
(Neo4j.ref_node) or by finding a start node from a lucene query.
</p>
<h3>Lucene Queries</h3>
<p>
There are different ways to write lucene queries. Using a hash:
</p>
<pre class="code">
  <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='find identifier id'>find</span> <span class='lparen token'>(</span><span class='symbol val'>:name</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'kalle'</span><span class='comma token'>,</span> <span class='symbol val'>:age</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='float val'>20</span><span class='dot2 op'>..</span><span class='integer val'>30</span><span class='rparen token'>)</span>  <span class='comment val'># find people with name kalle and age between 20 and 30</span>
</pre>
<p>
or using the lucene query language:
</p>
<pre class="code">
  <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='find identifier id'>find</span><span class='lparen token'>(</span><span class='string val'>&quot;name:kalle AND salary:[10000 TO 30000]&quot;</span><span class='rparen token'>)</span>
</pre>
<p>
The Lucene query language supports wildcard, grouping, boolean, fuzzy
queries, etc&#8230; For more information see:
http://lucene.apache.org/java/2_4_0/queryparsersyntax.html
</p>
<h3>Sorting, example</h3>
<pre class="code">
  <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='find identifier id'>find</span><span class='lparen token'>(</span><span class='symbol val'>:name</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'kalle'</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='sort_by identifier id'>sort_by</span><span class='lparen token'>(</span><span class='symbol val'>:salary</span><span class='rparen token'>)</span>
  <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='find identifier id'>find</span><span class='lparen token'>(</span><span class='symbol val'>:name</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'kalle'</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='sort_by identifier id'>sort_by</span><span class='lparen token'>(</span><span class='Desc constant id'>Desc</span><span class='lbrack token'>[</span><span class='symbol val'>:salary</span><span class='rbrack token'>]</span><span class='comma token'>,</span> <span class='Asc constant id'>Asc</span><span class='lbrack token'>[</span><span class='symbol val'>:country</span><span class='rbrack token'>]</span><span class='rparen token'>)</span>
  <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='find identifier id'>find</span><span class='lparen token'>(</span><span class='symbol val'>:name</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'kalle'</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='sort_by identifier id'>sort_by</span><span class='lparen token'>(</span><span class='Desc constant id'>Desc</span><span class='lbrack token'>[</span><span class='symbol val'>:salary</span><span class='comma token'>,</span> <span class='symbol val'>:country</span><span class='rbrack token'>]</span><span class='rparen token'>)</span>
</pre>
<h3>Search Results</h3>
<p>
The query is not performed until the search result is requested. Example of
using the search result.
</p>
<pre class="code">
  <span class='res identifier id'>res</span> <span class='assign token'>=</span> <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='find identifier id'>find</span><span class='lparen token'>(</span><span class='symbol val'>:name</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'kalle'</span><span class='rparen token'>)</span>
  <span class='res identifier id'>res</span><span class='dot token'>.</span><span class='size identifier id'>size</span>  <span class='comment val'># =&gt; 10</span>
  <span class='res identifier id'>res</span><span class='dot token'>.</span><span class='each identifier id'>each</span> <span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='x identifier id'>x</span><span class='bitor op'>|</span> <span class='puts identifier id'>puts</span> <span class='x identifier id'>x</span><span class='dot token'>.</span><span class='name identifier id'>name</span><span class='rbrace token'>}</span>
  <span class='res identifier id'>res</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='name identifier id'>name</span> <span class='assign token'>=</span> <span class='string val'>'sune'</span>
</pre>
<h3>Creating a Relationships</h3>
<p>
Adding a relationship between two nodes:
</p>
<pre class="code">
  <span class='person2 identifier id'>person2</span> <span class='assign token'>=</span> <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
  <span class='person identifier id'>person</span><span class='dot token'>.</span><span class='friends identifier id'>friends</span> <span class='lshft op'>&lt;&lt;</span> <span class='person2 identifier id'>person2</span>
</pre>
<p>
The person.friends returns an object that has a number of useful methods
(it also includes the Enumerable mixin). Example
</p>
<pre class="code">
  <span class='person identifier id'>person</span><span class='dot token'>.</span><span class='friends identifier id'>friends</span><span class='dot token'>.</span><span class='empty? fid id'>empty?</span> <span class='comment val'># =&gt; false</span>
  <span class='person identifier id'>person</span><span class='dot token'>.</span><span class='friends identifier id'>friends</span><span class='dot token'>.</span><span class='first identifier id'>first</span>  <span class='comment val'># =&gt; person2</span>
  <span class='person identifier id'>person</span><span class='dot token'>.</span><span class='friends identifier id'>friends</span><span class='dot token'>.</span><span class='include? fid id'>include?</span><span class='lparen token'>(</span><span class='person2 identifier id'>person2</span><span class='rparen token'>)</span> <span class='comment val'># =&gt; true</span>
</pre>
<h3>Deleting a Relationship</h3>
<p>
To delete the relationship between person and person2:
</p>
<pre class="code">
  <span class='person identifier id'>person</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='lbrack token'>[</span><span class='person2 identifier id'>person2</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='delete identifier id'>delete</span>
</pre>
<p>
If a node is deleted then all its relationship will also be deleted
Deleting a node is performed by using the delete method:
</p>
<pre class="code">
  <span class='person identifier id'>person</span><span class='dot token'>.</span><span class='delete identifier id'>delete</span>
</pre>
<h3>Node Traversals</h3>
<p>
The has_one and has_many methods create a convenient method for traversals
and managing relationships to other nodes. Example:
</p>
<pre class="code">
  <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='has_n identifier id'>has_n</span> <span class='symbol val'>:friends</span> <span class='comment val'># generates the friends instance method</span>
  <span class='comment val'># all instances of Person now has a friends method so that we can do the following</span>
  <span class='person identifier id'>person</span><span class='dot token'>.</span><span class='friends identifier id'>friends</span><span class='dot token'>.</span><span class='each identifier id'>each</span> <span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='n identifier id'>n</span><span class='bitor op'>|</span> <span class='dot3 op'>...</span>  <span class='rbrace token'>}</span>
</pre>
<p>
Traversing using a filter
</p>
<pre class="code">
  <span class='person identifier id'>person</span><span class='dot token'>.</span><span class='friends identifier id'>friends</span><span class='lbrace token'>{</span> <span class='salary identifier id'>salary</span> <span class='eq op'>==</span> <span class='integer val'>10000</span> <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='each identifier id'>each</span> <span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='n identifier id'>n</span><span class='bitor op'>|</span> <span class='dot3 op'>...</span><span class='rbrace token'>}</span>
</pre>
<p>
Traversing with a specific depth (depth 1 is default)
</p>
<pre class="code">
  <span class='person identifier id'>person</span><span class='dot token'>.</span><span class='friends identifier id'>friends</span><span class='lbrace token'>{</span> <span class='salary identifier id'>salary</span> <span class='eq op'>==</span> <span class='integer val'>10000</span><span class='rbrace token'>}</span><span class='dot token'>.</span><span class='depth identifier id'>depth</span><span class='lparen token'>(</span><span class='integer val'>3</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='each identifier id'>each</span> <span class='lbrace token'>{</span> <span class='dot3 op'>...</span> <span class='rbrace token'>}</span>
</pre>
<p>
There is also a more powerful method for traversing several relationships
at the same time - Neo4j::NodeMixin#traverse, see below.
</p>
<h3>Example on Relationships</h3>
<p>
In the first example the friends relationship can have relationships to any
other node of any class. In the next example we specify that the
&#8216;acted_in&#8217; relationship should use the Ruby classes Actor, Role
and Movie. This is done by using the has_n class method:
</p>
<pre class="code">
      <span class='class class kw'>class</span> <span class='Role constant id'>Role</span>
        <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='RelationshipMixin constant id'>RelationshipMixin</span>
        <span class='comment val'># notice that neo4j relationships can also have properties</span>
        <span class='property identifier id'>property</span> <span class='symbol val'>:name</span>
      <span class='end end kw'>end</span>

      <span class='class class kw'>class</span> <span class='Actor constant id'>Actor</span>
        <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='NodeMixin constant id'>NodeMixin</span>

        <span class='comment val'># The following line defines the acted_in relationship</span>
        <span class='comment val'># using the following classes:</span>
        <span class='comment val'># Actor[Node] --(Role[Relationship])--&gt; Movie[Node]</span>
        <span class='comment val'>#</span>
        <span class='has_n identifier id'>has_n</span><span class='lparen token'>(</span><span class='symbol val'>:acted_in</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='to identifier id'>to</span><span class='lparen token'>(</span><span class='Movie constant id'>Movie</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='relationship identifier id'>relationship</span><span class='lparen token'>(</span><span class='Role constant id'>Role</span><span class='rparen token'>)</span>
      <span class='end end kw'>end</span>

      <span class='class class kw'>class</span> <span class='Movie constant id'>Movie</span>
        <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='NodeMixin constant id'>NodeMixin</span>
        <span class='property identifier id'>property</span> <span class='symbol val'>:title</span>
        <span class='property identifier id'>property</span> <span class='symbol val'>:year</span>

        <span class='comment val'># defines a method for traversing incoming acted_in relationships from Actor</span>
        <span class='has_n identifier id'>has_n</span><span class='lparen token'>(</span><span class='symbol val'>:actors</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='from identifier id'>from</span><span class='lparen token'>(</span><span class='Actor constant id'>Actor</span><span class='comma token'>,</span> <span class='symbol val'>:acted_in</span><span class='rparen token'>)</span>
      <span class='end end kw'>end</span>
</pre>
<p>
Creating a new Actor-Role-Movie relationship can be done like this:
</p>
<pre class="code">
      <span class='keanu_reeves identifier id'>keanu_reeves</span> <span class='assign token'>=</span> <span class='Actor constant id'>Actor</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
      <span class='matrix identifier id'>matrix</span>       <span class='assign token'>=</span> <span class='Movie constant id'>Movie</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
      <span class='keanu_reeves identifier id'>keanu_reeves</span><span class='dot token'>.</span><span class='acted_in identifier id'>acted_in</span> <span class='lshft op'>&lt;&lt;</span> <span class='matrix identifier id'>matrix</span>
</pre>
<p>
or you can also specify this relationship on the incoming node (since we
provided that information in the has_n methods).
</p>
<pre class="code">
      <span class='keanu_reeves identifier id'>keanu_reeves</span> <span class='assign token'>=</span> <span class='Actor constant id'>Actor</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
      <span class='matrix identifier id'>matrix</span>       <span class='assign token'>=</span> <span class='Movie constant id'>Movie</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
      <span class='matrix identifier id'>matrix</span><span class='dot token'>.</span><span class='actors identifier id'>actors</span> <span class='lshft op'>&lt;&lt;</span> <span class='keanu_reeves identifier id'>keanu_reeves</span>
</pre>
<p>
Example of accessing the Role relationship object between an Actor and a
Movie
</p>
<pre class="code">
      <span class='keanu_reeves identifier id'>keanu_reeves</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='dot token'>.</span><span class='outgoing identifier id'>outgoing</span><span class='lparen token'>(</span><span class='symbol val'>:acted_in</span><span class='rparen token'>)</span><span class='lbrack token'>[</span><span class='matrix identifier id'>matrix</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='name identifier id'>name</span> <span class='assign token'>=</span> <span class='string val'>'neo'</span>
</pre>
<p>
More information about neo4j can be found after the Lucene section below.
</p>
<h2>The Lucene Module</h2>
<p>
You can use this module without using the Neo4j module.
</p>
<p>
Lucene provides:
</p>
<ul>
<li>Flexible Queries - Phrases, Wildcards, Compound boolean expressions
etc&#8230;

</li>
<li>Field-specific Queries eg. title, artist, album

</li>
<li>Sorting

</li>
<li>Ranked Searching

</li>
</ul>
<h3>Lucene Document</h3>
<p>
In lucene everything is a Document. A document can represent anything
textual: Word Document, DVD (the textual metadata only), or a Neo4j.rb
node. A document is like a record or row in a relationship database.
</p>
<p>
The following example shows how a document can be created by using the
&#8217;&#8217;&lt;&lt;&#8217;&#8217; operator on the Lucene::Index class
and found using the Lucene::Index#find method.
</p>
<p>
Example of how to write a document and find it:
</p>
<pre class="code">
    <span class='require identifier id'>require</span> <span class='string val'>'lucene'</span>

    <span class='include identifier id'>include</span> <span class='Lucene constant id'>Lucene</span>

    <span class='comment val'># the var/myindex parameter is either a path where to store the index or</span>
    <span class='comment val'># just a key if index is kept in memory (see below)</span>
    <span class='index identifier id'>index</span> <span class='assign token'>=</span> <span class='Index constant id'>Index</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='string val'>'var/myindex'</span><span class='rparen token'>)</span>

    <span class='comment val'># add one document (a document is like a record or row in a relationship database)</span>
    <span class='index identifier id'>index</span> <span class='lshft op'>&lt;&lt;</span> <span class='lbrace token'>{</span><span class='symbol val'>:id=</span><span class='gt op'>&gt;</span><span class='string val'>'1'</span><span class='comma token'>,</span> <span class='symbol val'>:name=</span><span class='gt op'>&gt;</span><span class='string val'>'foo'</span><span class='rbrace token'>}</span>

    <span class='comment val'># write to the index file</span>
    <span class='index identifier id'>index</span><span class='dot token'>.</span><span class='commit identifier id'>commit</span>

    <span class='comment val'># find a document with name foo</span>
    <span class='comment val'># hits is a ruby Enumeration of documents</span>
    <span class='hits identifier id'>hits</span> <span class='assign token'>=</span> <span class='index identifier id'>index</span><span class='dot token'>.</span><span class='find identifier id'>find</span><span class='lbrace token'>{</span><span class='name identifier id'>name</span> <span class='eq op'>==</span> <span class='string val'>'foo'</span><span class='rbrace token'>}</span>

    <span class='comment val'># show the id of the first document (document 0) found</span>
    <span class='comment val'># (the document contains all stored fields - see below)</span>
    <span class='hits identifier id'>hits</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span><span class='lbrack token'>[</span><span class='symbol val'>:id</span><span class='rbrack token'>]</span>   <span class='comment val'># =&gt; '1'</span>
</pre>
<p>
Notice that you have to call the commit method in order to update the index
on the disk/RAM. By performing several update and delete operations before
a commit will be much faster then performing commit after each operation.
</p>
<h3>Keep indexing on disk</h3>
<p>
By default Neo4j::Lucene keeps indexes in memory. That means that when the
application restarts the index will be gone and you have to reindex
everything again.
</p>
<p>
To keep indexes in memory:
</p>
<pre class="code">
   <span class='Lucene constant id'>Lucene</span><span class='colon2 op'>::</span><span class='Config constant id'>Config</span><span class='lbrack token'>[</span><span class='symbol val'>:store_on_file</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
   <span class='Lucene constant id'>Lucene</span><span class='colon2 op'>::</span><span class='Config constant id'>Config</span><span class='lbrack token'>[</span><span class='symbol val'>:storage_path</span><span class='rbrack token'>]</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'/home/neo/lucene-db'</span>
</pre>
<p>
When creating a new index the location of the index will be the
Lucene::Config[:storage_path] + index path Example:
</p>
<pre class="code">
   <span class='Lucene constant id'>Lucene</span><span class='colon2 op'>::</span><span class='Config constant id'>Config</span><span class='lbrack token'>[</span><span class='symbol val'>:store_on_file</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
   <span class='Lucene constant id'>Lucene</span><span class='colon2 op'>::</span><span class='Config constant id'>Config</span><span class='lbrack token'>[</span><span class='symbol val'>:storage_path</span><span class='rbrack token'>]</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'/home/neo/lucene-db'</span>
   <span class='index identifier id'>index</span> <span class='assign token'>=</span> <span class='Index constant id'>Index</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='string val'>'/foo/lucene'</span><span class='rparen token'>)</span>
</pre>
<p>
The example above will store the index at /home/neo/lucene-db/foo/lucene
</p>
<h3>Indexing several values with the same key</h3>
<p>
Let say a person can have several phone numbers. How do we index that ?
</p>
<pre class="code">
  <span class='index identifier id'>index</span> <span class='lshft op'>&lt;&lt;</span> <span class='lbrace token'>{</span><span class='symbol val'>:id=</span><span class='gt op'>&gt;</span><span class='string val'>'1'</span><span class='comma token'>,</span> <span class='symbol val'>:name=</span><span class='gt op'>&gt;</span><span class='string val'>'adam'</span><span class='comma token'>,</span> <span class='symbol val'>:phone</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='lbrack token'>[</span><span class='string val'>'987-654'</span><span class='comma token'>,</span> <span class='string val'>'1234-5678'</span><span class='rbrack token'>]</span><span class='rbrace token'>}</span>
</pre>
<h3>Id field</h3>
<p>
All Documents must have one id field. If one is not specified it is :id of
type String. A different id can be specified using the field_infos id_field
property on the index:
</p>
<pre class="code">
  <span class='index identifier id'>index</span> <span class='assign token'>=</span> <span class='Index constant id'>Index</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='string val'>'some/path/to/the/index'</span><span class='rparen token'>)</span>
  <span class='index identifier id'>index</span><span class='dot token'>.</span><span class='field_infos identifier id'>field_infos</span><span class='dot token'>.</span><span class='id_field identifier id'>id_field</span> <span class='assign token'>=</span> <span class='symbol val'>:my_id</span>
</pre>
<p>
To change the type of the my_id from String to a different type see below.
</p>
<h3>Conversion of types</h3>
<p>
Lucene.rb can handle type conversion for you. (The java lucene library
stores all the fields as Strings) For example if you want the id field to
be a fixnum
</p>
<pre class="code">
    <span class='require identifier id'>require</span> <span class='string val'>'lucene'</span>
    <span class='include identifier id'>include</span> <span class='Lucene constant id'>Lucene</span>

    <span class='index identifier id'>index</span> <span class='assign token'>=</span> <span class='Index constant id'>Index</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='string val'>'var/myindex'</span><span class='rparen token'>)</span>  <span class='comment val'># store the index at dir: var/myindex</span>
    <span class='index identifier id'>index</span><span class='dot token'>.</span><span class='field_infos identifier id'>field_infos</span><span class='lbrack token'>[</span><span class='symbol val'>:id</span><span class='rbrack token'>]</span><span class='lbrack token'>[</span><span class='symbol val'>:type</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='Fixnum constant id'>Fixnum</span>

    <span class='index identifier id'>index</span> <span class='lshft op'>&lt;&lt;</span> <span class='lbrace token'>{</span><span class='symbol val'>:id=</span><span class='gt op'>&gt;</span><span class='integer val'>1</span><span class='comma token'>,</span> <span class='symbol val'>:name=</span><span class='gt op'>&gt;</span><span class='string val'>'foo'</span><span class='rbrace token'>}</span> <span class='comment val'># notice 1 is not a string now</span>

    <span class='index identifier id'>index</span><span class='dot token'>.</span><span class='commit identifier id'>commit</span>

    <span class='comment val'># find that document, hits is a ruby Enumeration of documents</span>
    <span class='hits identifier id'>hits</span> <span class='assign token'>=</span> <span class='index identifier id'>index</span><span class='dot token'>.</span><span class='find identifier id'>find</span><span class='lparen token'>(</span><span class='symbol val'>:name</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'foo'</span><span class='rparen token'>)</span>

    <span class='comment val'># show the id of the first document (document 0) found</span>
    <span class='comment val'># (the document contains all stored fields - see below)</span>
    <span class='doc identifier id'>doc</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span><span class='lbrack token'>[</span><span class='symbol val'>:id</span><span class='rbrack token'>]</span>   <span class='comment val'># =&gt; 1</span>
</pre>
<p>
If the field_info type parameter is not set then it has a default value of
String.
</p>
<h3>Storage of fields</h3>
<p>
By default only the id field will be stored. That means that in the example
above the :name field will not be included in the document.
</p>
<p>
Example
</p>
<pre class="code">
    <span class='doc identifier id'>doc</span> <span class='assign token'>=</span> <span class='index identifier id'>index</span><span class='dot token'>.</span><span class='find identifier id'>find</span><span class='lparen token'>(</span><span class='string val'>'name'</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'foo'</span><span class='rparen token'>)</span>
    <span class='doc identifier id'>doc</span><span class='lbrack token'>[</span><span class='symbol val'>:id</span><span class='rbrack token'>]</span>   <span class='comment val'># =&gt; 1</span>
    <span class='doc identifier id'>doc</span><span class='lbrack token'>[</span><span class='symbol val'>:name</span><span class='rbrack token'>]</span> <span class='comment val'># =&gt; nil</span>
</pre>
<p>
Use the field info :store=true if you want a field to be stored in the
index (otherwise it will only be searchable).
</p>
<p>
Example
</p>
<pre class="code">
    <span class='require identifier id'>require</span> <span class='string val'>'lucene'</span>
    <span class='include identifier id'>include</span> <span class='Lucene constant id'>Lucene</span>

    <span class='index identifier id'>index</span> <span class='assign token'>=</span> <span class='Index constant id'>Index</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='string val'>'var/myindex'</span><span class='rparen token'>)</span>  <span class='comment val'># store the index at dir: var/myindex</span>
    <span class='index identifier id'>index</span><span class='dot token'>.</span><span class='field_infos identifier id'>field_infos</span><span class='lbrack token'>[</span><span class='symbol val'>:id</span><span class='rbrack token'>]</span><span class='lbrack token'>[</span><span class='symbol val'>:type</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='Fixnum constant id'>Fixnum</span>
    <span class='index identifier id'>index</span><span class='dot token'>.</span><span class='field_infos identifier id'>field_infos</span><span class='lbrack token'>[</span><span class='symbol val'>:name</span><span class='rbrack token'>]</span><span class='lbrack token'>[</span><span class='symbol val'>:store</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='true true kw'>true</span> <span class='comment val'># store this field</span>

    <span class='index identifier id'>index</span> <span class='lshft op'>&lt;&lt;</span> <span class='lbrace token'>{</span><span class='symbol val'>:id=</span><span class='gt op'>&gt;</span><span class='integer val'>1</span><span class='comma token'>,</span> <span class='symbol val'>:name=</span><span class='gt op'>&gt;</span><span class='string val'>'foo'</span><span class='rbrace token'>}</span> <span class='comment val'># notice 1 is not a string now</span>

    <span class='index identifier id'>index</span><span class='dot token'>.</span><span class='commit identifier id'>commit</span>

    <span class='comment val'># find that document, hits is a ruby Enumeration of documents</span>
    <span class='hits identifier id'>hits</span> <span class='assign token'>=</span> <span class='index identifier id'>index</span><span class='dot token'>.</span><span class='find identifier id'>find</span><span class='lparen token'>(</span><span class='string val'>'name'</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'foo'</span><span class='rparen token'>)</span>

    <span class='comment val'># let say hits only contains one document so we can use doc[0] for that one</span>
    <span class='comment val'># that document contains all stored fields (see below)</span>
    <span class='doc identifier id'>doc</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span><span class='lbrack token'>[</span><span class='symbol val'>:id</span><span class='rbrack token'>]</span>   <span class='comment val'># =&gt; 1</span>
    <span class='doc identifier id'>doc</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span><span class='lbrack token'>[</span><span class='symbol val'>:name</span><span class='rbrack token'>]</span> <span class='comment val'># =&gt; 'foo'</span>
</pre>
<h3>Setting field infos</h3>
<p>
As shown above you can set field infos like this
</p>
<pre class="code">
  <span class='index identifier id'>index</span><span class='dot token'>.</span><span class='field_infos identifier id'>field_infos</span><span class='lbrack token'>[</span><span class='symbol val'>:id</span><span class='rbrack token'>]</span><span class='lbrack token'>[</span><span class='symbol val'>:type</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='Fixnum constant id'>Fixnum</span>
</pre>
<p>
Or you can set several properties like this:
</p>
<pre class="code">
  <span class='index identifier id'>index</span><span class='dot token'>.</span><span class='field_infos identifier id'>field_infos</span><span class='lbrack token'>[</span><span class='symbol val'>:id</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='lbrace token'>{</span><span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='Fixnum constant id'>Fixnum</span><span class='comma token'>,</span> <span class='symbol val'>:store</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='true true kw'>true</span><span class='rbrace token'>}</span>
</pre>
<h3>Simple Queries</h3>
<p>
Lucene.rb support search in several fields: Example
</p>
<pre class="code">
    <span class='comment val'># finds all document having both name 'foo' and age 42</span>
    <span class='hits identifier id'>hits</span> <span class='assign token'>=</span> <span class='index identifier id'>index</span><span class='dot token'>.</span><span class='find identifier id'>find</span><span class='lparen token'>(</span><span class='string val'>'name'</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'foo'</span><span class='comma token'>,</span> <span class='symbol val'>:age=</span><span class='gt op'>&gt;</span><span class='integer val'>42</span><span class='rparen token'>)</span>
</pre>
<p>
Range queries
</p>
<pre class="code">
    <span class='comment val'># finds all document having both name 'foo' and age between 3 and 30</span>
    <span class='hits identifier id'>hits</span> <span class='assign token'>=</span> <span class='index identifier id'>index</span><span class='dot token'>.</span><span class='find identifier id'>find</span><span class='lparen token'>(</span><span class='string val'>'name'</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'foo'</span><span class='comma token'>,</span> <span class='symbol val'>:age=</span><span class='gt op'>&gt;</span><span class='float val'>3</span><span class='dot2 op'>..</span><span class='integer val'>30</span><span class='rparen token'>)</span>
</pre>
<h3>Lucene Queries</h3>
<p>
If the query is string then the string is a lucene query.
</p>
<pre class="code">
  <span class='hits identifier id'>hits</span> <span class='assign token'>=</span> <span class='index identifier id'>index</span><span class='dot token'>.</span><span class='find identifier id'>find</span><span class='lparen token'>(</span><span class='string val'>'name:foo'</span><span class='rparen token'>)</span>
</pre>
<p>
For more information see:
http://lucene.apache.org/java/2_4_0/queryparsersyntax.html
</p>
<h3>Advanced Queries (DSL)</h3>
<p>
The queries above can also be written in a lucene.rb DSL:
</p>
<pre class="code">
    <span class='hits identifier id'>hits</span> <span class='assign token'>=</span> <span class='index identifier id'>index</span><span class='dot token'>.</span><span class='find identifier id'>find</span> <span class='lbrace token'>{</span> <span class='lparen token'>(</span><span class='name identifier id'>name</span> <span class='eq op'>==</span> <span class='string val'>'andreas'</span><span class='rparen token'>)</span> <span class='bitand op'>&amp;</span> <span class='lparen token'>(</span><span class='foo identifier id'>foo</span> <span class='eq op'>==</span> <span class='string val'>'bar'</span><span class='rparen token'>)</span><span class='rbrace token'>}</span>
</pre>
<p>
Expression with OR (|) is supported, example
</p>
<pre class="code">
   <span class='comment val'># find all documents with name 'andreas' or age between 30 and 40</span>
    <span class='hits identifier id'>hits</span> <span class='assign token'>=</span> <span class='index identifier id'>index</span><span class='dot token'>.</span><span class='find identifier id'>find</span> <span class='lbrace token'>{</span> <span class='lparen token'>(</span><span class='name identifier id'>name</span> <span class='eq op'>==</span> <span class='string val'>'andreas'</span><span class='rparen token'>)</span> <span class='bitor op'>|</span> <span class='lparen token'>(</span><span class='age identifier id'>age</span> <span class='eq op'>==</span> <span class='float val'>30</span><span class='dot2 op'>..</span><span class='integer val'>40</span><span class='rparen token'>)</span><span class='rbrace token'>}</span>
</pre>
<h3>Sorting</h3>
<p>
Sorting is specified by the &#8216;sort_by&#8217; parameter Example
</p>
<pre class="code">
  <span class='hits identifier id'>hits</span> <span class='assign token'>=</span> <span class='index identifier id'>index</span><span class='dot token'>.</span><span class='find identifier id'>find</span><span class='lparen token'>(</span><span class='symbol val'>:name</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'foo'</span><span class='comma token'>,</span> <span class='symbol val'>:sort_by=</span><span class='gt op'>&gt;</span><span class='symbol val'>:category</span><span class='rparen token'>)</span>
</pre>
<p>
To sort by several fields:
</p>
<pre class="code">
  <span class='hits identifier id'>hits</span> <span class='assign token'>=</span> <span class='index identifier id'>index</span><span class='dot token'>.</span><span class='find identifier id'>find</span><span class='lparen token'>(</span><span class='symbol val'>:name</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'foo'</span><span class='comma token'>,</span> <span class='symbol val'>:sort_by=</span><span class='gt op'>&gt;</span><span class='lbrack token'>[</span><span class='symbol val'>:category</span><span class='comma token'>,</span> <span class='symbol val'>:country</span><span class='rbrack token'>]</span><span class='rparen token'>)</span>
</pre>
<p>
Example sort order
</p>
<pre class="code">
  <span class='hits identifier id'>hits</span> <span class='assign token'>=</span> <span class='index identifier id'>index</span><span class='dot token'>.</span><span class='find identifier id'>find</span><span class='lparen token'>(</span><span class='symbol val'>:name</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'foo'</span><span class='comma token'>,</span> <span class='symbol val'>:sort_by=</span><span class='gt op'>&gt;</span><span class='lbrack token'>[</span><span class='Desc constant id'>Desc</span><span class='lbrack token'>[</span><span class='symbol val'>:category</span><span class='comma token'>,</span> <span class='symbol val'>:country</span><span class='rbrack token'>]</span><span class='comma token'>,</span> <span class='Asc constant id'>Asc</span><span class='lbrack token'>[</span><span class='symbol val'>:city</span><span class='rbrack token'>]</span><span class='rbrack token'>]</span><span class='rparen token'>)</span>
</pre>
<h3>Thread-safety</h3>
<p>
The Lucene::Index is thread safe. It guarantees that an index is not
updated from two thread at the same time.
</p>
<h3>Lucene Transactions</h3>
<p>
Use the Lucene::Transaction in order to do atomic commits. By using a
transaction you do not need to call the Index.commit method.
</p>
<p>
Example:
</p>
<pre class="code">
    <span class='Transaction constant id'>Transaction</span><span class='dot token'>.</span><span class='run identifier id'>run</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='t identifier id'>t</span><span class='bitor op'>|</span>
      <span class='index identifier id'>index</span> <span class='assign token'>=</span> <span class='Index constant id'>Index</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='string val'>'var/index/foo'</span><span class='rparen token'>)</span>
      <span class='index identifier id'>index</span> <span class='lshft op'>&lt;&lt;</span> <span class='lbrace token'>{</span> <span class='id identifier id'>id</span><span class='assign token'>=</span><span class='gt op'>&gt;</span><span class='integer val'>42</span><span class='comma token'>,</span> <span class='symbol val'>:name=</span><span class='gt op'>&gt;</span><span class='string val'>'andreas'</span><span class='rbrace token'>}</span>
      <span class='t identifier id'>t</span><span class='dot token'>.</span><span class='failure identifier id'>failure</span>  <span class='comment val'># rollback</span>
    <span class='end end kw'>end</span>

    <span class='result identifier id'>result</span> <span class='assign token'>=</span> <span class='index identifier id'>index</span><span class='dot token'>.</span><span class='find identifier id'>find</span><span class='lparen token'>(</span><span class='string val'>'name'</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'andreas'</span><span class='rparen token'>)</span>
    <span class='result identifier id'>result</span><span class='dot token'>.</span><span class='size identifier id'>size</span><span class='dot token'>.</span><span class='should identifier id'>should</span> <span class='eq op'>==</span> <span class='integer val'>0</span>
</pre>
<p>
You can find which documents are uncommited by using the uncommited index
property.
</p>
<p>
Example
</p>
<pre class="code">
      <span class='index identifier id'>index</span> <span class='assign token'>=</span> <span class='Index constant id'>Index</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='string val'>'var/index/foo'</span><span class='rparen token'>)</span>
      <span class='index identifier id'>index</span><span class='dot token'>.</span><span class='uncommited identifier id'>uncommited</span> <span class='comment val'>#=&gt; [document1, document2]</span>
</pre>
<p>
Notice that even if it looks like a new Index instance object was created
the index.uncommited may return an not empty array. This is because
Index.new is a singleton - a new instance object is not created.
</p>
<h2>The Neo4j Module</h2>
<p>
The Neo4j module is used to map Ruby objects to nodes and relationships in
a network. It supports two different ways of retrieval/quering:
</p>
<ul>
<li>Neo4j traversal, Neo4j::NodeMixin#traverse (or Neo4j::NodeMixin#has_n)

</li>
<li>Lucene indexes, Neo4j::NodeMixin#find

</li>
</ul>
<h3>Start and Stop of the Neo4j</h3>
<p>
Unlike the Java Neo4j implementation it is not neccessarly to start Neo4j.
It will automatically be started when needed. It also uses a hook to
automatically shutdown Neo4j. Shutdown of neo4j can also be done using the
stop method, example:
</p>
<pre class="code">
  <span class='Neo4j constant id'>Neo4j</span><span class='dot token'>.</span><span class='stop identifier id'>stop</span>
</pre>
<h4>Neo4j Configuration</h4>
<p>
Before using Neo4j the location where the database is stored on disk should
be configured. The neo4j configuration is kept in the Neo4j::Config class:
</p>
<pre class="code">
   <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='Config constant id'>Config</span><span class='lbrack token'>[</span><span class='symbol val'>:storage_path</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='string val'>'/home/neo/neodb'</span>
</pre>
<h3>Lucene Integration</h3>
<p>
Neo4j.rb uses the Lucene module. That means that the Neo4j::NodeMixin has
method for both traversal and lucene queries/indexing.
</p>
<h4>Lucene Configuration</h4>
<p>
By default lucene indexes are kept in memory. Keeping index in memory will
increase the performance of lucene operations (such as updating the index).
</p>
<p>
Example to configure Lucene to store indexes on disk instead
</p>
<pre class="code">
   <span class='Lucene constant id'>Lucene</span><span class='colon2 op'>::</span><span class='Config constant id'>Config</span><span class='lbrack token'>[</span><span class='symbol val'>:store_on_file</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
   <span class='Lucene constant id'>Lucene</span><span class='colon2 op'>::</span><span class='Config constant id'>Config</span><span class='lbrack token'>[</span><span class='symbol val'>:storage_path</span><span class='rbrack token'>]</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'/home/neo/lucene-db'</span>
</pre>
<h4>Lucene Index in Memory</h4>
<p>
If index is stored in memory then one needs to reindex all nodes when the
application starts up again.
</p>
<pre class="code">
   <span class='MyNode constant id'>MyNode</span><span class='dot token'>.</span><span class='update_index identifier id'>update_index</span> <span class='comment val'># will traverse all MyNode instances and (re)create the lucene index in memory.</span>
</pre>
<h3>Neo4j::NodeMixin</h3>
<p>
Neo4j::NodeMixin is a mixin that lets instances to be stored as a node in
the neo node space on disk. A node can have properties and relationships to
other nodes.
</p>
<p>
Example of how declare a class that has this behaviour:
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='MyNode constant id'>MyNode</span>
     <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='NodeMixin constant id'>NodeMixin</span>
  <span class='end end kw'>end</span>
</pre>
<h3>Create a Node</h3>
<pre class="code">
  <span class='node identifier id'>node</span> <span class='assign token'>=</span> <span class='MyNode constant id'>MyNode</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
</pre>
<h3>Delete a Node</h3>
<p>
The Neo4j::NodeMixin mixin defines a delete method that will delete the
node and all its relationships.
</p>
<p>
Example:
</p>
<pre class="code">
  <span class='node identifier id'>node</span> <span class='assign token'>=</span> <span class='MyNode constant id'>MyNode</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
  <span class='node identifier id'>node</span><span class='dot token'>.</span><span class='delete identifier id'>delete</span>
</pre>
<p>
The node in the example above will be removed from the neo database on the
filesystem and the lucene index
</p>
<h3>Node Properties</h3>
<p>
In order to use properties they have to be declared first
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='MyNode constant id'>MyNode</span>
     <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='NodeMixin constant id'>NodeMixin</span>
     <span class='property identifier id'>property</span> <span class='symbol val'>:foo</span><span class='comma token'>,</span> <span class='symbol val'>:bar</span>
  <span class='end end kw'>end</span>
</pre>
<p>
These properties (foo and bar) will be stored in the Neo database. You can
set those properties:
</p>
<pre class="code">
  <span class='comment val'># create a node with two properties in one transaction</span>
  <span class='node identifier id'>node</span> <span class='assign token'>=</span> <span class='MyNode constant id'>MyNode</span><span class='dot token'>.</span><span class='new identifier id'>new</span> <span class='lbrace token'>{</span> <span class='bitor op'>|</span><span class='n identifier id'>n</span><span class='bitor op'>|</span>
     <span class='n identifier id'>n</span><span class='dot token'>.</span><span class='foo identifier id'>foo</span> <span class='assign token'>=</span> <span class='integer val'>123</span>
     <span class='n identifier id'>n</span><span class='dot token'>.</span><span class='bar identifier id'>bar</span> <span class='assign token'>=</span> <span class='float val'>3.14</span>
  <span class='rbrace token'>}</span>

  <span class='comment val'># access those properties</span>
  <span class='puts identifier id'>puts</span> <span class='node identifier id'>node</span><span class='dot token'>.</span><span class='foo identifier id'>foo</span>
</pre>
<p>
You can also set a property like this:
</p>
<pre class="code">
    <span class='f identifier id'>f</span> <span class='assign token'>=</span> <span class='SomeNode constant id'>SomeNode</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
    <span class='f identifier id'>f</span><span class='dot token'>.</span><span class='foo identifier id'>foo</span> <span class='assign token'>=</span> <span class='integer val'>123</span>
</pre>
<p>
Neo4j.rb supports properties to by of type String, Fixnum, Float and
true/false
</p>
<h3>Property Types and Marshalling</h3>
<p>
If you want to set a property of a different type then String, Fixnum,
Float or true/false you have to specify its type.
</p>
<p>
Example, to set a property to any type
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='MyNode constant id'>MyNode</span>
    <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='NodeMixin constant id'>NodeMixin</span>
    <span class='property identifier id'>property</span> <span class='symbol val'>:foo</span><span class='comma token'>,</span> <span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='Object constant id'>Object</span>
  <span class='end end kw'>end</span>

  <span class='node identifier id'>node</span> <span class='assign token'>=</span> <span class='MyNode constant id'>MyNode</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
  <span class='node identifier id'>node</span><span class='dot token'>.</span><span class='foo identifier id'>foo</span> <span class='assign token'>=</span> <span class='lbrack token'>[</span><span class='integer val'>1</span><span class='comma token'>,</span><span class='string val'>&quot;3&quot;</span><span class='comma token'>,</span> <span class='float val'>3.14</span><span class='rbrack token'>]</span>

  <span class='Neo4j constant id'>Neo4j</span><span class='dot token'>.</span><span class='load identifier id'>load</span><span class='lparen token'>(</span><span class='node identifier id'>node</span><span class='dot token'>.</span><span class='neo_node_id identifier id'>neo_node_id</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='foo identifier id'>foo</span><span class='dot token'>.</span><span class='class identifier id'>class</span> <span class='comment val'># =&gt; Array</span>
</pre>
<h3>Property of type Date and DateTime</h3>
<p>
Example of using Date queries:
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='MyNode constant id'>MyNode</span>
    <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='NodeMixin constant id'>NodeMixin</span>
    <span class='property identifier id'>property</span> <span class='symbol val'>:since</span><span class='comma token'>,</span> <span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='Date constant id'>Date</span>
    <span class='index identifier id'>index</span> <span class='symbol val'>:since</span><span class='comma token'>,</span> <span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='Date constant id'>Date</span>
  <span class='end end kw'>end</span>

  <span class='node identifier id'>node</span><span class='dot token'>.</span><span class='since identifier id'>since</span> <span class='assign token'>=</span> <span class='Date constant id'>Date</span><span class='dot token'>.</span><span class='new identifier id'>new</span> <span class='integer val'>2008</span><span class='comma token'>,</span><span class='integer val'>05</span><span class='comma token'>,</span><span class='integer val'>06</span>
  <span class='MyNode constant id'>MyNode</span><span class='dot token'>.</span><span class='find identifier id'>find</span><span class='lparen token'>(</span><span class='string val'>&quot;born:[20080427 TO 20100203]&quot;</span><span class='rparen token'>)</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='since identifier id'>since</span> <span class='comment val'># =&gt; Date 2008,05,06</span>
</pre>
<p>
Example of using DateTime queries:
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='MyNode constant id'>MyNode</span>
    <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='NodeMixin constant id'>NodeMixin</span>
    <span class='property identifier id'>property</span> <span class='symbol val'>:since</span><span class='comma token'>,</span> <span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='DateTime constant id'>DateTime</span>
    <span class='index identifier id'>index</span> <span class='symbol val'>:since</span><span class='comma token'>,</span> <span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='DateTime constant id'>DateTime</span>
  <span class='end end kw'>end</span>

  <span class='node identifier id'>node</span><span class='dot token'>.</span><span class='since identifier id'>since</span> <span class='assign token'>=</span> <span class='DateTime constant id'>DateTime</span><span class='dot token'>.</span><span class='civil identifier id'>civil</span> <span class='integer val'>2008</span><span class='comma token'>,</span><span class='integer val'>04</span><span class='comma token'>,</span><span class='integer val'>27</span><span class='comma token'>,</span><span class='integer val'>15</span><span class='comma token'>,</span><span class='integer val'>25</span><span class='comma token'>,</span><span class='integer val'>59</span>
  <span class='MyNode constant id'>MyNode</span><span class='dot token'>.</span><span class='find identifier id'>find</span><span class='lparen token'>(</span><span class='string val'>&quot;since:[200804271504 TO 201002031534]&quot;</span><span class='rparen token'>)</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='since identifier id'>since</span> <span class='comment val'># =&gt; DateTime ...</span>
</pre>
<p>
Only UTC timezone is allowed.
</p>
<h3>Finding all nodes</h3>
<p>
To find all nodes of a specific type use the all method. Example
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='Car constant id'>Car</span>
    <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='Node constant id'>Node</span>
    <span class='property identifier id'>property</span> <span class='symbol val'>:wheels</span>
  <span class='end end kw'>end</span>

  <span class='class class kw'>class</span> <span class='Volvo constant id'>Volvo</span> <span class='lt op'>&lt;</span> <span class='Car constant id'>Car</span>
  <span class='end end kw'>end</span>

  <span class='v identifier id'>v</span> <span class='assign token'>=</span> <span class='Volvo constant id'>Volvo</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
  <span class='c identifier id'>c</span> <span class='assign token'>=</span> <span class='Car constant id'>Car</span><span class='dot token'>.</span><span class='new identifier id'>new</span>

  <span class='Car constant id'>Car</span><span class='dot token'>.</span><span class='all identifier id'>all</span>   <span class='comment val'># will return all relationships from the reference node to car obejcts</span>
  <span class='Volvo constant id'>Volvo</span><span class='dot token'>.</span><span class='all identifier id'>all</span> <span class='comment val'># will return the same as Car.all</span>
</pre>
<p>
To return nodes (just like the relationships method)
</p>
<pre class="code">
  <span class='Car constant id'>Car</span><span class='dot token'>.</span><span class='all identifier id'>all</span><span class='dot token'>.</span><span class='nodes identifier id'>nodes</span>    <span class='comment val'># =&gt; [c,v]</span>
  <span class='Volvo constant id'>Volvo</span><span class='dot token'>.</span><span class='all identifier id'>all</span><span class='dot token'>.</span><span class='nodes identifier id'>nodes</span>  <span class='comment val'># =&gt; [c,v]</span>
</pre>
<h3>Relationship has_n and has_one</h3>
<p>
Neo relationships are none symmetrical. That means that if A has a
relationship to B then it may not be true that B has a relationship to A.
</p>
<p>
Relationships can be declared by using the &#8216;has_n&#8217; or
&#8216;has_one&#8217; Neo4j::NodeMixin class methods.
</p>
<h4>has_n</h4>
<p>
The has_n Neo4j::NodeMixin class method creates a new instance method that
can be used for both traversing and adding new objects to a specific
relationship type.
</p>
<p>
For example, let say that Person can have a relationship to any other node
class with the type &#8216;friends&#8217;:
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='Person constant id'>Person</span>
     <span class='include identifier id'>include</span> <span class='Neo constant id'>Neo</span><span class='colon2 op'>::</span><span class='Node constant id'>Node</span>
     <span class='has_n identifier id'>has_n</span> <span class='symbol val'>:knows</span>  <span class='comment val'># will generate a knows method for outgoing relationships</span>
  <span class='end end kw'>end</span>
</pre>
<p>
The generated knows method will allow you to add new relationships,
example:
</p>
<pre class="code">
  <span class='me identifier id'>me</span> <span class='assign token'>=</span> <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
  <span class='neo identifier id'>neo</span> <span class='assign token'>=</span> <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
  <span class='me identifier id'>me</span><span class='dot token'>.</span><span class='knows identifier id'>knows</span> <span class='lshft op'>&lt;&lt;</span> <span class='neo identifier id'>neo</span>  <span class='comment val'># me knows neo but neo does not know me</span>
</pre>
<p>
You can add any object to the &#8216;knows&#8217; relationship as long as
it includes the Neo4j::NodeMixin, example:
</p>
<pre class="code">
  <span class='person identifier id'>person</span> <span class='assign token'>=</span> <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
  <span class='car identifier id'>car</span> <span class='assign token'>=</span> <span class='Volvo constant id'>Volvo</span><span class='dot token'>.</span><span class='new identifier id'>new</span> <span class='comment val'># Volvo is a class that includes the Neo4j::NodeMixin</span>
  <span class='person identifier id'>person</span><span class='dot token'>.</span><span class='knows identifier id'>knows</span> <span class='lshft op'>&lt;&lt;</span> <span class='car identifier id'>car</span>
</pre>
<p>
If you want to express that the relationship should point to a specific
class use the &#8216;to&#8217; method on the has_n method.
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='Person constant id'>Person</span>
     <span class='include identifier id'>include</span> <span class='Neo constant id'>Neo</span><span class='colon2 op'>::</span><span class='Node constant id'>Node</span>
     <span class='has_n identifier id'>has_n</span><span class='lparen token'>(</span><span class='symbol val'>:knows</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='to identifier id'>to</span><span class='lparen token'>(</span><span class='Person constant id'>Person</span><span class='rparen token'>)</span>
  <span class='end end kw'>end</span>
</pre>
<p>
It is also possible to generate methods for incoming relationships by using
the &#8216;from&#8217; method on the has_n method.
</p>
<p>
Example:
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='Person constant id'>Person</span>
     <span class='include identifier id'>include</span> <span class='Neo constant id'>Neo</span><span class='colon2 op'>::</span><span class='Node constant id'>Node</span>
     <span class='has_n identifier id'>has_n</span> <span class='symbol val'>:knows</span>  <span class='comment val'># will generate a knows method for outgoing relationships</span>
     <span class='has_n identifier id'>has_n</span><span class='lparen token'>(</span><span class='symbol val'>:known_by</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='from identifier id'>from</span><span class='lparen token'>(</span><span class='symbol val'>:knows</span><span class='rparen token'>)</span>  <span class='comment val'>#  will generate a known_by method for incomming knows relationship</span>
  <span class='end end kw'>end</span>
</pre>
<p>
By doing this you can add a relationships on either the incoming or
outgoing node. The from method can also take an additional class parameter
if it has incoming nodes from a different node class (see the
Actor-Role-Movie example at the top of this document).
</p>
<p>
Example of adding a &#8216;knows&#8217; relationship from the other node:
</p>
<pre class="code">
  <span class='me identifier id'>me</span> <span class='assign token'>=</span> <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
  <span class='neo identifier id'>neo</span> <span class='assign token'>=</span> <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
  <span class='neo identifier id'>neo</span><span class='dot token'>.</span><span class='known_by identifier id'>known_by</span> <span class='lshft op'>&lt;&lt;</span> <span class='me identifier id'>me</span> <span class='comment val'># me knows neo but neo does not know me</span>
</pre>
<p>
The known_by method creates a &#8216;knows&#8217; relationship between the
me and neo nodes. This is the same as doing:
</p>
<pre class="code">
  <span class='me identifier id'>me</span><span class='dot token'>.</span><span class='knows identifier id'>knows</span> <span class='lshft op'>&lt;&lt;</span> <span class='neo identifier id'>neo</span> <span class='comment val'># me knows neo but neo does not know me</span>
</pre>
<h4>Relationship has_one</h4>
<p>
Example of has_one: A person can have at most one Address
</p>
<pre class="code">
      <span class='class class kw'>class</span> <span class='Person constant id'>Person</span>
        <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='NodeMixin constant id'>NodeMixin</span>
        <span class='has_one identifier id'>has_one</span><span class='lparen token'>(</span><span class='symbol val'>:address</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='to identifier id'>to</span><span class='lparen token'>(</span><span class='Address constant id'>Address</span><span class='rparen token'>)</span>
      <span class='end end kw'>end</span>

      <span class='class class kw'>class</span> <span class='Address constant id'>Address</span>
        <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='NodeMixin constant id'>NodeMixin</span>
        <span class='property identifier id'>property</span> <span class='symbol val'>:city</span><span class='comma token'>,</span> <span class='symbol val'>:road</span>
        <span class='has_n identifier id'>has_n</span><span class='lparen token'>(</span><span class='symbol val'>:people</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='from identifier id'>from</span><span class='lparen token'>(</span><span class='Person constant id'>Person</span><span class='comma token'>,</span> <span class='symbol val'>:address</span><span class='rparen token'>)</span>
      <span class='end end kw'>end</span>
</pre>
<p>
In the example above we have Neo4j.rb will generate the following methods
</p>
<ul>
<li>in Person, the method &#8217;&#8217;address=&#8217;&#8217; and
&#8217;&#8217;address&#8217;&#8216;

</li>
<li>in Address, the traversal method &#8217;&#8217;people&#8217;&#8217; for
traversing incomming relationships from the Person node.

</li>
</ul>
<p>
Example of usage:
</p>
<pre class="code">
      <span class='p identifier id'>p</span> <span class='assign token'>=</span> <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
      <span class='p identifier id'>p</span><span class='dot token'>.</span><span class='address identifier id'>address</span> <span class='assign token'>=</span> <span class='Address constant id'>Address</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
      <span class='p identifier id'>p</span><span class='dot token'>.</span><span class='address identifier id'>address</span><span class='dot token'>.</span><span class='city identifier id'>city</span> <span class='assign token'>=</span> <span class='string val'>'malmoe'</span>
</pre>
<p>
Or from the incoming &#8217;&#8217;address&#8217;&#8217; relationship
</p>
<pre class="code">
      <span class='a identifier id'>a</span> <span class='assign token'>=</span> <span class='Address constant id'>Address</span><span class='dot token'>.</span><span class='new identifier id'>new</span> <span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='n identifier id'>n</span><span class='bitor op'>|</span> <span class='n identifier id'>n</span><span class='dot token'>.</span><span class='city identifier id'>city</span> <span class='assign token'>=</span> <span class='string val'>'malmoe'</span><span class='rbrace token'>}</span>
      <span class='a identifier id'>a</span><span class='dot token'>.</span><span class='people identifier id'>people</span> <span class='lshft op'>&lt;&lt;</span> <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
</pre>
<h3>Relationship has_list</h3>
<p>
The has_n relationship will not maintain the order of when items are
inserted to the relationship. If order should be preserved then use the
has_list class method instead.
</p>
<p>
Example
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='Company constant id'>Company</span>
    <span class='has_list identifier id'>has_list</span> <span class='symbol val'>:employees</span>
  <span class='end end kw'>end</span>

  <span class='company identifier id'>company</span> <span class='assign token'>=</span> <span class='Company constant id'>Company</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
  <span class='company identifier id'>company</span><span class='dot token'>.</span><span class='employees identifier id'>employees</span> <span class='lshft op'>&lt;&lt;</span> <span class='employee1 identifier id'>employee1</span> <span class='lshft op'>&lt;&lt;</span> <span class='employee2 identifier id'>employee2</span>

  <span class='comment val'># prints first employee2 and then employee1</span>
  <span class='company identifier id'>company</span><span class='dot token'>.</span><span class='employees identifier id'>employees</span><span class='dot token'>.</span><span class='each identifier id'>each</span> <span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='employee identifier id'>employee</span><span class='bitor op'>|</span> <span class='puts identifier id'>puts</span> <span class='employee identifier id'>employee</span><span class='dot token'>.</span><span class='name identifier id'>name</span><span class='rbrace token'>}</span>
</pre>
<h4>Traversing Relationships</h4>
<p>
Each type of relationship has a method that returns an Enumerable object
that enables you to traverse that type of relationship.
</p>
<p>
For example the Person example above declares one relationship of type
friends. You can traverse all Person&#8217;s friend (depth 1 is default)
</p>
<pre class="code">
  <span class='f identifier id'>f</span><span class='dot token'>.</span><span class='friends identifier id'>friends</span><span class='dot token'>.</span><span class='each identifier id'>each</span> <span class='lbrace token'>{</span> <span class='bitor op'>|</span><span class='n identifier id'>n</span><span class='bitor op'>|</span> <span class='puts identifier id'>puts</span> <span class='n identifier id'>n</span> <span class='rbrace token'>}</span>
</pre>
<p>
It is also possible to traverse a relationship of an arbitrary depth.
Example finding all friends and friends friends.
</p>
<pre class="code">
  <span class='f identifier id'>f</span><span class='dot token'>.</span><span class='friends identifier id'>friends</span><span class='dot token'>.</span><span class='depth identifier id'>depth</span><span class='lparen token'>(</span><span class='integer val'>2</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='each identifier id'>each</span> <span class='lbrace token'>{</span> <span class='dot3 op'>...</span><span class='rbrace token'>}</span>
</pre>
<p>
Traversing to the end of the graph
</p>
<pre class="code">
  <span class='f identifier id'>f</span><span class='dot token'>.</span><span class='friends identifier id'>friends</span><span class='dot token'>.</span><span class='depth identifier id'>depth</span><span class='lparen token'>(</span><span class='symbol val'>:all</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='each identifier id'>each</span> <span class='lbrace token'>{</span> <span class='dot3 op'>...</span><span class='rbrace token'>}</span>
</pre>
<h4>Filtering Nodes</h4>
<p>
If you want to find one node in a relationship you can use a filter.
Example, let say we want to find a friend with name &#8216;andreas&#8217;
</p>
<pre class="code">
  <span class='n1 identifier id'>n1</span> <span class='assign token'>=</span> <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
  <span class='n2 identifier id'>n2</span> <span class='assign token'>=</span> <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='new identifier id'>new</span> <span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='n identifier id'>n</span><span class='bitor op'>|</span> <span class='n identifier id'>n</span><span class='dot token'>.</span><span class='name identifier id'>name</span> <span class='assign token'>=</span> <span class='string val'>'andreas'</span><span class='rbrace token'>}</span>
  <span class='n3 identifier id'>n3</span> <span class='assign token'>=</span> <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
  <span class='n1 identifier id'>n1</span><span class='dot token'>.</span><span class='friends identifier id'>friends</span> <span class='lshft op'>&lt;&lt;</span> <span class='n2 identifier id'>n2</span> <span class='lshft op'>&lt;&lt;</span> <span class='n3 identifier id'>n3</span>
  <span class='n1 identifier id'>n1</span><span class='dot token'>.</span><span class='friends identifier id'>friends</span><span class='lbrace token'>{</span> <span class='name identifier id'>name</span> <span class='eq op'>==</span> <span class='string val'>'andreas'</span> <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='to_a identifier id'>to_a</span> <span class='comment val'># =&gt; [n2]</span>
</pre>
<p>
The block { name == &#8216;andreas&#8217; } will be evaluated on each node
in the relationship. If the evaluation returns true the node will be
included in the filter search result.
</p>
<h3>Traversing Nodes</h3>
<p>
The Neo4j::NodeMixin#traverse method is a more powerful method compared to
the generated has_n and has_one methods. Unlike those generated method it
can traverse several relationship types at the same time. The types of
relationships being traversed must therefore always be specified in the
incoming, outgoing or both method. Those three methods can take one or more
relationship types parameters if more then one type of relationship should
be traversed.
</p>
<h4>Traversing Nodes of Arbitrary Depth</h4>
<p>
The depth method allows you to specify how deep the traverse should be. If
not specified only one level traverse is done.
</p>
<p>
Example:
</p>
<pre class="code">
  <span class='me identifier id'>me</span><span class='dot token'>.</span><span class='traverse identifier id'>traverse</span><span class='dot token'>.</span><span class='incoming identifier id'>incoming</span><span class='lparen token'>(</span><span class='symbol val'>:friends</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='depth identifier id'>depth</span><span class='lparen token'>(</span><span class='integer val'>4</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='each identifier id'>each</span> <span class='lbrace token'>{</span><span class='rbrace token'>}</span> <span class='comment val'># =&gt; people with a friend relationship to me</span>
</pre>
<h4>Traversing Nodes With Several Relationship Types</h4>
<p>
It is possible to traverse sevaral relationship types at the same type. The
incoming, both and outgoing methods takes list of arguments.
</p>
<p>
Example, given the following holiday trip domain:
</p>
<pre class="code">
  <span class='comment val'># A location contains a hierarchy of other locations</span>
  <span class='comment val'># Example region (asia) contains countries which contains  cities etc...</span>
  <span class='class class kw'>class</span> <span class='Location constant id'>Location</span>
    <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='NodeMixin constant id'>NodeMixin</span>
    <span class='has_n identifier id'>has_n</span> <span class='symbol val'>:contains</span>
    <span class='has_n identifier id'>has_n</span> <span class='symbol val'>:trips</span>
    <span class='property identifier id'>property</span> <span class='symbol val'>:name</span>
    <span class='index identifier id'>index</span> <span class='symbol val'>:name</span>

  <span class='comment val'># A Trip can be specific for one global area, such as &quot;see all of sweden&quot; or</span>
  <span class='comment val'># local such as a 'city tour of malmoe'</span>
  <span class='class class kw'>class</span> <span class='Trip constant id'>Trip</span>
    <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='NodeMixin constant id'>NodeMixin</span>
    <span class='property identifier id'>property</span> <span class='symbol val'>:name</span>
  <span class='end end kw'>end</span>

  <span class='comment val'># create all nodes</span>
  <span class='comment val'># ...</span>

  <span class='comment val'># setup the relationship between all nodes</span>
  <span class='@europe ivar id'>@europe</span><span class='dot token'>.</span><span class='contains identifier id'>contains</span> <span class='lshft op'>&lt;&lt;</span> <span class='@sweden ivar id'>@sweden</span> <span class='lshft op'>&lt;&lt;</span> <span class='@denmark ivar id'>@denmark</span>
  <span class='@sweden ivar id'>@sweden</span><span class='dot token'>.</span><span class='contains identifier id'>contains</span> <span class='lshft op'>&lt;&lt;</span> <span class='@malmoe ivar id'>@malmoe</span> <span class='lshft op'>&lt;&lt;</span> <span class='@stockholm ivar id'>@stockholm</span>

  <span class='@sweden ivar id'>@sweden</span><span class='dot token'>.</span><span class='trips identifier id'>trips</span> <span class='lshft op'>&lt;&lt;</span> <span class='@sweden_trip ivar id'>@sweden_trip</span>
  <span class='@malmoe ivar id'>@malmoe</span><span class='dot token'>.</span><span class='trips identifier id'>trips</span> <span class='lshft op'>&lt;&lt;</span> <span class='@malmoe_trip ivar id'>@malmoe_trip</span>
  <span class='@malmoe ivar id'>@malmoe</span><span class='dot token'>.</span><span class='trips identifier id'>trips</span> <span class='lshft op'>&lt;&lt;</span> <span class='@city_tour ivar id'>@city_tour</span>
  <span class='@stockholm ivar id'>@stockholm</span><span class='dot token'>.</span><span class='trips identifier id'>trips</span> <span class='lshft op'>&lt;&lt;</span> <span class='@city_tour ivar id'>@city_tour</span> <span class='comment val'># the same city tour is available both in malmoe and stockholm</span>
</pre>
<p>
Then we can traverse both the contains and the trips relationship types
Example:
</p>
<pre class="code">
  <span class='@sweden ivar id'>@sweden</span><span class='dot token'>.</span><span class='traverse identifier id'>traverse</span><span class='dot token'>.</span><span class='outgoing identifier id'>outgoing</span><span class='lparen token'>(</span><span class='symbol val'>:contains</span><span class='comma token'>,</span> <span class='symbol val'>:trips</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='to_a identifier id'>to_a</span> <span class='comment val'># =&gt; [@malmoe, @stockholm, @sweden_trip]</span>
</pre>
<p>
It is also possible to traverse both incoming and outgoing relationships,
example:
</p>
<pre class="code">
  <span class='@sweden ivar id'>@sweden</span><span class='dot token'>.</span><span class='traverse identifier id'>traverse</span><span class='dot token'>.</span><span class='outgoing identifier id'>outgoing</span><span class='lparen token'>(</span><span class='symbol val'>:contains</span><span class='comma token'>,</span> <span class='symbol val'>:trips</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='incoming identifier id'>incoming</span><span class='lparen token'>(</span><span class='symbol val'>:contains</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='to_a identifier id'>to_a</span> <span class='comment val'># =&gt; [@malmoe, @stockholm, @sweden_trip, @europe]</span>
</pre>
<h4>Traversing Nodes With a Filter</h4>
<p>
It&#8217;s possible to filter which nodes should be returned from the
traverser by using the filter function. This filter function will be
evaluated differently depending on if it takes one argument or no
arguments, see below.
</p>
<h4>Filtering: Using Evaluation in the Context of the Current Node</h4>
<p>
If the provided filter function does not take any parameter it will be
evaluted in the context of the current node being traversed. That means
that one can writer filter functions like this:
</p>
<pre class="code">
  <span class='@sweden ivar id'>@sweden</span><span class='dot token'>.</span><span class='traverse identifier id'>traverse</span><span class='dot token'>.</span><span class='outgoing identifier id'>outgoing</span><span class='lparen token'>(</span><span class='symbol val'>:contains</span><span class='comma token'>,</span> <span class='symbol val'>:trips</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span> <span class='lbrace token'>{</span> <span class='name identifier id'>name</span> <span class='eq op'>==</span> <span class='string val'>'sweden'</span> <span class='rbrace token'>}</span>
</pre>
<h4>Filtering: Using the TraversalPostion</h4>
<p>
If the filter method takes one parameter then it will be given an object of
type TraversalPosition which contains information about current node, how
many nodes has been returned, depth etc.
</p>
<p>
The information contained in the TraversalPostion can be used in order to
decide if the node should included in the traversal search result. If the
provided block returns true then the node will be included in the search
result.
</p>
<p>
The filter function will not be evaluated in the context of the current
node when this parameter is provided.
</p>
<p>
The TraversalPosition is a wrapper of java interface TraversalPosition, see
http://api.neo4j.org/current/org/neo4j/api/core/TraversalPosition.html
</p>
<p>
For example if we only want to return the Trip objects in the example
above:
</p>
<pre class="code">
  <span class='comment val'># notice how the tp (TraversalPosition) parameter is used in order to only</span>
  <span class='comment val'># return nodes included in a 'trips' relationship.</span>
  <span class='traverser identifier id'>traverser</span> <span class='assign token'>=</span> <span class='@sweden ivar id'>@sweden</span><span class='dot token'>.</span><span class='traverse identifier id'>traverse</span><span class='dot token'>.</span><span class='outgoing identifier id'>outgoing</span><span class='lparen token'>(</span><span class='symbol val'>:contains</span><span class='comma token'>,</span> <span class='symbol val'>:trips</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='tp identifier id'>tp</span><span class='bitor op'>|</span>
    <span class='tp identifier id'>tp</span><span class='dot token'>.</span><span class='last_relationship_traversed identifier id'>last_relationship_traversed</span><span class='dot token'>.</span><span class='relationship_type identifier id'>relationship_type</span> <span class='eq op'>==</span> <span class='symbol val'>:trips</span>
  <span class='end end kw'>end</span>

  <span class='traverser identifier id'>traverser</span><span class='dot token'>.</span><span class='to_a identifier id'>to_a</span> <span class='comment val'># =&gt; [@sweden_trip]</span>
</pre>
<h3>Relationships</h3>
<p>
A relationship between two nodes can have properties just like a node.
</p>
<p>
Example:
</p>
<pre class="code">
  <span class='p1 identifier id'>p1</span> <span class='assign token'>=</span> <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
  <span class='p2 identifier id'>p2</span> <span class='assign token'>=</span> <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='new identifier id'>new</span>

  <span class='relationship identifier id'>relationship</span> <span class='assign token'>=</span> <span class='p1 identifier id'>p1</span><span class='dot token'>.</span><span class='friends identifier id'>friends</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='p2 identifier id'>p2</span><span class='rparen token'>)</span>

  <span class='comment val'># set a property 'since' on this relationship bewteen p1 and p2</span>
  <span class='relationship identifier id'>relationship</span><span class='dot token'>.</span><span class='since identifier id'>since</span> <span class='assign token'>=</span> <span class='integer val'>1992</span>
</pre>
<p>
If a Relationship class has not been specified for a relationship then any
properties can be set on the relationship. It has a default relationship
class: Neo4j::DynamicRelation
</p>
<p>
If you instead want to use your own class for a relationship use the
Neo4j::NodeMixin#has_n.relationship method, example:
</p>
<pre class="code">
      <span class='class class kw'>class</span> <span class='Role constant id'>Role</span>
        <span class='comment val'># This class can be used as the relationship between two nodes</span>
        <span class='comment val'># since it includes the following mixin</span>
        <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='RelationMixin constant id'>RelationMixin</span>
        <span class='property identifier id'>property</span> <span class='symbol val'>:name</span>
      <span class='end end kw'>end</span>

      <span class='class class kw'>class</span> <span class='Actor constant id'>Actor</span>
        <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='NodeMixin constant id'>NodeMixin</span>
        <span class='comment val'># use the Role class above in the relationship between Actor and Movie</span>
        <span class='has_n identifier id'>has_n</span><span class='lparen token'>(</span><span class='symbol val'>:acted_in</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='to identifier id'>to</span><span class='lparen token'>(</span><span class='Movie constant id'>Movie</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='relationship identifier id'>relationship</span><span class='lparen token'>(</span><span class='Role constant id'>Role</span><span class='rparen token'>)</span>
      <span class='end end kw'>end</span>
</pre>
<h3>Finding Relationships</h3>
<p>
The Neo4j::NodeMixin#relationships method can be used to find incoming or
outgoing relationship objects. Example of listing all types of outgoing
(default) relationship objects (of depth one) from the me node.
</p>
<pre class="code">
  <span class='me identifier id'>me</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='dot token'>.</span><span class='each identifier id'>each</span> <span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='rel identifier id'>rel</span><span class='bitor op'>|</span> <span class='dot3 op'>...</span> <span class='rbrace token'>}</span>
</pre>
<p>
If we instead want to list the nodes that those relationships points to
then the nodes method can be used.
</p>
<pre class="code">
  <span class='me identifier id'>me</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='dot token'>.</span><span class='nodes identifier id'>nodes</span><span class='dot token'>.</span><span class='each identifier id'>each</span> <span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='rel identifier id'>rel</span><span class='bitor op'>|</span> <span class='dot3 op'>...</span> <span class='rbrace token'>}</span>
</pre>
<p>
Listing all incoming relationship obejcts of any relationship type:
</p>
<pre class="code">
  <span class='me identifier id'>me</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='dot token'>.</span><span class='incoming identifier id'>incoming</span><span class='dot token'>.</span><span class='each identifier id'>each</span> <span class='lbrace token'>{</span> <span class='dot3 op'>...</span> <span class='rbrace token'>}</span>
</pre>
<p>
Listing both incoming and outgoing relationship object of a specific type:
</p>
<pre class="code">
  <span class='me identifier id'>me</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='dot token'>.</span><span class='both identifier id'>both</span><span class='lparen token'>(</span><span class='symbol val'>:friends</span><span class='rparen token'>)</span> <span class='lbrace token'>{</span> <span class='rbrace token'>}</span>
</pre>
<p>
Finding one outgoing relationship of a specific type and node (you)
</p>
<pre class="code">
  <span class='me identifier id'>me</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='dot token'>.</span><span class='outgoing identifier id'>outgoing</span><span class='lparen token'>(</span><span class='symbol val'>:friends</span><span class='rparen token'>)</span><span class='lbrack token'>[</span><span class='you identifier id'>you</span><span class='rbrack token'>]</span> <span class='comment val'># =&gt; [#&lt;Neo4j::RelationshipMixin:0x134ae32]</span>
</pre>
<h4>Finding Relationships Example</h4>
<p>
Example, given we have the two nodes with a relationship between them:
</p>
<pre class="code">
  <span class='n1 identifier id'>n1</span> <span class='assign token'>=</span> <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
  <span class='n2 identifier id'>n2</span> <span class='assign token'>=</span> <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='new identifier id'>new</span>

  <span class='n1 identifier id'>n1</span><span class='dot token'>.</span><span class='friends identifier id'>friends</span> <span class='lshft op'>&lt;&lt;</span> <span class='n2 identifier id'>n2</span>
</pre>
<p>
Then we can find all incoming and outgoing relationships like this:
</p>
<pre class="code">
  <span class='n1 identifier id'>n1</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='dot token'>.</span><span class='to_a identifier id'>to_a</span> <span class='comment val'># =&gt; [#&lt;Neo4j::RelationshipMixin:0x134ae32]</span>
</pre>
<p>
A Neo4j::RelationshipMixin object represents a relationship between two
nodes.
</p>
<pre class="code">
  <span class='n1 identifier id'>n1</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='start_node identifier id'>start_node</span> <span class='comment val'># =&gt; n1</span>
  <span class='n1 identifier id'>n1</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='end_node identifier id'>end_node</span> <span class='comment val'># =&gt; n2</span>
</pre>
<p>
A RelationshipMixin contains the relationship type which connects it
connects two nodes with, example:
</p>
<pre class="code">
  <span class='n1 identifier id'>n1</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='relationship_type identifier id'>relationship_type</span> <span class='comment val'># =&gt; :friends</span>
</pre>
<p>
Relationships can also have properties just like a node (NodeMixin).
</p>
<h3>Finding outgoing and incoming relationships</h3>
<p>
If we are only interested in all incoming nodes, we can do
</p>
<pre class="code">
  <span class='n2 identifier id'>n2</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='dot token'>.</span><span class='incoming identifier id'>incoming</span> <span class='comment val'># =&gt; [#&lt;Neo4j::RelationshipMixin:0x134ae32]</span>
</pre>
<p>
Or outgoing:
</p>
<pre class="code">
  <span class='n1 identifier id'>n1</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='dot token'>.</span><span class='outgoing identifier id'>outgoing</span> <span class='comment val'># =&gt; [#&lt;Neo4j::RelationshipMixin:0x134aea2]</span>
</pre>
<p>
To find a specific relationship use the [] operator:
</p>
<pre class="code">
  <span class='n1 identifier id'>n1</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='dot token'>.</span><span class='outgoing identifier id'>outgoing</span><span class='lbrack token'>[</span><span class='n2 identifier id'>n2</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='comment val'>#&lt;Neo4j::RelationshipMixin:0x134aea2</span>
</pre>
<p>
Or which is better performance wise (since only friends relationships are
being traversed):
</p>
<pre class="code">
  <span class='n1 identifier id'>n1</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='dot token'>.</span><span class='outgoing identifier id'>outgoing</span><span class='lparen token'>(</span><span class='symbol val'>:friends</span><span class='rparen token'>)</span><span class='lbrack token'>[</span><span class='n2 identifier id'>n2</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='comment val'>#&lt;Neo4j::RelationshipMixin:0x134aea2</span>
</pre>
<h3>Deleting a relationship</h3>
<p>
Use the Neo4j::RelationshipMixin#delete method. For example, to delete the
relationship between n1 and n2 from the example above:
</p>
<pre class="code">
    <span class='n1 identifier id'>n1</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='dot token'>.</span><span class='outgoing identifier id'>outgoing</span><span class='lparen token'>(</span><span class='symbol val'>:friends</span><span class='rparen token'>)</span><span class='lbrack token'>[</span><span class='n2 identifier id'>n2</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='delete identifier id'>delete</span>
</pre>
<h3>Finding nodes in a relationship</h3>
<p>
If you do not want those relationship object but instead want the nodes you
can use the &#8216;nodes&#8217; method in the Neo4j::RelationshipMixin
object.
</p>
<p>
For example:
</p>
<pre class="code">
  <span class='n2 identifier id'>n2</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='dot token'>.</span><span class='incoming identifier id'>incoming</span><span class='dot token'>.</span><span class='nodes identifier id'>nodes</span> <span class='comment val'># =&gt; [n1]</span>
</pre>
<h3>Finding outgoing/incoming nodes of a specific relationship type</h3>
<p>
Let say we want to find who has my phone number and who consider me as a
friend
</p>
<pre class="code">
  <span class='comment val'># who has my phone numbers</span>
  <span class='me identifier id'>me</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='dot token'>.</span><span class='incoming identifier id'>incoming</span><span class='lparen token'>(</span><span class='symbol val'>:phone_numbers</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='nodes identifier id'>nodes</span> <span class='comment val'># =&gt; people with my phone numbers</span>

  <span class='comment val'># who consider me as a friend</span>
  <span class='me identifier id'>me</span><span class='dot token'>.</span><span class='relationships identifier id'>relationships</span><span class='dot token'>.</span><span class='incoming identifier id'>incoming</span><span class='lparen token'>(</span><span class='symbol val'>:friends</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='nodes identifier id'>nodes</span> <span class='comment val'># =&gt; people with a friend relationship to me</span>
</pre>
<p>
Remember that relationships are not symmetrical. Notice there is also a
otherway of finding nodes, see the Neo4j::NodeMixin#traverse method below.
</p>
<h3>Transactions</h3>
<p>
All operations that work with the node space (even read operations) must be
wrapped in a transaction. For example all get, set and find operations will
start a new transaction if none is already not runnig (for that thread).
</p>
<p>
If you want to perform a set of operation in a single transaction, use the
Neo4j::Transaction.run method:
</p>
<p>
Example
</p>
<pre class="code">
  <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='Transaction constant id'>Transaction</span><span class='dot token'>.</span><span class='run identifier id'>run</span> <span class='lbrace token'>{</span>
    <span class='node1 identifier id'>node1</span><span class='dot token'>.</span><span class='foo identifier id'>foo</span> <span class='assign token'>=</span> <span class='string val'>&quot;value&quot;</span>
    <span class='node2 identifier id'>node2</span><span class='dot token'>.</span><span class='bar identifier id'>bar</span> <span class='assign token'>=</span> <span class='string val'>&quot;hi&quot;</span>
  <span class='rbrace token'>}</span>
</pre>
<p>
There is also a auto commit feature available which is enabled by requiring
&#8216;neo4j/auto_tx&#8217; instead of &#8216;neo4j&#8217;, see the three
minutes tutorial above.
</p>
<h4>Rollback</h4>
<p>
Neo4j support rollbacks on transaction. Example: Example:
</p>
<pre class="code">
  <span class='include identifier id'>include</span> <span class='string val'>'neo4j'</span>

  <span class='node identifier id'>node</span> <span class='assign token'>=</span> <span class='MyNode constant id'>MyNode</span><span class='dot token'>.</span><span class='new identifier id'>new</span>

  <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='Transaction constant id'>Transaction</span><span class='dot token'>.</span><span class='run identifier id'>run</span> <span class='lbrace token'>{</span> <span class='bitor op'>|</span><span class='t identifier id'>t</span><span class='bitor op'>|</span>
     <span class='node identifier id'>node</span><span class='dot token'>.</span><span class='foo identifier id'>foo</span> <span class='assign token'>=</span> <span class='string val'>&quot;hej&quot;</span>
     <span class='comment val'># something failed so we signal for a failure</span>
     <span class='t identifier id'>t</span><span class='dot token'>.</span><span class='failure identifier id'>failure</span> <span class='comment val'># will cause a rollback, node.foo will not be updated</span>
  <span class='rbrace token'>}</span>
</pre>
<p>
You can also run it without a block, like this:
</p>
<pre class="code">
   <span class='transaction identifier id'>transaction</span> <span class='assign token'>=</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='Transaction constant id'>Transaction</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
   <span class='transaction identifier id'>transaction</span><span class='dot token'>.</span><span class='start identifier id'>start</span>
   <span class='comment val'># do something</span>
   <span class='transaction identifier id'>transaction</span><span class='dot token'>.</span><span class='finish identifier id'>finish</span>
</pre>
<h3>Indexing</h3>
<p>
Properties and relationships which should be indexed by lucene can be
specified by the index class method. For example to index the proeprties
foo and bar
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='SomeNode constant id'>SomeNode</span>
     <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='NodeMixin constant id'>NodeMixin</span>
     <span class='property identifier id'>property</span> <span class='symbol val'>:foo</span><span class='comma token'>,</span> <span class='symbol val'>:bar</span>
     <span class='index identifier id'>index</span> <span class='symbol val'>:foo</span><span class='comma token'>,</span> <span class='symbol val'>:bar</span>
  <span class='end end kw'>end</span>
</pre>
<p>
Everytime a node of type SomeNode (or a subclass) is create, deleted or
updated the lucene index of will be updated.
</p>
<h3>Reindexing</h3>
<p>
Sometimes it&#8217;s neccessarly to change the index of a class after alot
of node instances already have been created. To delete an index use the
class method &#8216;remove_index&#8217; To update an index use the class
method &#8216;update_index&#8217; which will update all already created
nodes in the neo database.
</p>
<p>
Example
</p>
<pre class="code">
  <span class='require identifier id'>require</span> <span class='string val'>'neo4j'</span>
  <span class='require identifier id'>require</span> <span class='string val'>'neo4j/extensions/tx_tracker'</span> <span class='comment val'># needed for the update_index method</span>
  <span class='class class kw'>class</span> <span class='Person constant id'>Person</span>
    <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span>
    <span class='property identifier id'>property</span> <span class='symbol val'>:name</span><span class='comma token'>,</span> <span class='symbol val'>:age</span><span class='comma token'>,</span> <span class='symbol val'>:phone</span>
    <span class='index identifier id'>index</span> <span class='symbol val'>:name</span><span class='comma token'>,</span> <span class='symbol val'>:age</span>
  <span class='end end kw'>end</span>

  <span class='p1 identifier id'>p1</span> <span class='assign token'>=</span> <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='new identifier id'>new</span> <span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='n identifier id'>n</span><span class='bitor op'>|</span> <span class='n identifier id'>n</span><span class='dot token'>.</span><span class='name identifier id'>name</span> <span class='assign token'>=</span> <span class='string val'>'andreas'</span><span class='semicolon token'>;</span> <span class='n identifier id'>n</span><span class='dot token'>.</span><span class='phone identifier id'>phone</span> <span class='assign token'>=</span> <span class='integer val'>123</span><span class='rbrace token'>}</span>
  <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='find identifier id'>find</span> <span class='lparen token'>(</span><span class='symbol val'>:name</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'andreas'</span><span class='rparen token'>)</span> <span class='comment val'># =&gt; [p1]</span>
  <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='find identifier id'>find</span> <span class='lparen token'>(</span><span class='symbol val'>:phone</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='integer val'>123</span><span class='rparen token'>)</span> <span class='comment val'># =&gt; []</span>

  <span class='comment val'># change index and reindex all person nodes already created in the neo database.</span>
  <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='remove_index identifier id'>remove_index</span> <span class='symbol val'>:name</span>
  <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='index identifier id'>index</span> <span class='symbol val'>:phone</span>  <span class='comment val'># add an index on phone</span>
  <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='update_index identifier id'>update_index</span>

  <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='find identifier id'>find</span> <span class='lparen token'>(</span><span class='symbol val'>:name</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'andreas'</span><span class='rparen token'>)</span> <span class='comment val'># =&gt; []</span>
  <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='find identifier id'>find</span> <span class='lparen token'>(</span><span class='symbol val'>:phone</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='integer val'>123</span><span class='rparen token'>)</span> <span class='comment val'># =&gt; [p1]</span>
</pre>
<p>
In order to use the update_index method you must include the reindexer
neo4j.rb extension. This extensions will keep a relationship to each
created node so that it later can recreate the index by traversing those
relationships.
</p>
<h3>Updating Lucene Index</h3>
<p>
The lucene index will be updated after the transaction commits. It is not
possible to query for something that has been created inside the same
transaction as where the query is performed.
</p>
<h3>Quering (using lucene)</h3>
<p>
You can declare properties to be indexed by lucene by the index method:
</p>
<p>
Example
</p>
<pre class="code">
      <span class='class class kw'>class</span> <span class='Person constant id'>Person</span>
        <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='NodeMixin constant id'>NodeMixin</span>
        <span class='property identifier id'>property</span> <span class='symbol val'>:name</span><span class='comma token'>,</span> <span class='symbol val'>:age</span>
        <span class='index identifier id'>index</span> <span class='symbol val'>:name</span><span class='comma token'>,</span> <span class='symbol val'>:age</span>
      <span class='end end kw'>end</span>

      <span class='node identifier id'>node</span> <span class='assign token'>=</span> <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
      <span class='node identifier id'>node</span><span class='dot token'>.</span><span class='name identifier id'>name</span> <span class='assign token'>=</span> <span class='string val'>'foo'</span>
      <span class='node identifier id'>node</span><span class='dot token'>.</span><span class='age identifier id'>age</span>  <span class='assign token'>=</span> <span class='integer val'>42</span>

      <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='find identifier id'>find</span><span class='lparen token'>(</span><span class='symbol val'>:name</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'foo'</span><span class='comma token'>,</span> <span class='symbol val'>:age</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='integer val'>42</span><span class='rparen token'>)</span> <span class='comment val'># =&gt; [node]</span>
</pre>
<p>
The query parameter (like property on a Neo4j::NodeMixin) can be of type
String, Fixnum, Float, boolean or Range. The query above can also be
written in a lucene query DSL:
</p>
<pre class="code">
      <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='find identifier id'>find</span><span class='lbrace token'>{</span><span class='lparen token'>(</span><span class='name identifier id'>name</span> <span class='eq op'>==</span><span class='string val'>'foo'</span><span class='rparen token'>)</span> <span class='bitand op'>&amp;</span> <span class='lparen token'>(</span><span class='age identifier id'>age</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='integer val'>42</span><span class='rparen token'>)</span><span class='rbrace token'>}</span> <span class='comment val'># =&gt; [node]</span>
</pre>
<p>
Or lucene query language:
</p>
<pre class="code">
     <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='find identifier id'>find</span><span class='lparen token'>(</span><span class='string val'>&quot;name:foo AND age:42&quot;</span><span class='rparen token'>)</span>
</pre>
<p>
For more information see:
http://lucene.apache.org/java/2_4_0/queryparsersyntax.html or the lucene
module above.
</p>
<h3>Indexing and Property Types</h3>
<p>
In order to use range querie on numbers the property types must be
converted. This is done by using the :type optional parameter:
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='Person constant id'>Person</span>
    <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='NodeMixin constant id'>NodeMixin</span>
    <span class='property identifier id'>property</span> <span class='symbol val'>:name</span><span class='comma token'>,</span> <span class='symbol val'>:age</span>
    <span class='index identifier id'>index</span> <span class='symbol val'>:age</span><span class='comma token'>,</span> <span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='Fixnum constant id'>Fixnum</span>
  <span class='end end kw'>end</span>
</pre>
<p>
By using :type =&gt; Fixnum the age will be padded with &#8216;0&#8217;s
(lucene only support string comparsion).
</p>
<p>
Example, if the :type =&gt; Fixnum was not specified then
</p>
<pre class="code">
  <span class='p identifier id'>p</span> <span class='assign token'>=</span> <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='new identifier id'>new</span> <span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='n identifier id'>n</span><span class='bitor op'>|</span> <span class='n identifier id'>n</span><span class='dot token'>.</span><span class='age identifier id'>age</span> <span class='assign token'>=</span> <span class='integer val'>100</span> <span class='rbrace token'>}</span>
  <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='find identifier id'>find</span><span class='lparen token'>(</span><span class='symbol val'>:age</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='integer val'>0</span><span class='dot2 op'>..</span><span class='integer val'>8</span><span class='rparen token'>)</span> <span class='comment val'># =&gt; [p]</span>
</pre>
<h3>Indexing and Quering Relationships</h3>
<p>
The Neo4j::NodeMixin#index method can be used to index relationships to
other classes.
</p>
<p>
Example, let say we have to classes, Customer and Orders:
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='Customer constant id'>Customer</span>
    <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='NodeMixin constant id'>NodeMixin</span>

    <span class='property identifier id'>property</span> <span class='symbol val'>:name</span>

    <span class='comment val'># specifies outgoing relationships to Order</span>
    <span class='has_n identifier id'>has_n</span><span class='lparen token'>(</span><span class='symbol val'>:orders</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='to identifier id'>to</span><span class='lparen token'>(</span><span class='Order constant id'>Order</span><span class='rparen token'>)</span>

    <span class='comment val'># create an index on customer--&gt;order#total_cost</span>
    <span class='index identifier id'>index</span> <span class='string val'>&quot;orders.total_cost&quot;</span>
  <span class='end end kw'>end</span>

  <span class='class class kw'>class</span> <span class='Order constant id'>Order</span>
    <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='NodeMixin constant id'>NodeMixin</span>

    <span class='property identifier id'>property</span> <span class='symbol val'>:total_cost</span>

    <span class='comment val'># specifies one incoming relationship from Customer</span>
    <span class='has_one identifier id'>has_one</span><span class='lparen token'>(</span><span class='symbol val'>:customer</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='from identifier id'>from</span><span class='lparen token'>(</span><span class='Customer constant id'>Customer</span><span class='comma token'>,</span> <span class='symbol val'>:orders</span><span class='rparen token'>)</span>

    <span class='comment val'># create an index on the order&lt;--customer#name relationship</span>
    <span class='index identifier id'>index</span> <span class='string val'>&quot;customer.name&quot;</span>
  <span class='end end kw'>end</span>
</pre>
<p>
Notice that we can index both incoming and outgoing relationships.
</p>
<p>
Let&#8217;s create a customer and one order for that customer
</p>
<pre class="code">
    <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='Transaction constant id'>Transaction</span><span class='dot token'>.</span><span class='run identifier id'>run</span> <span class='do do kw'>do</span>
      <span class='cust identifier id'>cust</span> <span class='assign token'>=</span> <span class='Customer constant id'>Customer</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
      <span class='order identifier id'>order</span> <span class='assign token'>=</span> <span class='Order constant id'>Order</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
      <span class='cust identifier id'>cust</span><span class='dot token'>.</span><span class='name identifier id'>name</span> <span class='assign token'>=</span> <span class='string val'>&quot;kalle&quot;</span>
      <span class='order identifier id'>order</span><span class='dot token'>.</span><span class='total_cost identifier id'>total_cost</span> <span class='assign token'>=</span> <span class='string val'>&quot;1000&quot;</span>

      <span class='cust identifier id'>cust</span><span class='dot token'>.</span><span class='orders identifier id'>orders</span> <span class='lshft op'>&lt;&lt;</span> <span class='order identifier id'>order</span>
    <span class='end end kw'>end</span>
</pre>
<p>
Now we can find both Orders with a total cost between 500 and 2000 and
Customers with name &#8216;kalle&#8217; using lucene
</p>
<p>
Example:
</p>
<pre class="code">
   <span class='customers identifier id'>customers</span> <span class='assign token'>=</span> <span class='Customer constant id'>Customer</span><span class='dot token'>.</span><span class='find identifier id'>find</span><span class='lparen token'>(</span><span class='string val'>'orders.total_cost'</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='float val'>500</span><span class='dot2 op'>..</span><span class='integer val'>2000</span><span class='comma token'>,</span> <span class='string val'>'name'</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'kalle'</span><span class='rparen token'>)</span>
</pre>
<p>
Or also possible from the other way:
</p>
<pre class="code">
   <span class='orders identifier id'>orders</span> <span class='assign token'>=</span> <span class='Order constant id'>Order</span><span class='dot token'>.</span><span class='find identifier id'>find</span><span class='lparen token'>(</span><span class='string val'>'total_cost'</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='float val'>500</span><span class='dot2 op'>..</span><span class='integer val'>2000</span><span class='comma token'>,</span> <span class='string val'>'customer.name'</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'kalle'</span><span class='rparen token'>)</span>
</pre>
<h3>Full text search</h3>
<p>
Neo4j supports full text search by setting the tokenized property to true
on an index. (see JavaDoc for
org.apache.lucene.document.Field.Index.ANALYZED).
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='Comment constant id'>Comment</span>
    <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='NodeMixin constant id'>NodeMixin</span>

    <span class='property identifier id'>property</span> <span class='symbol val'>:comment</span>
    <span class='index identifier id'>index</span> <span class='comment identifier id'>comment</span><span class='comma token'>,</span> <span class='symbol val'>:tokenized</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='true true kw'>true</span>
  <span class='end end kw'>end</span>
</pre>
<h3>Unmarshalling</h3>
<p>
The neo module will automatically unmarshalling nodes to the correct ruby
class. It does this by reading the classname property and loading that ruby
class with that node.
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='Person constant id'>Person</span>
    <span class='include identifier id'>include</span> <span class='Neo constant id'>Neo</span><span class='colon2 op'>::</span><span class='Node constant id'>Node</span>

    <span class='def def kw'>def</span> <span class='hello identifier id'>hello</span>
    <span class='end end kw'>end</span>
  <span class='end end kw'>end</span>

  <span class='f1 identifier id'>f1</span> <span class='assign token'>=</span> <span class='Person constant id'>Person</span><span class='dot token'>.</span><span class='new identifier id'>new</span> <span class='lbrace token'>{</span><span class='rbrace token'>}</span>

  <span class='comment val'># load the class again</span>
  <span class='f2 identifier id'>f2</span> <span class='assign token'>=</span> <span class='Neo4j constant id'>Neo4j</span><span class='dot token'>.</span><span class='load identifier id'>load</span><span class='lparen token'>(</span><span class='foo identifier id'>foo</span><span class='dot token'>.</span><span class='neo_node_id identifier id'>neo_node_id</span><span class='rparen token'>)</span>

  <span class='comment val'># f2 will now be new instance of Person, but will be == f1</span>
  <span class='f1 identifier id'>f1</span> <span class='eq op'>==</span> <span class='f2 identifier id'>f2</span> <span class='comment val'># =&gt; true</span>
</pre>
<h3>Reference node</h3>
<p>
There is one node that can always be find - the reference node,
Neo4j::ReferenceNode. Example:
</p>
<pre class="code">
    <span class='Neo4j constant id'>Neo4j</span><span class='dot token'>.</span><span class='ref_node identifier id'>ref_node</span>
</pre>
<p>
This node has a relationship to all created nodes. You can add
relationships from this node to your nodes.
</p>
<h3>Performance Issues</h3>
<p>
It is recommended to wrap several Neo4j operations including read
operations in a singel transaction if possible for better performance.
Updating a lucene index can be slow. A solution to this is to keep the
index in memory instead of on disk.
</p>
<p>
I&#8217;m currently looking at how to scale neo4j.rb by a simple
master-slave cluster by using REST, see the REST extension below.
</p>
<h2>Extensions: Replication</h2>
<p>
There is an experimental extension that makes it possible to replicate an
neo4j database to another machine. For example how to use it see the
test/replication/test_master.rb and test_slave.rb It has only been tested
to work with a very simple node space.
</p>
<h2>Extension: REST</h2>
<p>
There is an REST extension to Neo4j.rb. It requires the following gems
</p>
<pre class="code">
 <span class='mult op'>*</span> <span class='Sinatra constant id'>Sinatra</span> <span class='gt op'>&gt;</span> <span class='integer val'>0</span><span class='float val'>.9.2</span> <span class='lparen token'>(</span><span class='I constant id'>I</span> <span class='can identifier id'>can</span> <span class='only identifier id'>only</span> <span class='get identifier id'>get</span> <span class='the identifier id'>the</span> <span class='example identifier id'>example</span><span class='dot token'>.</span><span class='rb identifier id'>rb</span> <span class='running identifier id'>running</span> <span class='by identifier id'>by</span> <span class='building identifier id'>building</span> <span class='from identifier id'>from</span> <span class='the identifier id'>the</span> <span class='latest identifier id'>latest</span> <span class='from identifier id'>from</span> <span class='github identifier id'>github</span><span class='rparen token'>)</span><span class='dot token'>.</span>
 <span class='mult op'>*</span> <span class='Rack constant id'>Rack</span> <span class='geq op'>&gt;=</span> <span class='float val'>1.0</span>
 <span class='mult op'>*</span> <span class='json identifier id'>json</span><span class='minus op'>-</span><span class='jruby identifier id'>jruby</span> <span class='geq op'>&gt;=</span> <span class='float val'>1.1</span><span class='integer val'>.6</span>
</pre>
<p>
For RSpec testing it also needs:
</p>
<pre class="code">
 <span class='mult op'>*</span> <span class='rack identifier id'>rack</span><span class='minus op'>-</span><span class='test identifier id'>test</span>
</pre>
<p>
For more information see the test/rest/example.rb or the examples/admin or
Neo4j::RestMixin.
</p>
<h2>Ruby on Rails with Neo4j.rb</h2>
<p>
Neo4j.rb does work nicely with R&amp;R. There are two ways to use neo4j.rb
with rails - embedded or accessing it via REST.
</p>
<p>
The following example demonstrate how to embed neo4j.rb with rails. It has
been verified to work on neo4j.rb 0.2.1 rail 2.2.2, JRuby 1.1.6 RC1,
Glassfish 0.9.1.
</p>
<h3>Configuration</h3>
<h4>Install Neo4j.rb</h4>
<pre class="code">
  <span class='gem identifier id'>gem</span> <span class='install identifier id'>install</span> <span class='neo4j identifier id'>neo4j</span>
</pre>
<h4>Install rails</h4>
<pre class="code">
  <span class='gem identifier id'>gem</span> <span class='install identifier id'>install</span> <span class='rails identifier id'>rails</span>
</pre>
<h4>Create a rails project, movies</h4>
<pre class="code">
  <span class='rails identifier id'>rails</span> <span class='movies identifier id'>movies</span>
</pre>
<h4>Config rails</h4>
<p>
Config rails to use Neo4j.rb instead of ActiveRecord, edit
movies/config/environment.rb environment.rb:
</p>
<pre class="code">
  <span class='config identifier id'>config</span><span class='dot token'>.</span><span class='frameworks identifier id'>frameworks</span> <span class='opasgn op'>-=</span> <span class='lbrack token'>[</span> <span class='symbol val'>:active_record</span> <span class='rbrack token'>]</span> <span class='comment val'>#, :active_resource, :action_mailer ]</span>
  <span class='config identifier id'>config</span><span class='dot token'>.</span><span class='gem identifier id'>gem</span> <span class='string val'>&quot;neo4j&quot;</span><span class='comma token'>,</span> <span class='symbol val'>:version</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>&quot;0.0.7&quot;</span>
</pre>
<h4>Create Models</h4>
<p>
Create model in movies/app/models actor.rb:
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='Role constant id'>Role</span>
    <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='RelationshipMixin constant id'>RelationshipMixin</span>
    <span class='property identifier id'>property</span> <span class='symbol val'>:title</span><span class='comma token'>,</span> <span class='symbol val'>:character</span>
  <span class='end end kw'>end</span>

  <span class='class class kw'>class</span> <span class='Actor constant id'>Actor</span>
    <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='NodeMixin constant id'>NodeMixin</span>
    <span class='property identifier id'>property</span> <span class='symbol val'>:name</span><span class='comma token'>,</span> <span class='symbol val'>:phone</span><span class='comma token'>,</span> <span class='symbol val'>:salary</span>
    <span class='has_n identifier id'>has_n</span><span class='lparen token'>(</span><span class='symbol val'>:acted_in</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='to identifier id'>to</span><span class='lparen token'>(</span><span class='Movie constant id'>Movie</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='relationship identifier id'>relationship</span><span class='lparen token'>(</span><span class='Role constant id'>Role</span><span class='rparen token'>)</span>
    <span class='index identifier id'>index</span> <span class='symbol val'>:name</span>
  <span class='end end kw'>end</span>
</pre>
<p>
movie.rb:
</p>
<pre class="code">
  <span class='class class kw'>class</span> <span class='Movie constant id'>Movie</span>
    <span class='include identifier id'>include</span> <span class='Neo4j constant id'>Neo4j</span><span class='colon2 op'>::</span><span class='NodeMixin constant id'>NodeMixin</span>
    <span class='property identifier id'>property</span> <span class='symbol val'>:title</span>
    <span class='property identifier id'>property</span> <span class='symbol val'>:year</span>

    <span class='comment val'># defines a method for traversing incoming acted_in relationships from Actor</span>
    <span class='has_n identifier id'>has_n</span><span class='lparen token'>(</span><span class='symbol val'>:actors</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='from identifier id'>from</span><span class='lparen token'>(</span><span class='Actor constant id'>Actor</span><span class='comma token'>,</span> <span class='symbol val'>:acted_in</span><span class='rparen token'>)</span>
  <span class='end end kw'>end</span>
</pre>
<h4>Create RESTful routes</h4>
<p>
Edit the config/routes.rb file
</p>
<pre class="code">
  <span class='ActionController constant id'>ActionController</span><span class='colon2 op'>::</span><span class='Routing constant id'>Routing</span><span class='colon2 op'>::</span><span class='Routes constant id'>Routes</span><span class='dot token'>.</span><span class='draw identifier id'>draw</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='map identifier id'>map</span><span class='bitor op'>|</span>
     <span class='map identifier id'>map</span><span class='dot token'>.</span><span class='resources identifier id'>resources</span> <span class='symbol val'>:actors</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='actor identifier id'>actor</span><span class='bitor op'>|</span>
      <span class='actor identifier id'>actor</span><span class='dot token'>.</span><span class='resources identifier id'>resources</span> <span class='symbol val'>:acted_in</span>
      <span class='actor identifier id'>actor</span><span class='dot token'>.</span><span class='resource identifier id'>resource</span> <span class='symbol val'>:movies</span><span class='comma token'>,</span> <span class='symbol val'>:controller</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'acted_in'</span>
     <span class='end end kw'>end</span>
</pre>
<h4>Create Controllers</h4>
<p>
Add the following controllers in app/controllers
</p>
<p>
actors_controller.rb:
</p>
<pre class="code">
    <span class='class class kw'>class</span> <span class='ActorsController constant id'>ActorsController</span> <span class='lt op'>&lt;</span> <span class='ApplicationController constant id'>ApplicationController</span>
      <span class='before_filter identifier id'>before_filter</span> <span class='symbol val'>:find_actor</span><span class='comma token'>,</span> <span class='symbol val'>:only</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='lbrack token'>[</span><span class='symbol val'>:show</span><span class='comma token'>,</span> <span class='symbol val'>:edit</span><span class='comma token'>,</span> <span class='symbol val'>:update</span><span class='comma token'>,</span> <span class='symbol val'>:destroy</span><span class='rbrack token'>]</span>

      <span class='def def kw'>def</span> <span class='index identifier id'>index</span>
        <span class='@actors ivar id'>@actors</span> <span class='assign token'>=</span> <span class='Actor constant id'>Actor</span><span class='dot token'>.</span><span class='all identifier id'>all</span><span class='dot token'>.</span><span class='nodes identifier id'>nodes</span>
      <span class='end end kw'>end</span>

      <span class='def def kw'>def</span> <span class='create identifier id'>create</span>
        <span class='@actor ivar id'>@actor</span> <span class='assign token'>=</span> <span class='Actor constant id'>Actor</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
        <span class='@actor ivar id'>@actor</span><span class='dot token'>.</span><span class='update identifier id'>update</span><span class='lparen token'>(</span><span class='params identifier id'>params</span><span class='lbrack token'>[</span><span class='symbol val'>:actor</span><span class='rbrack token'>]</span><span class='rparen token'>)</span>
        <span class='flash identifier id'>flash</span><span class='lbrack token'>[</span><span class='symbol val'>:notice</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='string val'>'Actor was successfully created.'</span>
        <span class='redirect_to identifier id'>redirect_to</span><span class='lparen token'>(</span><span class='@actor ivar id'>@actor</span><span class='rparen token'>)</span>
      <span class='end end kw'>end</span>

      <span class='def def kw'>def</span> <span class='update identifier id'>update</span>
        <span class='@actor ivar id'>@actor</span><span class='dot token'>.</span><span class='update identifier id'>update</span><span class='lparen token'>(</span><span class='params identifier id'>params</span><span class='lbrack token'>[</span><span class='symbol val'>:actor</span><span class='rbrack token'>]</span><span class='rparen token'>)</span>
        <span class='flash identifier id'>flash</span><span class='lbrack token'>[</span><span class='symbol val'>:notice</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='string val'>'Actor was successfully updated.'</span>
        <span class='redirect_to identifier id'>redirect_to</span><span class='lparen token'>(</span><span class='@actor ivar id'>@actor</span><span class='rparen token'>)</span>
      <span class='end end kw'>end</span>

      <span class='def def kw'>def</span> <span class='destroy identifier id'>destroy</span>
        <span class='@actor ivar id'>@actor</span><span class='dot token'>.</span><span class='delete identifier id'>delete</span>
        <span class='redirect_to identifier id'>redirect_to</span><span class='lparen token'>(</span><span class='actors_url identifier id'>actors_url</span><span class='rparen token'>)</span>
      <span class='end end kw'>end</span>

      <span class='def def kw'>def</span> <span class='edit identifier id'>edit</span>
      <span class='end end kw'>end</span>

      <span class='def def kw'>def</span> <span class='show identifier id'>show</span>
      <span class='end end kw'>end</span>

      <span class='def def kw'>def</span> <span class='new identifier id'>new</span>
        <span class='@actor ivar id'>@actor</span> <span class='assign token'>=</span> <span class='Actor constant id'>Actor</span><span class='dot token'>.</span><span class='value_object identifier id'>value_object</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
      <span class='end end kw'>end</span>

      <span class='private identifier id'>private</span>
      <span class='def def kw'>def</span> <span class='find_actor identifier id'>find_actor</span>
        <span class='@actor ivar id'>@actor</span> <span class='assign token'>=</span> <span class='Neo4j constant id'>Neo4j</span><span class='dot token'>.</span><span class='load identifier id'>load</span><span class='lparen token'>(</span><span class='params identifier id'>params</span><span class='lbrack token'>[</span><span class='symbol val'>:id</span><span class='rbrack token'>]</span><span class='rparen token'>)</span>
      <span class='end end kw'>end</span>
    <span class='end end kw'>end</span>
</pre>
<p>
acted_in_controller.rb:
</p>
<pre class="code">
    <span class='class class kw'>class</span> <span class='ActedInController constant id'>ActedInController</span> <span class='lt op'>&lt;</span> <span class='ApplicationController constant id'>ApplicationController</span>
      <span class='def def kw'>def</span> <span class='index identifier id'>index</span>
        <span class='@actor ivar id'>@actor</span> <span class='assign token'>=</span> <span class='Neo4j constant id'>Neo4j</span><span class='dot token'>.</span><span class='load identifier id'>load</span><span class='lparen token'>(</span><span class='params identifier id'>params</span><span class='lbrack token'>[</span><span class='symbol val'>:actor_id</span><span class='rbrack token'>]</span><span class='rparen token'>)</span>
        <span class='@movies ivar id'>@movies</span> <span class='assign token'>=</span> <span class='@actor ivar id'>@actor</span><span class='dot token'>.</span><span class='acted_in identifier id'>acted_in</span><span class='dot token'>.</span><span class='nodes identifier id'>nodes</span>
      <span class='end end kw'>end</span>

      <span class='def def kw'>def</span> <span class='create identifier id'>create</span>
        <span class='@actor ivar id'>@actor</span> <span class='assign token'>=</span> <span class='Neo4j constant id'>Neo4j</span><span class='dot token'>.</span><span class='load identifier id'>load</span><span class='lparen token'>(</span><span class='params identifier id'>params</span><span class='lbrack token'>[</span><span class='symbol val'>:actor_id</span><span class='rbrack token'>]</span><span class='rparen token'>)</span>
        <span class='@movie ivar id'>@movie</span> <span class='assign token'>=</span> <span class='Movie constant id'>Movie</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
        <span class='@movie ivar id'>@movie</span><span class='dot token'>.</span><span class='update identifier id'>update</span><span class='lparen token'>(</span><span class='params identifier id'>params</span><span class='lbrack token'>[</span><span class='symbol val'>:movie</span><span class='rbrack token'>]</span><span class='rparen token'>)</span>
        <span class='@actor ivar id'>@actor</span><span class='dot token'>.</span><span class='acted_in identifier id'>acted_in</span> <span class='lshft op'>&lt;&lt;</span> <span class='@movie ivar id'>@movie</span>
        <span class='flash identifier id'>flash</span><span class='lbrack token'>[</span><span class='symbol val'>:notice</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='string val'>'Movie was successfully created.'</span>
        <span class='redirect_to identifier id'>redirect_to</span><span class='lparen token'>(</span><span class='@actor ivar id'>@actor</span><span class='rparen token'>)</span>
      <span class='end end kw'>end</span>

      <span class='def def kw'>def</span> <span class='update identifier id'>update</span>
        <span class='@actor ivar id'>@actor</span> <span class='assign token'>=</span> <span class='Neo4j constant id'>Neo4j</span><span class='dot token'>.</span><span class='load identifier id'>load</span><span class='lparen token'>(</span><span class='params identifier id'>params</span><span class='lbrack token'>[</span><span class='symbol val'>:actor_id</span><span class='rbrack token'>]</span><span class='rparen token'>)</span>
        <span class='@movie ivar id'>@movie</span> <span class='assign token'>=</span> <span class='Movie constant id'>Movie</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
        <span class='@movie ivar id'>@movie</span><span class='dot token'>.</span><span class='update identifier id'>update</span><span class='lparen token'>(</span><span class='params identifier id'>params</span><span class='lbrack token'>[</span><span class='symbol val'>:movie</span><span class='rbrack token'>]</span><span class='rparen token'>)</span>
        <span class='@actor ivar id'>@actor</span><span class='dot token'>.</span><span class='acted_in identifier id'>acted_in</span><span class='dot token'>.</span><span class='new identifier id'>new</span> <span class='@movie ivar id'>@movie</span>
        <span class='@movie ivar id'>@movie</span><span class='dot token'>.</span><span class='update identifier id'>update</span><span class='lparen token'>(</span><span class='params identifier id'>params</span><span class='lbrack token'>[</span><span class='symbol val'>:movie</span><span class='rbrack token'>]</span><span class='rparen token'>)</span>
        <span class='flash identifier id'>flash</span><span class='lbrack token'>[</span><span class='symbol val'>:notice</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='string val'>'Movie was successfully updated.'</span>
        <span class='redirect_to identifier id'>redirect_to</span><span class='lparen token'>(</span><span class='@movie ivar id'>@movie</span><span class='rparen token'>)</span>
      <span class='end end kw'>end</span>

      <span class='def def kw'>def</span> <span class='show identifier id'>show</span>
        <span class='@movie ivar id'>@movie</span> <span class='assign token'>=</span> <span class='Neo4j constant id'>Neo4j</span><span class='dot token'>.</span><span class='load identifier id'>load</span><span class='lparen token'>(</span><span class='params identifier id'>params</span><span class='lbrack token'>[</span><span class='symbol val'>:id</span><span class='rbrack token'>]</span><span class='rparen token'>)</span>
      <span class='end end kw'>end</span>

      <span class='def def kw'>def</span> <span class='new identifier id'>new</span>
        <span class='@actor ivar id'>@actor</span> <span class='assign token'>=</span> <span class='Neo4j constant id'>Neo4j</span><span class='dot token'>.</span><span class='load identifier id'>load</span><span class='lparen token'>(</span><span class='params identifier id'>params</span><span class='lbrack token'>[</span><span class='symbol val'>:actor_id</span><span class='rbrack token'>]</span><span class='rparen token'>)</span>
        <span class='@movie ivar id'>@movie</span> <span class='assign token'>=</span> <span class='Movie constant id'>Movie</span><span class='dot token'>.</span><span class='value_object identifier id'>value_object</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
      <span class='end end kw'>end</span>

      <span class='def def kw'>def</span> <span class='edit identifier id'>edit</span>
        <span class='@movie ivar id'>@movie</span> <span class='assign token'>=</span> <span class='Neo4j constant id'>Neo4j</span><span class='dot token'>.</span><span class='load identifier id'>load</span><span class='lparen token'>(</span><span class='params identifier id'>params</span><span class='lbrack token'>[</span><span class='symbol val'>:id</span><span class='rbrack token'>]</span><span class='rparen token'>)</span>
      <span class='end end kw'>end</span>
    <span class='end end kw'>end</span>
</pre>
<h4>Add views</h4>
<p>
Add the following views in app/views/actors index.html.erb:
</p>
<pre class="code">
    <span class='lt op'>&lt;</span><span class='h1 identifier id'>h1</span><span class='gt op'>&gt;</span><span class='Listing constant id'>Listing</span> <span class='actors identifier id'>actors</span><span class='lt op'>&lt;</span><span class='regexp val'>/h1&gt;

    &lt;table&gt;
      &lt;tr&gt;
        &lt;th&gt;Name&lt;/</span><span class='th identifier id'>th</span><span class='gt op'>&gt;</span>
      <span class='lt op'>&lt;</span><span class='regexp val'>/tr&gt;

      &lt;% for actor in @actors %&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;%=h actor.name %&gt;&lt;/</span><span class='td identifier id'>td</span><span class='gt op'>&gt;</span>
          <span class='lt op'>&lt;</span><span class='td identifier id'>td</span><span class='gt op'>&gt;</span><span class='lt op'>&lt;</span><span class='string val'>%= link_to 'Edit', edit_actor_path(actor) %&gt;&lt;/td&gt;
          &lt;td&gt;&lt;%=</span> <span class='link_to identifier id'>link_to</span> <span class='string val'>'Show'</span><span class='comma token'>,</span> <span class='actor identifier id'>actor</span> <span class='string val'>%&gt;&lt;/td&gt;</span>
          <span class='lt op'>&lt;</span><span class='td identifier id'>td</span><span class='gt op'>&gt;</span><span class='lt op'>&lt;</span><span class='string val'>%= link_to 'Destroy', actor, :confirm =</span><span class='gt op'>&gt;</span> <span class='string val'>'Are you sure?'</span><span class='comma token'>,</span> <span class='symbol val'>:method</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='symbol val'>:delete</span> <span class='mod op'>%</span><span class='gt op'>&gt;</span><span class='lt op'>&lt;</span><span class='regexp val'>/td&gt;
        &lt;/</span><span class='tr identifier id'>tr</span><span class='gt op'>&gt;</span>
      <span class='lt op'>&lt;</span><span class='string val'>% end </span><span class='mod op'>%</span><span class='gt op'>&gt;</span>
    <span class='lt op'>&lt;</span><span class='regexp val'>/table&gt;

    &lt;br /</span><span class='gt op'>&gt;</span>

    <span class='lt op'>&lt;</span><span class='string val'>%= link_to 'New actor', new_actor_path %&gt;
</span></pre>
<p>
new.html.erb:
</p>
<pre class="code">
    <span class='lt op'>&lt;</span><span class='h1 identifier id'>h1</span><span class='gt op'>&gt;</span><span class='New constant id'>New</span> <span class='Actor constant id'>Actor</span><span class='lt op'>&lt;</span><span class='regexp val'>/h1&gt;

    &lt;% form_for(@actor) do |f| %&gt;
      &lt;p&gt;
        &lt;%= f.label :name %&gt;&lt;br /</span><span class='gt op'>&gt;</span>
        <span class='lt op'>&lt;</span><span class='string val'>%= f.text_field :name %&gt;
      &lt;/p&gt;
      &lt;p&gt;
        &lt;%=</span> <span class='f identifier id'>f</span><span class='dot token'>.</span><span class='label identifier id'>label</span> <span class='symbol val'>:phone</span> <span class='mod op'>%</span><span class='gt op'>&gt;</span><span class='lt op'>&lt;</span><span class='br identifier id'>br</span> <span class='regexp val'>/&gt;
        &lt;%= f.text_field :phone %&gt;
      &lt;/</span><span class='p identifier id'>p</span><span class='gt op'>&gt;</span>
      <span class='lt op'>&lt;</span><span class='p identifier id'>p</span><span class='gt op'>&gt;</span>
        <span class='lt op'>&lt;</span><span class='string val'>%= f.label :salary%&gt;&lt;br /&gt;
        &lt;%=</span> <span class='f identifier id'>f</span><span class='dot token'>.</span><span class='text_field identifier id'>text_field</span> <span class='symbol val'>:salary</span> <span class='mod op'>%</span><span class='gt op'>&gt;</span>
      <span class='lt op'>&lt;</span><span class='regexp val'>/p&gt;
      &lt;p&gt;
        &lt;%= f.submit &quot;Update&quot; %&gt;
      &lt;/</span><span class='p identifier id'>p</span><span class='gt op'>&gt;</span>

    <span class='lt op'>&lt;</span><span class='string val'>% end </span><span class='mod op'>%</span><span class='gt op'>&gt;</span>

    <span class='lt op'>&lt;</span><span class='string val'>%= link_to 'Back', actors_path %&gt;
</span></pre>

</div>
          </div>
        </div>
      </div>                    
    </div>

    <div id="footer">
      <div class="site">
        <div class="info">
          <div class="links">
            <a href="http://github.com/blog/148-github-shirts-now-available">Shirts</a> |
            <a href="http://github.com/blog">Blog</a> |
            <a href="http://support.github.com/">Support</a> |
            <a href="http://github.com/training">Training</a> |
            <a href="http://github.com/contact">Contact</a> |
            <a href="http://groups.google.com/group/github/">Google Group</a> |
            <a href="http://develop.github.com/">API</a> |
            <a href="http://twitter.com/github">Status</a>
          </div>
          <div class="company">
            <span id="_rrt" title="0.64509s from xc88-s00039">GitHub</span>
            is <a href="http://logicalawesome.com/">Logical Awesome</a> 2009 | <a href="http://github.com/site/terms">Terms of Service</a> | <a href="http://github.com/site/privacy">Privacy Policy</a>
          </div>
        </div>
        <div class="sponsor">
          <a href="http://engineyard.com/"><img src="http://github.com/images/modules/footer/engine_yard_logo.png" alt="Engine Yard"></a>
          <div>
            Hosting provided by our<br> partners at Engine Yard
          </div>
        </div>
      </div>
    </div>
    
    <div id="coming_soon" style="display: none;">
      This feature is coming soon.  Sit tight!
    </div>

    <div id="facebox" style="display: none;">       
      <div class="popup">         
        <table>           
          <tbody>             
            <tr>               
              <td class="tl"></td>
              <td class="b"></td>
              <td class="tr"></td>             
            </tr>             
          <tr>               
            <td class="b"></td>               
            <td class="body">                 
              <div class="content"></div>                 
              <div class="footer">                   
                <a href="#" class="close"><img src="http://github.com/facebox/closelabel.gif" title="close" class="close_image"></a>                 
              </div>               
            </td>               
            <td class="b"></td>             
          </tr>             
          <tr>               
            <td class="bl"></td>
            <td class="b"></td>
            <td class="br"></td>             
          </tr>           
        </tbody>         
      </table>       
    </div>     


    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
    var pageTracker = _gat._getTracker("UA-8689483-1");
    pageTracker._trackPageview();
    } catch(err) {}</script>

  </body>
</html>