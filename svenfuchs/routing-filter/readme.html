<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="style.css" type="text/css" charset="utf-8" />
<link rel="stylesheet" href="syntax_highlight.css" type="text/css" charset="utf-8" />

    <title>README</title>
  </head>
  <body>
    <div id="content">
      <div class="section docstring readme">
        <p>
## Routing Filter
</p>
<p>
This plugin is a wild hack that wraps around the complex beast that the
Rails routing system is to allow for unseen flexibility and power in Rails
URL recognition and generation.
</p>
<p>
As powerful and awesome the Rails&#8217; routes are, when you need to
design your URLs in a manner that only slightly leaves the paved cowpaths
of Rails conventions, you&#8217;re usually unable to use all the goodness
of helpers and convenience that Rails ships with.
</p>
<p>
## Usage
</p>
<p>
This plugin comes with a locale routing filter that demonstrates the
implementation of a custom filter.
</p>
<p>
The following would be a sceleton of an empty filter:
</p>
<pre class="code">
    <span class='module module kw'>module</span> <span class='RoutingFilter constant id'>RoutingFilter</span>
      <span class='class class kw'>class</span> <span class='Awesomeness constant id'>Awesomeness</span> <span class='lt op'>&lt;</span> <span class='Base constant id'>Base</span>
        <span class='def def kw'>def</span> <span class='around_recognize identifier id'>around_recognize</span><span class='lparen token'>(</span><span class='route identifier id'>route</span><span class='comma token'>,</span> <span class='path identifier id'>path</span><span class='comma token'>,</span> <span class='env identifier id'>env</span><span class='rparen token'>)</span>
          <span class='comment val'># Alter the path here before it gets recognized.</span>
          <span class='comment val'># Make sure to yield (calls the next around filter if present and</span>
          <span class='comment val'># eventually `recognize_path` on the routeset):</span>
          <span class='returning identifier id'>returning</span> <span class='yield yield kw'>yield</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='params identifier id'>params</span><span class='bitor op'>|</span>
            <span class='comment val'># You can additionally modify the params here before they get passed</span>
            <span class='comment val'># to the controller.</span>
          <span class='end end kw'>end</span>
        <span class='end end kw'>end</span>

        <span class='def def kw'>def</span> <span class='around_generate identifier id'>around_generate</span><span class='lparen token'>(</span><span class='controller identifier id'>controller</span><span class='comma token'>,</span> <span class='mult op'>*</span><span class='args identifier id'>args</span><span class='comma token'>,</span> <span class='bitand op'>&amp;</span><span class='block identifier id'>block</span><span class='rparen token'>)</span>
          <span class='comment val'># Alter arguments here before they are passed to `url_for`.</span>
          <span class='comment val'># Make sure to yield (calls the next around filter if present and</span>
          <span class='comment val'># eventually `url_for` on the controller):</span>
          <span class='returning identifier id'>returning</span> <span class='yield yield kw'>yield</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='result identifier id'>result</span><span class='bitor op'>|</span>
            <span class='comment val'># You can change the generated url_or_path here. Make sure to use</span>
            <span class='comment val'># one of the &quot;in-place&quot; modifying String methods though (like sub!</span>
            <span class='comment val'># and friends).</span>
          <span class='end end kw'>end</span>
        <span class='end end kw'>end</span>
      <span class='end end kw'>end</span>
    <span class='end end kw'>end</span>
</pre>
<p>
You then have to specify the filter explicitely in your routes.rb:
</p>
<pre class="code">
    <span class='ActionController constant id'>ActionController</span><span class='colon2 op'>::</span><span class='Routing constant id'>Routing</span><span class='colon2 op'>::</span><span class='Routes constant id'>Routes</span><span class='dot token'>.</span><span class='draw identifier id'>draw</span> <span class='do do kw'>do</span> <span class='bitor op'>|</span><span class='map identifier id'>map</span><span class='bitor op'>|</span>
      <span class='map identifier id'>map</span><span class='dot token'>.</span><span class='filter identifier id'>filter</span> <span class='string val'>'awesomeness'</span>
    <span class='end end kw'>end</span>
</pre>
<p>
(I am not sure if it makes sense to provide more technical information than
this because the usage of this plugin definitely requires some advanced
knowledge about Rails internals and especially its routing system. So, I
figure, anyone who could use this should also be able to read the code and
figure out what it&#8217;s doing much better then from any lengthy
documentation.
</p>
<p>
If I&#8217;m mistaken on this please drop me an email with your
suggestions.)
</p>
<p>
## Rationale: Two example usecases
</p>
<p>
An early usecase from which this originated was the need to define a locale
at the beginning of an URL in a way so that
</p>
<ul>
<li>the locale can be omitted when it is the default locale

</li>
<li>all the url_helpers that are generated by named routes continue to work in

</li>
</ul>
<p>
a concise manner (i.e. without specifying all parameters again and again)
</p>
<ul>
<li>ideally also plays nicely with default route helpers in tests/specs

</li>
</ul>
<p>
You can read about this struggle and two possible, yet unsatisfying
solutions
[here](http://www.artweb-design.de/2007/5/13/concise-localized-rails-url-helpers-solved-twice).
The conclusion so far is that Rails itself does not provide the tools to
solve this problem in a clean and dry way.
</p>
<p>
Another usecase that eventually spawned the manifestation of this plugin
was the need to map an arbitrary count of path segments to a certain model
instance. In an application that I&#8217;ve been working on recently I
needed to map URL paths to a nested tree of models like so:
</p>
<pre class="code">
    <span class='root identifier id'>root</span>
    <span class='plus op'>+</span> <span class='docs identifier id'>docs</span>
      <span class='plus op'>+</span> <span class='api identifier id'>api</span>
      <span class='plus op'>+</span> <span class='wiki identifier id'>wiki</span>
</pre>
<p>
E.g. the docs section should map to the path `/docs`, the api section to
the path `/docs/api` and so on. Furthermore, after these paths there need
to be more things to be specified. E.g. the wiki needs to define a whole
Rails resource with URLs like `/docs/wiki/pages/1/edit`.
</p>
<p>
The only way to solve this problem with Rails&#8217; routing toolkit is to
map a big, bold `/*everything` catch-all (&quot;globbing&quot;) route and
process the whole path in a custom dispatcher.
</p>
<p>
This, of course, is a really unsatisfying solution because one has to
reimplement everything that Rails routes are here to help with: regarding
both URL recognition (like parameter mappings, resources, &#8230;) and
generation (url_helpers).
</p>
<p>
## Solution
</p>
<p>
This plugin offers a solution that takes exactly the opposite route.
</p>
<p>
Instead of trying to change things <b>between</b> the URL recognition and
generation stages to achieve the desired result it *wraps around* the whole
routing system and allows to pre- and post-filter both what goes into it
(URL recognition) and what comes out of it (URL generation).
</p>
<p>
This way we can leave <b>everything</b> else completely untouched.
</p>
<ul>
<li>We can tinker with the URLs that we receive from the server and feed URLs
to

</li>
</ul>
<p>
Rails that perfectly match the best breed of Rails&#8217; conventions.
</p>
<ul>
<li>Inside of the application we can use all the nice helper goodness and

</li>
</ul>
<p>
conveniences that rely on these conventions being followed.
</p>
<ul>
<li>Finally we can accept URLs that have been generated by the url_helpers and,

</li>
</ul>
<p>
again, mutate them in the way that matches our requirements.
</p>
<p>
So, even though the plugin itself is a blatant monkey-patch to one of the
most complex area of Rails internals, this solution seems to be effectively
less intrusive and pricey than others are.
</p>
<p>
## Etc
</p>
<p>
Authors: [Sven Fuchs](http://www.artweb-design.de) &lt;svenfuchs at
artweb-design dot de&gt; License: MIT
</p>

      </div>
    </div>
  </body>
</html>