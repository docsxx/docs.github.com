<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <title>RISCfuture's autumn - GitHub Documentation</title>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="description" content="">

<link rel="search" type="application/opensearchdescription+xml" href="http://github.com/opensearch.xml" title="GitHub">
<link rel="fluid-icon" href="http://github.com/fluidicon.png" title="GitHub">
<link href="http://assets0.github.com/stylesheets/bundle.css" media="screen" rel="stylesheet" type="text/css">
<link href="http://github.com/feeds/RISCfuture/commits/autumn/master" rel="alternate" title="Recent Commits to autumn:master" type="application/atom+xml">

<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js"></script>
<script type="text/javascript" src="http://assets3.github.com/javascripts/bundle.js"></script>              
<script src="app.js" type="text/javascript" charset="utf-8"></script>

<script type="text/javascript" src="http://docs.github.com/javascripts/md5.js"></script>
<script type="text/javascript" src="http://docs.github.com/javascripts/repos.js"></script>
<script type="text/javascript" src="http://docs.github.com/javascripts/commits.js"></script>
<script type="text/javascript">
  $(document).ready(function(){
    if (typeof skipHeaders != 'undefined') return;
    
    GitHubRepo.init("RISCfuture", "autumn", function(){ 
      GitHubRepo.links = " <a id='namespaces_button' rel='RISCfuture/autumn/blob/64fda32795e4ddd7ec4b80a201769916cf436456' href='#'><img class='button' src='http://docs.github.com/namespaces_button.png' alt='Modules and Classes'/></a> ";
      GitHubRepo.links += " <a id='methods_button' rel='RISCfuture/autumn/blob/64fda32795e4ddd7ec4b80a201769916cf436456' href='#'><img class='button' src='http://docs.github.com/methods_button.png' alt='Methods'/></a> ";
      $("#repo").html(GitHubRepo.content());
      $('#namespaces_button').click(function(){
        var url="/"+$(this).attr('rel')+"/namespaces/";
        $.gitbox(url);
        return false;
      });    
      $('#methods_button').click(function(){
        var url="/"+$(this).attr('rel')+"/methods/";
        $.gitbox(url);
        return false;
      });        
    });
    GitHubCommit.init("RISCfuture", "autumn", "64fda32795e4ddd7ec4b80a201769916cf436456", function(){ 
      $("#commit").html(GitHubCommit.content());
    });
  });
</script>

    <link rel="stylesheet" href="style.css" type="text/css" charset="utf-8" />
  </head>
  <body>    
    
    
        <div id="main" style="padding-bottom:8em;">
      <div id="header">
        <div class="site">
          <div class="logo">
            <a href="http://github.com/"><img src="http://github.com/images/modules/header/logov3.png" alt="github"></a>
          </div>          
          <div class="topsearch">
            <form action="http://github.com/search" id="top_search_form" method="get">
              <input class="search" name="q" type="search"> <input value="Search" type="submit">
            </form>
            <div class="links">
              <a href="http://github.com/repositories">Browse</a> | <a href="http://github.com/guides">Guides</a> | <a href="http://github.com/search">Advanced</a>
            </div>
          </div>
          <div class="actions">
            <a href="http://github.com">Home</a>
            <a href="http://github.com/plans"><b><u>Pricing and Signup</u></b></a>
            <a href="http://docs.github.com/">Documentation</a>
            <a href="https://github.com/login">Login</a>
          </div>                  
        </div>
      </div>    
                                                  
      <div id="repo_menu">
        <div class="site">
          <ul>          
            <li class=""><a href="http://github.com/RISCfuture/autumn/tree/">Source</a></li>
            <li class=""><a href="http://github.com/RISCfuture/autumn/commits/">Commits</a></li>            
            <li class=""><a href="http://github.com/RISCfuture/autumn/network">Network</a></li>            
            <li class=""><a href="http://github.com/RISCfuture/autumn/issues">Issues</a></li>
            <li class=""><a href="http://wiki.github.com/RISCfuture/autumn">Wiki</a></li>
            <li class=""><a href="http://github.com/RISCfuture/autumn/graphs">Graphs</a></li>                    
            <li class="active"><a href="/RISCfuture/autumn">Documentation</a></li>
          </ul>
        </div>
      </div>

      <div id="repo_sub_menu">
        <div class="site">
          <div class="joiner"></div>      
        </div>
      </div>

      <div class="site">  
        <div id="repos">
          <div id="repo" class="repo public">
            <div class="title">
              <div class="path">
                <a href="http://github.com/RISCfuture">RISCfuture</a> / <b><a href="http://github.com/RISCfuture/autumn/tree">autumn</a></b>        
                <a id="namespaces_button" rel="RISCfuture/autumn/blob/64fda32795e4ddd7ec4b80a201769916cf436456" href="#"><img class="button" src="http://docs.github.com/namespaces_button.png" alt="Modules and Classes"/></a>
                <a id="methods_button" rel="RISCfuture/autumn/blob/64fda32795e4ddd7ec4b80a201769916cf436456" href="#"><img class="button" src="http://docs.github.com/methods_button.png" alt="Methods"/></a>
              </div>
            </div>            
          </div>
          <div id="commit">
          </div> 
          <br/>                                       
          <div id="content">
            <div class="section docstring readme wikistyle">
  <h1>Autumn: A Ruby IRC Bot Framework</h1>
<p>
<b>Version 3.0 (Jul 4, 2008)</b>
</p>
<table>
<tr><td valign="top">Author:</td><td>Tim Morgan (mailto:autumn@timothymorgan.info)

</td></tr>
<tr><td valign="top">Copyright:</td><td>Copyright &#169;2007-2008 Tim Morgan

</td></tr>
<tr><td valign="top">License:</td><td>Distributed under the same terms as Ruby. Portions of this code are
copyright &#169;2004 David Heinemeier Hansson; please see
libs/inheritable_attributes.rb for more information.

</td></tr>
</table>
<p>
Autumn is a full-featured framework on top of which IRC bots (called
&quot;leaves&quot;) can be quickly and easily built. It features a very
Ruby-like approach to bot-writing, a complete framework for loading and
daemonizing your bots, multiple environment contexts, a database-backed
model, and painless logging support.
</p>
<h2>Requirements</h2>
<p>
Autumn requires RubyGems (http://www.rubygems.org) and the Daemons and
Facets* gems, as well as some of the gems spun off from Facets. Install
RubyGems then run <tt>sudo gem install daemons facets anise
activesupport</tt> in a command line in order to run Autumn.
</p>
<p>
If you wish to use a database backend for your bot, you will need the
DataMapper gem. To install, see the DataMapper website
(http://www.datamapper.org).
</p>
<p>
The included example bot Scorekeeper requires the DataMapper gem. It can
optionally use the Chronic gem to enhance its textual date parsing. The
other example bot, Insulter, is much simpler and can run under any Autumn
configuration.
</p>
<h2>Directory Structure</h2>
<p>
An Autumn installation is like a Ruby on Rails installation: There is a
certain directory structure where your files go. A lot of files and folders
will seem confusing to people who have never used Autumn before, but bear
with me. In a bit I will explain in detail what all of this stuff is. For
now, here is an overview you can consult for future reference:
</p>
<ul>
<li><b>config/</b> - Configuration files and season definitions

<ul>
<li>global.yml - Universal settings that apply to every season

</li>
<li><b>seasons/</b> - Contains directories for each season (see
&quot;Seasons&quot;)

<ul>
<li><b>testing/</b> - Example season

<ul>
<li>database.yml - Example database configuration file

</li>
<li>leaves.yml - Example bot configuration file

</li>
<li>season.yml - Season configuration

</li>
<li>stems.yml - Example IRC configuration file

</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><b>doc/</b> - HTML documentation generated by RDoc

<ul>
<li><b>api/</b> - Autumn API documentation

</li>
<li><b>leaves/</b> - Autumn leaves documentation

</li>
</ul>
</li>
<li><b>leaves/</b> - Autumn leaves. Each subdirectory contains all the code and
data for a leaf.

<ul>
<li><b>insulter/</b> - Very simple example leaf

<ul>
<li><em>See the <b>scorekeeper</b> directory</em>

</li>
</ul>
</li>
<li><b>scorekeeper/</b> - Database-backed, full-featured example leaf

<ul>
<li>config.yml - Optional leaf-global configuration options

</li>
<li>controller.rb - The leaf&#8217;s controller object

</li>
<li><b>data/</b> - Optional directory for data storage (not used by Autumn)

</li>
<li><b>helpers/</b> - Modules that extend the controller and views

</li>
<li><b>lib</b> - Library files loaded before the leaf

</li>
<li><b>models/</b> - Active record-type database objects

</li>
<li><b>tasks</b> - Additional rake tasks for this leaf

</li>
<li><b>views/</b> - ERb views for each of the leaf&#8217;s commands

</li>
</ul>
</li>
</ul>
</li>
<li><b>libs/</b> - Autumn core code

<ul>
<li>channel_leaf.rb - A leaf subclass that can ignore messages from certain
channels its in

</li>
<li>coder.rb - Used by script/generate to write out Ruby code

</li>
<li>ctcp.rb - CTCP support library

</li>
<li>daemon.rb - Provides support for different kinds of IRC servers

</li>
<li>datamapper_hacks.rb - Some hacks to help DataMapper work with Autumn

</li>
<li>foliater.rb - Instantiates and manages stems and leaves

</li>
<li>formatting.rb - Provides support for different kinds of IRC client text
formatting and colorization

</li>
<li>generator.rb - Library used by script/generate

</li>
<li>genesis.rb - Boots the Autumn environment

</li>
<li>inheritable_attributes.rb - Adds support for class-level inheritable
attributes

</li>
<li>leaf.rb - The core bot superclass

</li>
<li>log_facade.rb - Simplifies logging for stems and leaves

</li>
<li>misc.rb - RubyCore class additions and other knick-knacks

</li>
<li>script.rb - Library used by script/generate and script/destroy

</li>
<li>speciator.rb - Manages global, season, stem, and leaf configurations

</li>
<li>stem.rb - IRC client library

</li>
<li>stem_facade.rb - Additional methods to simplify the Stem class

</li>
</ul>
</li>
<li><b>log/</b> - Directory where (most) Autumn logs are written (see the
&quot;Logs&quot; section)

</li>
<li>Rakefile - Contains the rake tasks used to control Autumn (see the
&quot;Tasks&quot; section)

</li>
<li>README - This file

</li>
<li>README.textile - Textile-formatted readme

</li>
<li><b>resources/</b> - Data files used by Autumn

<ul>
<li><b>daemons/</b> - Data files describing different IRC server types

</li>
</ul>
</li>
<li><b>script/</b> - Helper scripts for controlling Autumn

<ul>
<li>daemon - Runs Autumn as a daemon

</li>
<li>destroy - Destroys Autumn objects

</li>
<li>generate - Creates Autumn objects

</li>
<li>server - Starts Autumn

</li>
</ul>
</li>
<li><b>shared/</b> - Shared code libraries available to all leaves

</li>
<li><b>tmp/</b> - Temporary files, such as PID files

</li>
</ul>
<h2>Configuring Autumn for Your First Launch</h2>
<p>
Before you can run Autumn and try out the example leaves, you&#8217;ll need
to set up a few things. Here are the steps:
</p>
<h3>Configure Your Testing Season</h3>
<p>
In Autumn, your leaves run in an environment, called a &quot;season.&quot;
Each season has different leaves and different settings for those leaves.
By default, Autumn comes with a season called &quot;testing&quot; already
set up for you. You can edit that season or create a new one with
<tt>script/generate season [season name]</tt>. The files for your season
are stored in the config/seasons directory.
</p>
<p>
First, edit the stems.yml file. This file stores information about your IRC
connection. Edit it to connect to an IRC server of your choosing. For more
information, see &quot;Stems&quot; below.
</p>
<p>
Next, edit the database.yml file. As mentioned previously, Scorekeeper
requires the DataMapper gem because it uses a persistent store. By default
it&#8217;s set up to use a MySQL database, but you can use PostgreSQL or
SQLite 3 if you&#8217;d like. If you&#8217;d prefer not to install any of
these database solutions, delete the database.yml file and remove the
Scorekeeper leaf from the leaves.yml and stems.yml files.
</p>
<p>
If you do choose to set up a database, you will have to run <tt>rake
db:migrate</tt> after your database.yml file is configured and your
database is created.
</p>
<p>
Lastly, view the leaves.yml file. You shouldn&#8217;t have to make any
changes to this file, but it&#8217;s a good idea to look at it to see how
leaves are configured. You can do the same with the season.yml file. See
&quot;Seasons&quot; and &quot;Leaves&quot; below for more.
</p>
<h3>Starting the Server</h3>
<p>
Run the shell command <tt>script/server</tt> to start the server. After a
short while, your leaf should appear in the channel you specified. You can
type &quot;!points Coolguy +5&quot; and then &quot;!points&quot; to get
started using Scorekeeper, or &quot;!insult&quot; to play with Insulter.
Have some fun, and when you&#8217;re satisfied, stop the server by typing
&quot;!quit&quot;.
</p>
<p>
If you&#8217;d like to daemonize your server, you can use the shell
commands <tt>rake app:start</tt> and <tt>rake app:stop</tt>. For more
information, see &quot;Tasks&quot; below.
</p>
<h2>Making Your Own Leaf</h2>
<p>
Making your own leaf using Autumn is easy. In this tutorial, I&#8217;ll
show you how to make a simple Fortune bot that responds to a few basic
commands.
</p>
<h3>Step 1: Subclass Leaf</h3>
<p>
Create a new leaf by typing <tt>script/generate leaf fortune</tt>. This
will create a fortune directory in the leaves directory, along with the
bare bones of files needed within that directory. Edit the controller.rb
file. First we&#8217;ll create an array to hold our fortunes:
</p>
<pre class="code">
 <span class='FORTUNES constant id'>FORTUNES</span> <span class='assign token'>=</span> <span class='lbrack token'>[</span>
   <span class='string val'>&quot;You will make someone happy today.&quot;</span><span class='comma token'>,</span>
   <span class='string val'>&quot;Someone you don't expect will be important to you today.&quot;</span><span class='comma token'>,</span>
   <span class='string val'>&quot;Today will bring unexpected hardships.&quot;</span>
 <span class='rbrack token'>]</span>
</pre>
<p>
As you can see, our 3 meager fortunes are stored in the <tt>FORTUNES</tt>
class constant. Now, we&#8217;ll want it to respond to the
&quot;!fortune&quot; command, and all you have to do is create a method
called <tt>fortune_command</tt> to make it work:
</p>
<pre class="code">
 <span class='def def kw'>def</span> <span class='fortune_command identifier id'>fortune_command</span><span class='lparen token'>(</span><span class='stem identifier id'>stem</span><span class='comma token'>,</span> <span class='sender identifier id'>sender</span><span class='comma token'>,</span> <span class='reply_to identifier id'>reply_to</span><span class='comma token'>,</span> <span class='msg identifier id'>msg</span><span class='rparen token'>)</span>
   <span class='FORTUNES constant id'>FORTUNES</span><span class='dot token'>.</span><span class='pick identifier id'>pick</span>
 <span class='end end kw'>end</span>
</pre>
<p>
The <tt>pick</tt> method is provided by Facets, so you may need to add a
<tt>require &#8216;facets/random&#8217;</tt> line at the top of your file.
Our method returns a fortune at random, which is automatically transmitted
to the channel or nick where the command was received.
</p>
<p>
Of course, any self-respecting fortune bot announces its presence when it
starts up, so, in your <tt>Controller</tt> class, override the
Autumn::Leaf#did_start_up method to display a cheerful greeting:
</p>
<pre class="code">
 <span class='def def kw'>def</span> <span class='did_start_up identifier id'>did_start_up</span>
   <span class='stems identifier id'>stems</span><span class='dot token'>.</span><span class='message identifier id'>message</span> <span class='string val'>'FortuneBot at your service! Type &quot;!fortune&quot; to get your fortune!'</span>
 <span class='end end kw'>end</span>
</pre>
<p>
&#8230;and that&#8217;s it! You now have a fully functional fortune bot
featuring &#8212; not two &#8212; but <em>three</em> unique and exciting
fortunes!
</p>
<p>
(For more on that <tt>stems.message</tt> bit, see &quot;Stems.&quot;)
</p>
<h3>Step 2: Add the Leaf to Your Season</h3>
<p>
If you want, you can add the fortune bot to your leaves.yml and stems.yml
files to try it out. Adding a leaf is easy; simply duplicate the structure
used for another leaf&#8217;s entry and change the values as appropriate. A
typical two-leaf configuration will look like:
</p>
<pre class="code">
 <span class='Scorekeeper constant id'>Scorekeeper</span><span class='colon op'>:</span>
   <span class='class class kw'>class</span><span class='colon op'>:</span> <span class='Scorekeeper constant id'>Scorekeeper</span>
   <span class='respond_to_private_messages identifier id'>respond_to_private_messages</span><span class='colon op'>:</span> <span class='false false kw'>false</span>
 <span class='Fortune constant id'>Fortune</span><span class='colon op'>:</span>
   <span class='class class kw'>class</span><span class='colon op'>:</span> <span class='Fortune constant id'>Fortune</span>
   <span class='respond_to_private_messages identifier id'>respond_to_private_messages</span><span class='colon op'>:</span> <span class='true true kw'>true</span>
</pre>
<p>
As you notice, each leaf instance is given a name. In this example the name
happens to be the same as the leaf&#8217;s <em>type</em> name, but you
could run two copies of a leaf like so:
</p>
<pre class="code">
 <span class='Fortune1 constant id'>Fortune1</span><span class='colon op'>:</span>
   <span class='class class kw'>class</span><span class='colon op'>:</span> <span class='Fortune constant id'>Fortune</span>
 <span class='Fortune2 constant id'>Fortune2</span><span class='colon op'>:</span>
   <span class='class class kw'>class</span><span class='colon op'>:</span> <span class='Fortune constant id'>Fortune</span>
</pre>
<p>
This doesn&#8217;t make a whole lot of sense for our fortune bot, but for
more complicated bots it can be useful.
</p>
<p>
We&#8217;ve created the leaf, but we have to add it to the stem for it to
work. (Remember, a stem is an IRC connection and a leaf is a bot.) So, in
your stems.yml file, add an entry for this leaf. Your new config will
appear something like:
</p>
<pre class="code">
 <span class='Example constant id'>Example</span><span class='colon op'>:</span>
   <span class='nick identifier id'>nick</span><span class='colon op'>:</span> <span class='Scorekeeper constant id'>Scorekeeper</span>
   <span class='leaves identifier id'>leaves</span><span class='colon op'>:</span>
     <span class='minus op'>-</span> <span class='Scorekeeper constant id'>Scorekeeper</span>
     <span class='minus op'>-</span> <span class='Fortune constant id'>Fortune</span>
   <span class='rejoin identifier id'>rejoin</span><span class='colon op'>:</span> <span class='true true kw'>true</span>
   <span class='channel identifier id'>channel</span><span class='colon op'>:</span> <span class='somechannel identifier id'>somechannel</span>
   <span class='server identifier id'>server</span><span class='colon op'>:</span> <span class='irc identifier id'>irc</span><span class='dot token'>.</span><span class='someserver identifier id'>someserver</span><span class='dot token'>.</span><span class='com identifier id'>com</span>
</pre>
<p>
When you restart the server, the bot will come back online and will now
also respond to the &quot;!fortune&quot; command. This is a helpful
tutorial on how stems and leaves are separate. One leaf can have many
stems, and one stem can have many leaves. You can combine these two
entities however you need.
</p>
<h3>Step 3: Upgrade to ERb Views</h3>
<p>
You&#8217;ve already learned that for your <tt>[word]_command</tt>-type
methods, the bot responds with whatever string your method returns. For
more complicated commands, however, you may want to upgrade to full view
abstraction, a la Ruby on Rails. This is what the views directory is for.
</p>
<p>
If you place a .txt.erb file in the views directory named after your
command, it will be parsed by ERb and rendered as the result. You can pass
variables to the ERb parser by using the Autumn::Leaf#var method.
Let&#8217;s upgrade our <tt>fortune_command</tt> method for that:
</p>
<pre class="code">
 <span class='def def kw'>def</span> <span class='fortune_command identifier id'>fortune_command</span><span class='lparen token'>(</span><span class='stem identifier id'>stem</span><span class='comma token'>,</span> <span class='sender identifier id'>sender</span><span class='comma token'>,</span> <span class='reply_to identifier id'>reply_to</span><span class='comma token'>,</span> <span class='msg identifier id'>msg</span><span class='rparen token'>)</span>
   <span class='var identifier id'>var</span> <span class='symbol val'>:fortune</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='FORTUNES constant id'>FORTUNES</span><span class='dot token'>.</span><span class='pick identifier id'>pick</span>
 <span class='end end kw'>end</span>
</pre>
<p>
We can then write a view, fortune.txt.erb, which will render the fortune:
</p>
<pre class="code">
 <span class='lt op'>&lt;</span><span class='string val'>%= var :fortune %&gt;
</span></pre>
<p>
OK, so admittedly, this doesn&#8217;t really get us anywhere, but for more
complicated bots, this well help separate view and controller concerns.
</p>
<p>
For more information on view rendering, see the Autumn::Leaf#render method.
</p>
<h2>Seasons</h2>
<p>
Each time you start Autumn, the process launches in a certain season
(a.k.a. environment context). This season is defined in the
config/global.yml file. You can temporarily override it by setting the
<tt>SEASON</tt> environment variable (e.g., <tt>SEASON=production
script/server</tt>).
</p>
<p>
It&#8217;s important to realize that an season is just a name, nothing
more. You can have as many seasons as you like, and name them anything that
you like. Autumn will load the config files for the season you&#8217;ve
indicated as active. Autumn doesn&#8217;t really care if it&#8217;s named
&quot;production&quot; or &quot;live&quot; or
&quot;testing-on-jeffs-machine&quot;; it&#8217;s all the same to Autumn.
</p>
<p>
Your season&#8217;s configuration is stored in the season.yml file within
your season directory. Currently it supports one directive,
<tt>logging</tt>. This sets the minimum log level (such as <tt>debug</tt>
or <tt>warn</tt>). If the log level is set to <tt>debug</tt>, it also
enables console output parroting. (See the &quot;Logging&quot; section.)
</p>
<p>
The power of seasons comes in custom configuration options. For instance,
consider that you have a testing and production season. In your testing
season, your season.yml file contains:
</p>
<pre class="code">
 <span class='dont_http identifier id'>dont_http</span><span class='colon op'>:</span> <span class='true true kw'>true</span>
</pre>
<p>
and in production, it contains:
</p>
<pre class="code">
 <span class='dont_http identifier id'>dont_http</span><span class='colon op'>:</span> <span class='false false kw'>false</span>
</pre>
<p>
Now, in your code, you might have a method like:
</p>
<pre class="code">
 <span class='def def kw'>def</span> <span class='scores_command identifier id'>scores_command</span><span class='lparen token'>(</span><span class='stem identifier id'>stem</span><span class='comma token'>,</span> <span class='sender identifier id'>sender</span><span class='comma token'>,</span> <span class='reply_to identifier id'>reply_to</span><span class='comma token'>,</span> <span class='msg identifier id'>msg</span><span class='rparen token'>)</span>
   <span class='if if kw'>if</span> <span class='options identifier id'>options</span><span class='lbrack token'>[</span><span class='symbol val'>:dont_http</span><span class='rbrack token'>]</span> <span class='then then kw'>then</span>
     <span class='return return kw'>return</span> <span class='string val'>&quot;Some fake sports scores.&quot;</span>
   <span class='else else kw'>else</span>
     <span class='comment val'># go on the web and find real sports scores</span>
   <span class='end end kw'>end</span>
 <span class='end end kw'>end</span>
</pre>
<h3>Standard Configuration Options</h3>
<h4>Global</h4>
<p>
System-wide configuration is done in the config/global.yml file. It
supports by default the following directives:
</p>
<table>
<tr><td valign="top"><tt>season</tt>:</td><td>The season to launch in.

</td></tr>
<tr><td valign="top"><tt>log_history</tt>:</td><td>The number of historical logfiles to keep (default 10).

</td></tr>
</table>
<p>
In addition, the following options are available (but cannot be set in the
yml file):
</p>
<table>
<tr><td valign="top"><tt>root</tt>:</td><td>The root directory of the Autumn installation.

</td></tr>
<tr><td valign="top"><tt>system_logger</tt>:</td><td>The Autumn::LogFacade instance that records system messages.

</td></tr>
</table>
<h4>Season</h4>
<p>
Season-specific configuration is done in the
config/seasons/[season]/season.yml file. Currently it only supports one
directive, <tt>logging</tt>, which takes log levels such as <tt>debug</tt>
or <tt>warn</tt>.
</p>
<h4>Stem</h4>
<p>
Stem-specific configuration is done in the
config/seasons/[season]/stems.yml file. It&#8217;s important to note that
stem and leaf configurations are completely independent of each other. (In
other words, stem options do not override leaf options, nor vice versa.)
Therefore, you generally won&#8217;t add custom directives to the stems.yml
file, because you generally won&#8217;t be working with stems directly. The
standard options are:
</p>
<table>
<tr><td valign="top"><tt>server</tt>:</td><td>The address of the IRC server.

</td></tr>
<tr><td valign="top"><tt>port</tt>:</td><td>The IRC server port (default 6667).

</td></tr>
<tr><td valign="top"><tt>local_ip</tt>:</td><td>The IP address to connect on (for virtual hosting).

</td></tr>
<tr><td valign="top"><tt>nick</tt>:</td><td>The nick to request.

</td></tr>
<tr><td valign="top"><tt>password</tt>:</td><td>The nick&#8217;s password, if it is registered.

</td></tr>
<tr><td valign="top"><tt>channel</tt>:</td><td>A channel to join.

</td></tr>
<tr><td valign="top"><tt>channels</tt>:</td><td>A list of channels to join.

</td></tr>
<tr><td valign="top"><tt>leaf</tt>:</td><td>The name of a leaf to run.

</td></tr>
<tr><td valign="top"><tt>leaves</tt>:</td><td>A list of leaves to run. (These are the names of leaf configurations in
leaves.yml, not leaf subclasses.)

</td></tr>
<tr><td valign="top"><tt>rejoin</tt>:</td><td>If true, the stem will rejoin any channels it is kicked from.

</td></tr>
<tr><td valign="top"><tt>server_password</tt>:</td><td>The password for the IRC server, if necessary.

</td></tr>
<tr><td valign="top"><tt>ssl</tt>:</td><td>If true, the connection to the IRC server will be made over SSL.

</td></tr>
<tr><td valign="top"><tt>server_type</tt>:</td><td>The IRC server type. See resources/daemons for a list of valid server
types. If you do not manually set this value, it will be guessed
automatically.

</td></tr>
<tr><td valign="top"><tt>case_sensitive_channel_names</tt>:</td><td>If true, channel names will be compared with case sensitivity.

</td></tr>
<tr><td valign="top"><tt>dont_ghost</tt>:</td><td>If true, the stem will not try to GHOST a registered nick if it&#8217;s
taken.

</td></tr>
<tr><td valign="top"><tt>ghost_without_password</tt>:</td><td>If true, the stem will use the GHOST command without a password. Set this
for servers that use some other form of nick authentication, such as
hostname-based.

</td></tr>
<tr><td valign="top"><tt>user</tt>:</td><td>The username to send (optional).

</td></tr>
<tr><td valign="top"><tt>name</tt>:</td><td>The user&#8217;s real name (optional).

</td></tr>
<tr><td valign="top"><tt>throttle</tt>:</td><td>If enabled, the stem will throttle large amounts of simultaneous messages.

</td></tr>
<tr><td valign="top"><tt>throttle_rate</tt>:</td><td>Sets the number of seconds that pass between consecutive PRIVMSG&#8217;s
when the leaf&#8217;s output is throttled.

</td></tr>
<tr><td valign="top"><tt>throttle_threshold</tt>:</td><td>Sets the number of simultaneous messages that must be queued before the
leaf begins throttling output.

</td></tr>
<tr><td valign="top"><tt>nick_regex</tt>:</td><td>The regular expression used to match nicknames in server messages. By
default, it conforms to the RFC-1459 definition.

</td></tr>
</table>
<p>
The <tt>channel</tt> and <tt>channels</tt> directives can also be used to
specify a password for a password protected channel, like so:
</p>
<pre class="code">
 <span class='channel identifier id'>channel</span><span class='colon op'>:</span>
   <span class='channelname identifier id'>channelname</span><span class='colon op'>:</span> <span class='channelpassword identifier id'>channelpassword</span>
</pre>
<p>
or
</p>
<pre class="code">
 <span class='channels identifier id'>channels</span><span class='colon op'>:</span>
 <span class='minus op'>-</span> <span class='channel1 identifier id'>channel1</span><span class='colon op'>:</span> <span class='password1 identifier id'>password1</span>
 <span class='minus op'>-</span> <span class='channel2 identifier id'>channel2</span><span class='colon op'>:</span> <span class='password2 identifier id'>password2</span>
</pre>
<p>
The <tt>port</tt>, <tt>server_type</tt>, and
<tt>channel</tt>/<tt>channels</tt> options are set in the config file but
not available in the <tt>options</tt> hash. They are accessed directly from
attributes in the Stem instance, such as the <tt>channels</tt> attribute.
</p>
<h4>Leaf</h4>
<p>
Leaf-specific configuration is done in the
config/seasons/[season]/leaves.yml file and the leaves/[leaf]/config.yml
file, with the former taking precedence over the latter. As mentioned
above, leaf and stem configurations are completely separate, so one does
not override the other. The standard options are:
</p>
<table>
<tr><td valign="top"><tt>class</tt>:</td><td>The type of the leaf. It must be a subdirectory in the leaves directory.

</td></tr>
<tr><td valign="top"><tt>command_prefix</tt>:</td><td>The text that must precede each command. Defaults to &quot;!&quot;.

</td></tr>
<tr><td valign="top"><tt>respond_to_private_messages</tt>:</td><td>If true, the leaf will parse commands in whispers, and respond over
whispers to those commands.

</td></tr>
<tr><td valign="top"><tt>database</tt>:</td><td>A database connection to use (as defined in database.yml). By default
Autumn will choose a connection named after your leaf.

</td></tr>
<tr><td valign="top"><tt>formatter</tt>:</td><td>The name of a module in Autumn::Formatting that will handle output
formatting and colorization. This defaults to mIRC-style formatting.

</td></tr>
</table>
<p>
In addition, the following options are available (but cannot be set in the
yml file):
</p>
<table>
<tr><td valign="top"><tt>root</tt>:</td><td>The root directory of the leaf installation.

</td></tr>
</table>
<p>
The leaves.yml file is optional. When not included, each leaf in the leaves
directory will be automatically instantiated once.
</p>
<h3>Custom Configuration Options</h3>
<p>
All configuration files support user-generated directives. You can set
options at any level. Options at a more narrow level override those at a
broader level.
</p>
<p>
Options are maintained and cataloged by the Autumn::Speciator singleton.
You could access the singleton directly, but most objects have an
<tt>options</tt> attribute providing simpler access to the Speciator.
</p>
<p>
For example, to access options in a leaf, all you do is call, for example,
<tt>options[:my_custom_option]</tt>. <tt>my_custom_option</tt> can be set
at the global, season, or leaf level.
</p>
<h2>Leaves</h2>
<p>
The Autumn::Leaf class has many tools to help you write your leaves. These
include things like filters, helpers, loggers, and an easy to use IRC
library. The Autumn::Leaf and Autumn::Stem class docs are the most thorough
way of learning about each of these features, but I&#8217;ll walk you
through the basics here.
</p>
<h3>The Many Methods of Leaf</h3>
<p>
By subclassing Autumn::Leaf, you gain access to a number of neat utilities.
These generally come in three classes: IRC commands that have already been
written for you, utility methods you can call, and invoked methods you can
override. Utility methods do things like add filters. Invoked methods are
called when certain events happen, like when your leaf starts up or when a
private message is received. You override them in your leaf to customize
how it responds to these events.
</p>
<table>
<tr><td valign="top"><b>Invoked methods</b>:</td><td><tt>will_start_up</tt>, <tt>did_start_up</tt>,
<tt>did_receive_channel_message</tt>, etc.

</td></tr>
<tr><td valign="top"><b>Utility methods</b>:</td><td><tt>before_filter</tt>, <tt>database</tt>, etc.

</td></tr>
<tr><td valign="top"><b>IRC commands</b>:</td><td><tt>quit_command</tt>, <tt>reload_command</tt>, <tt>autumn_command</tt>,
etc.

</td></tr>
</table>
<p>
See the class docs for more information on these methods.
</p>
<p>
In addition, your leaf is designated as a listener for its Autumn::Stem
instances. In short, this means if you want even finer control over the IRC
connection, you can implement listener methods. See the
Autumn::Stem#add_listener method for examples of such methods.
</p>
<p>
Finally, your leaf can implement methods that are broadcast by listener
plugins. An example of such a plugin is the Autumn::CTCP class, which is
included in all stems by default. Visit its class docs to learn more about
how to send and receive CTCP requests.
</p>
<h3>Filters</h3>
<p>
Filters are methods that are run either before or after a command is
executed. In the former case, they can also prevent the command from being
run. This is useful for authentication, for instance: A filter could
determine if someone is authorized to run a command, and prevent the
command from being run if not.
</p>
<p>
Use filters to save yourself the effort of rewriting code that will run
before or after a command is executed. Filter methods are named
<tt>[word]_filter</tt> and they are added to the filter chain using the
<tt>before_filter</tt> and <tt>after_filter</tt> methods (like in Ruby on
Rails). As an example, imagine you wanted your bot to say something after
each command:
</p>
<pre class="code">
 <span class='class class kw'>class</span> <span class='Controller constant id'>Controller</span> <span class='lt op'>&lt;</span> <span class='Autumn constant id'>Autumn</span><span class='colon2 op'>::</span><span class='Leaf constant id'>Leaf</span>
   <span class='after_filter identifier id'>after_filter</span> <span class='symbol val'>:outro</span>

   <span class='private identifier id'>private</span>

   <span class='def def kw'>def</span> <span class='outro_filter identifier id'>outro_filter</span><span class='lparen token'>(</span><span class='stem identifier id'>stem</span><span class='comma token'>,</span> <span class='channel identifier id'>channel</span><span class='comma token'>,</span> <span class='sender identifier id'>sender</span><span class='comma token'>,</span> <span class='command identifier id'>command</span><span class='comma token'>,</span> <span class='msg identifier id'>msg</span><span class='comma token'>,</span> <span class='opts identifier id'>opts</span><span class='rparen token'>)</span>
     <span class='stem identifier id'>stem</span><span class='dot token'>.</span><span class='message identifier id'>message</span> <span class='string val'>&quot;This has been a production of OutroBot!&quot;</span><span class='comma token'>,</span> <span class='channel identifier id'>channel</span>
   <span class='end end kw'>end</span>
 <span class='end end kw'>end</span>
</pre>
<p>
The result of this is that after each command, the leaf will make a
dramatic exit. (Why did I use <tt>after_filter</tt> and not
<tt>before_filter</tt>? Because as I said earlier, a <tt>before_filter</tt>
can stop the command from being executed; the only way we know for sure
that the command was executed &#8212; and therefore should be outroed
&#8212; is to use an <tt>after_filter</tt>.)
</p>
<p>
I made the <tt>outro_filter</tt> method private because I felt it
shouldn&#8217;t be exposed to other classes; this is not a requirement of
the filter framework, though.
</p>
<p>
Now let&#8217;s say you wanted to prevent the command from being run in
some cases. The most obvious application of this feature is authentication.
Autumn already includes a robust authentication module, but for the sake of
example, let&#8217;s pretend you wanted to do your own authentication in
your leaf. So, you write a <tt>before_filter</tt> to determine if the user
is authenticated. <tt>before_filter</tt>s have return values; if they
return false, the filter chain is halted and the command is suppressed. If
you want to have your leaf display some sort of message (like &quot;Nice
try!&quot;), you need to include that in your filter.
</p>
<p>
As an example, here&#8217;s a simple form of authentication that just
checks a person&#8217;s nick:
</p>
<pre class="code">
 <span class='class class kw'>class</span> <span class='Controller constant id'>Controller</span> <span class='lt op'>&lt;</span> <span class='Autumn constant id'>Autumn</span><span class='colon2 op'>::</span><span class='Leaf constant id'>Leaf</span>
   <span class='before_filter identifier id'>before_filter</span> <span class='symbol val'>:authenticate</span><span class='comma token'>,</span> <span class='symbol val'>:only</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='symbol val'>:quit</span><span class='comma token'>,</span> <span class='symbol val'>:admin</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='string val'>'Yournick'</span>

   <span class='def def kw'>def</span> <span class='authenticate_filter identifier id'>authenticate_filter</span><span class='lparen token'>(</span><span class='stem identifier id'>stem</span><span class='comma token'>,</span> <span class='channel identifier id'>channel</span><span class='comma token'>,</span> <span class='sender identifier id'>sender</span><span class='comma token'>,</span> <span class='command identifier id'>command</span><span class='comma token'>,</span> <span class='msg identifier id'>msg</span><span class='comma token'>,</span> <span class='opts identifier id'>opts</span><span class='rparen token'>)</span>
     <span class='sender identifier id'>sender</span> <span class='eq op'>==</span> <span class='opts identifier id'>opts</span><span class='lbrack token'>[</span><span class='symbol val'>:admin</span><span class='rbrack token'>]</span>
   <span class='end end kw'>end</span>
 <span class='end end kw'>end</span>
</pre>
<p>
I&#8217;m introducing you to three new features with this sample:
</p>
<ul>
<li>You can use the <tt>:only</tt> option to limit your filter to certain
commands. Note that you specify the <em>command</em> name as a symbol,
<em>not</em> the method name (which would be <tt>quit_command</tt> in this
case).

</li>
<li>You can pass your own options to <tt>before_filter</tt> and
<tt>after_filter</tt>; they are passed through to your method via the last
parameter, <tt>opts</tt>.

</li>
<li>The return value of a <tt>before_filter</tt> is used to determine if the
command should be run. So be careful that your method does not return nil
or false unless you really mean for the command to be suppressed.

</li>
</ul>
<p>
Both of these examples use the parameters sent to your filter method. They
are, in order:
</p>
<ol>
<li>the Autumn::Stem instance that received the command,

</li>
<li>the name of the channel to which the command was sent (or nil if it was a
private message),

</li>
<li>the sender hash,

</li>
<li>the name of the command that was typed, as a symbol,

</li>
<li>any additional parameters after the command (same as the <tt>msg</tt>
parameter in the <tt>[word]_command</tt> methods),

</li>
<li>the custom options that were given to <tt>before_filter</tt> or
<tt>after_filter</tt>.

</li>
</ol>
<p>
There are two built-in options that you can specify for
<tt>before_filter</tt> and <tt>after_filter</tt>, and those are
<tt>only</tt> and <tt>except</tt>. They work just like in Rails: The
<tt>only</tt> option limits the filter to running only on the given command
or list of commands, and the <tt>except</tt> option prevents the filter
from being run on the given command or list. All other options are passed
to the filter for you to use.
</p>
<p>
Filters are run in the order they are added to the filter chain. Therefore,
a superclass&#8217;s filters will run before a subclass&#8217;s filters,
and filters added later in a class definition will be run after those added
earlier.
</p>
<p>
If you subclass one of your leaves, it inherits your superclass&#8217;s
filters. The Autumn::Leaf superclass does not have any filters by default,
though by default new leaves come with a simple authentication filter that
checks the user&#8217;s privilege level.
</p>
<h3>Authentication</h3>
<p>
You don&#8217;t need to write a <tt>before_filter</tt> as shown above,
because Autumn already includes a robust authentication module. The
Autumn::Authentication module includes the <tt>Base</tt> class and four
different subclasses of it. Each of these subclasses handles a different
type of authentication. You can choose the authentication strategy you want
on a leaf-by-leaf basis or for a whole season.
</p>
<p>
To specify the kind of authentication you want, you must add an
<tt>authentication</tt> directive to your config. If you want to set it for
an individual leaf, add it to the leaves.yml file. If you want all leaves
to have the same authentication strategy, add it to the season.yml or
global.yml file.
</p>
<p>
The <tt>authentication</tt> directive should be a hash that, at a minimum,
includes a key called <tt>type</tt>. This is the snake_cased name of
subclass in Autumn::Authentication that you wish to use. As an example,
here is an entry for an Administrator bot in a leaves.yml file, with
ops-based authentication.
</p>
<pre class="code">
 <span class='Administrator constant id'>Administrator</span><span class='colon op'>:</span>
   <span class='class class kw'>class</span><span class='colon op'>:</span> <span class='Administrator constant id'>Administrator</span>
   <span class='authentication identifier id'>authentication</span><span class='colon op'>:</span>
     <span class='type identifier id'>type</span><span class='colon op'>:</span> <span class='op identifier id'>op</span>
</pre>
<p>
This will instantiate the Autumn::Authentication::Op class for use with the
Administrator bot.
</p>
<p>
Other authentication strategies may require additional information. For
instance, if you want to used nick-based authentication, your leaves.yml
file might look like:
</p>
<pre class="code">
 <span class='Administrator constant id'>Administrator</span><span class='colon op'>:</span>
   <span class='class class kw'>class</span><span class='colon op'>:</span> <span class='Administrator constant id'>Administrator</span>
   <span class='authentication identifier id'>authentication</span><span class='colon op'>:</span>
     <span class='type identifier id'>type</span><span class='colon op'>:</span> <span class='nick identifier id'>nick</span>
     <span class='nick identifier id'>nick</span><span class='colon op'>:</span> <span class='MyNick constant id'>MyNick</span>
</pre>
<p>
See the class docs for each subclass in Autumn::Authentication for more
info on how you should set up your configs.
</p>
<h3>Persistent Stores</h3>
<p>
If you would like to use a persistent store for your leaf, you should
install the DataMapper gem and a DataObjects gem for your database of
choice (MySQL, PostgreSQL, or SQLite). DataMapper works almost identically
to ActiveRecord, so if you have any Rails programming experience, you
should be able to dive right in.
</p>
<p>
Once you&#8217;ve got DataMapper installed, you should create one or more
database connections in your config/seasons/[season]/database.yml file. A
sample database connection looks like:
</p>
<pre class="code">
 <span class='connection_name identifier id'>connection_name</span><span class='colon op'>:</span>
   <span class='adapter identifier id'>adapter</span><span class='colon op'>:</span> <span class='mysql identifier id'>mysql</span>
   <span class='host identifier id'>host</span><span class='colon op'>:</span> <span class='localhost identifier id'>localhost</span>
   <span class='username identifier id'>username</span><span class='colon op'>:</span> <span class='root identifier id'>root</span>
   <span class='password identifier id'>password</span><span class='colon op'>:</span> <span class='pass identifier id'>pass</span>
   <span class='database identifier id'>database</span><span class='colon op'>:</span> <span class='database_name identifier id'>database_name</span>
</pre>
<p>
or, in a smaller syntax:
</p>
<pre class="code">
 <span class='connection_name identifier id'>connection_name</span><span class='colon op'>:</span> <span class='mysql identifier id'>mysql</span><span class='symbol val'>:/</span><span class='regexp val'>/root@pass:localhost/</span><span class='database_name identifier id'>database_name</span>
</pre>
<p>
If you are using the &quot;sqlite3&quot; adapter, the <tt>database</tt>
option is the path to the file where the data should be written (example:
leaves/fortune/data/my_database.db). You can name your connection however
you want, but you <em>should</em> name it after either your leaf or your
leaf subclass. (More on this below.)
</p>
<p>
You should also create DataMapper model classes for each of your model
objects. You can place them within your leaf&#8217;s models directory. This
works almost exactly the same as the app/models directory in Rails.
</p>
<p>
Once your database, data models, and leaves have been configured, you can
use the <tt>rake db:migrate</tt> task to automatically populate your
database.
</p>
<p>
Now, unlike Rails, Autumn supports multiple database connections. Two
leaves can use two different database connections, or share the same
database connection. Because of this, it&#8217;s important to understand
how to manage your connections. Autumn tries to do this for you by guessing
which connection belongs to which leaf, based on their names.
</p>
<p>
For example, imagine you have a leaf named &quot;Fortune&quot; and an
instance of that leaf in leaves.yml named &quot;MyFortune&quot;. If you
name your database connection either &quot;Fortune&quot; or
&quot;MyFortune&quot; (or &quot;fortune&quot; or &quot;my_fortune&quot;),
it will automatically be associated with that leaf. What this means is that
for the leaf&#8217;s command methods (such as <tt>about_command</tt>) and
invoked methods (such as <tt>did_receive_private_message</tt>), the
database connection will already be set for you, and you can start using
your DataMapper objects just like ActiveRecord objects.
</p>
<p>
If, on the other hand, you either <b>named your database connection
differently from your leaf or subclass name</b> or you <b>are writing a
method outside of the normal flow of leaf methods</b> (for instance, one
that is directly called by a Stem, or a different listener), you will need
to call the <tt>database</tt> method and pass it a block containing your
code.
</p>
<p>
This is terribly confusing, so let me give you an example. Let&#8217;s
assume you&#8217;ve got a fortune bot running a leaf named
&quot;FortuneLeaf&quot;, so your leaves.yml configuration is:
</p>
<pre class="code">
 <span class='FortuneBot constant id'>FortuneBot</span><span class='colon op'>:</span>
   <span class='class class kw'>class</span><span class='colon op'>:</span> <span class='FortuneLeaf constant id'>FortuneLeaf</span>
</pre>
<p>
And you have a database connection for that leaf, named after the
leaf&#8217;s class:
</p>
<pre class="code">
 <span class='fortune_leaf identifier id'>fortune_leaf</span><span class='colon op'>:</span>
   <span class='adapter identifier id'>adapter</span><span class='colon op'>:</span> <span class='sqlite3 identifier id'>sqlite3</span>
   <span class='database identifier id'>database</span><span class='colon op'>:</span> <span class='leaves identifier id'>leaves</span><span class='div op'>/</span><span class='fortune_leaf identifier id'>fortune_leaf</span><span class='div op'>/</span><span class='data identifier id'>data</span><span class='div op'>/</span><span class='development identifier id'>development</span><span class='dot token'>.</span><span class='db identifier id'>db</span>
</pre>
<p>
Let&#8217;s further assume you have a simple DataMapper object:
</p>
<pre class="code">
 <span class='class class kw'>class</span> <span class='Fortune constant id'>Fortune</span>
   <span class='include identifier id'>include</span> <span class='DataMapper constant id'>DataMapper</span><span class='colon2 op'>::</span><span class='Resource constant id'>Resource</span>
   <span class='property identifier id'>property</span> <span class='symbol val'>:id</span><span class='comma token'>,</span> <span class='Integer constant id'>Integer</span><span class='comma token'>,</span> <span class='symbol val'>:serial</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='true true kw'>true</span>
   <span class='property identifier id'>property</span> <span class='symbol val'>:text</span><span class='comma token'>,</span> <span class='String constant id'>String</span>
 <span class='end end kw'>end</span>
</pre>
<p>
Now, if we wanted to write a &quot;!fortune&quot; command, it would appear
something like this:
</p>
<pre class="code">
 <span class='def def kw'>def</span> <span class='fortune_command identifier id'>fortune_command</span><span class='lparen token'>(</span><span class='stem identifier id'>stem</span><span class='comma token'>,</span> <span class='sender identifier id'>sender</span><span class='comma token'>,</span> <span class='reply_to identifier id'>reply_to</span><span class='comma token'>,</span> <span class='msg identifier id'>msg</span><span class='rparen token'>)</span>
   <span class='fortunes identifier id'>fortunes</span> <span class='assign token'>=</span> <span class='Fortune constant id'>Fortune</span><span class='dot token'>.</span><span class='all identifier id'>all</span>
   <span class='fortunes identifier id'>fortunes</span><span class='lbrack token'>[</span><span class='rand identifier id'>rand</span><span class='lparen token'>(</span><span class='fortunes identifier id'>fortunes</span><span class='dot token'>.</span><span class='size identifier id'>size</span><span class='rparen token'>)</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='text identifier id'>text</span>
 <span class='end end kw'>end</span>
</pre>
<p>
Autumn automatically knows to execute this DataMapper code in the correct
database context. It knows this because your leaf&#8217;s name is
<tt>FortuneLeaf</tt>, and your database context is named the same.
</p>
<p>
But what if you wanted to use that connection for other leaves too, so you
named it something like &quot;local_database&quot;? Now, Autumn won&#8217;t
be able to guess that you want to use that DB context, so you have to
specify it manually:
</p>
<pre class="code">
 <span class='def def kw'>def</span> <span class='fortune_command identifier id'>fortune_command</span><span class='lparen token'>(</span><span class='stem identifier id'>stem</span><span class='comma token'>,</span> <span class='sender identifier id'>sender</span><span class='comma token'>,</span> <span class='reply_to identifier id'>reply_to</span><span class='comma token'>,</span> <span class='msg identifier id'>msg</span><span class='rparen token'>)</span>
   <span class='database identifier id'>database</span><span class='lparen token'>(</span><span class='symbol val'>:local_database</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
     <span class='fortunes identifier id'>fortunes</span> <span class='assign token'>=</span> <span class='Fortune constant id'>Fortune</span><span class='dot token'>.</span><span class='all identifier id'>all</span>
     <span class='return return kw'>return</span> <span class='fortunes identifier id'>fortunes</span><span class='lbrack token'>[</span><span class='rand identifier id'>rand</span><span class='lparen token'>(</span><span class='fortunes identifier id'>fortunes</span><span class='dot token'>.</span><span class='size identifier id'>size</span><span class='rparen token'>)</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='text identifier id'>text</span>
   <span class='end end kw'>end</span>
 <span class='end end kw'>end</span>
</pre>
<p>
If that is too tedious, you can specify the database connection manually in
the leaves.yml file:
</p>
<pre class="code">
 <span class='FortuneBot constant id'>FortuneBot</span><span class='colon op'>:</span>
   <span class='class class kw'>class</span><span class='colon op'>:</span> <span class='FortuneLeaf constant id'>FortuneLeaf</span>
   <span class='database identifier id'>database</span><span class='colon op'>:</span> <span class='local_database identifier id'>local_database</span>
</pre>
<p>
OK, now onto the second special case. Imagine you want your fortune bot to
also send a fortune in response to a CTCP VERSION request. So, you&#8217;d
implement a method like so:
</p>
<pre class="code">
 <span class='def def kw'>def</span> <span class='ctcp_version_request identifier id'>ctcp_version_request</span><span class='lparen token'>(</span><span class='handler identifier id'>handler</span><span class='comma token'>,</span> <span class='stem identifier id'>stem</span><span class='comma token'>,</span> <span class='sender identifier id'>sender</span><span class='comma token'>,</span> <span class='arguments identifier id'>arguments</span><span class='rparen token'>)</span>
   <span class='fortune identifier id'>fortune</span> <span class='assign token'>=</span> <span class='random_fortune identifier id'>random_fortune</span> <span class='comment val'># Loads a random fortune</span>
   <span class='send_ctcp_reply identifier id'>send_ctcp_reply</span> <span class='stem identifier id'>stem</span><span class='comma token'>,</span> <span class='sender identifier id'>sender</span><span class='lbrack token'>[</span><span class='symbol val'>:nick</span><span class='rbrack token'>]</span><span class='comma token'>,</span> <span class='string val'>'VERSION'</span><span class='comma token'>,</span> <span class='fortune identifier id'>fortune</span><span class='dot token'>.</span><span class='text identifier id'>text</span>
 <span class='end end kw'>end</span>
</pre>
<p>
This will break &#8212; why? Because the <tt>ctcp_version_request</tt>
method is in the realm of the Autumn::CTCP class, <em>not</em> the
Autumn::Leaf class. (You can see this by investigating the CTCP class docs;
it shows you what methods you can implement for CTCP support.) Basically,
the <tt>CTCP</tt> class calls your method directly, giving the Autumn::Leaf
class no chance to set up the database first. So to fix it, make a call to
<tt>database</tt> first:
</p>
<pre class="code">
 <span class='def def kw'>def</span> <span class='ctcp_version_request identifier id'>ctcp_version_request</span><span class='lparen token'>(</span><span class='handler identifier id'>handler</span><span class='comma token'>,</span> <span class='stem identifier id'>stem</span><span class='comma token'>,</span> <span class='sender identifier id'>sender</span><span class='comma token'>,</span> <span class='arguments identifier id'>arguments</span><span class='rparen token'>)</span>
   <span class='fortune identifier id'>fortune</span> <span class='assign token'>=</span> <span class='database identifier id'>database</span> <span class='lbrace token'>{</span> <span class='random_fortune identifier id'>random_fortune</span> <span class='rbrace token'>}</span>
   <span class='send_ctcp_reply identifier id'>send_ctcp_reply</span> <span class='stem identifier id'>stem</span><span class='comma token'>,</span> <span class='sender identifier id'>sender</span><span class='lbrack token'>[</span><span class='symbol val'>:nick</span><span class='rbrack token'>]</span><span class='comma token'>,</span> <span class='string val'>'VERSION'</span><span class='comma token'>,</span> <span class='fortune identifier id'>fortune</span><span class='dot token'>.</span><span class='text identifier id'>text</span>
 <span class='end end kw'>end</span>
</pre>
<p>
This will execute those methods in the scope of the database connection
guessed by Autumn::Leaf. Of course, you can manually pass in a connection
name if necessary.
</p>
<p>
<b>Another important note:</b> You will need to make a call to @database@
in any child threads your leaf creates. The database context is not
automatically carried over to such threads.
</p>
<h3>Your Leaf&#8217;s Module; or, &quot;What Do I Do About Namespace Conflicts?&quot;</h3>
<p>
So, if you have two database-backed leaves, it&#8217;s entirely likely that
both of them will use some sort of DataMapper resource named
<tt>Channel</tt>, or something similar. You can&#8217;t define the class
<tt>Channel</tt> twice in two different ways, so how do you deal with this?
</p>
<p>
The answer is: It&#8217;s already dealt with for you. Go ahead and define
the class twice. Or three times.
</p>
<p>
The longer explanation is: Secretly, behind the scenes, <b>all your leaf
code is being cleverly loaded into a module named after your leaf</b>. So,
when, in your controller.rb code, it says <tt>class Controller &lt;
Autumn::Leaf</tt>, you should read it as <tt>class MyLeafName::Controller
&lt; Autumn::Leaf</tt>. When you define your model with <tt>class
Channel</tt>, it&#8217;s really read as <tt>class MyLeafName::Channel</tt>.
</p>
<p>
Don&#8217;t worry about table names or associations or anything, either.
Just go ahead and use it as if it weren&#8217;t in a module. The
libs/datamapper_hacks.rb file has all the necessary code changes to make
this bit of trickery work.
</p>
<h3>Using Support Modules</h3>
<p>
Helper modules placed in your leaf&#8217;s helpers directory will
automatically be loaded and included in your leaf controller and views. To
create a helper module, place Ruby files to be loaded into the helpers
directory. Make sure your helper modules&#8217; names end with the word
&quot;Helper&quot;.
</p>
<p>
For instance, if your leaf&#8217;s name is &quot;Fortune&quot;, and you
needed two helpers, a database helper and a network helper, you could
create two modules named <tt>DatabaseHelper</tt> and
<tt>NetworkHelper</tt>. Any modules named in this fashion and placed in the
helpers subdirectory will be loaded and appended to the controller and its
views automatically.
</p>
<h3>Loading libraries</h3>
<p>
Files placed in your leaf&#8217;s lib directory will be loaded and run
before your leaf&#8217;s controller, helpers, and views are parsed. You can
place any gem dependencies in this file, or preload any class definitions.
</p>
<h3>Debugging Your Leaf</h3>
<p>
If you make a simple code change to your leaf, you can reload it without
having to restart the whole process. See the Autumn::Leaf#reload_command
documentation for more information on when and how you can reload your
leaf&#8217;s code.
</p>
<p>
If an error occurs on a live production instance, it will be logged to the
log file for your season. You can inspect the log file to determine what
went wrong.
</p>
<p>
If the error happens before the logger is available, oftentimes it will
appear in the autumn.output or autumn.log files. These files are generated
by the daemon library and note any uncaught exceptions or standard outs.
They are in the tmp directory.
</p>
<p>
The most tricky of errors can happen before the process is daemonized. If
your process is quitting prematurely, and you don&#8217;t see anything in
either log file, consider running <tt>script/server</tt>, allowing you to
see any exceptions for yourself.
</p>
<p>
Unfortunately, it&#8217;s still possible that the bug might not appear when
you do this, but only appear when the process is daemonized. In this
situation, I&#8217;d recommend installing rdebug (<tt>sudo gem install
rdebug</tt>) and stepping through the code to figure out what&#8217;s going
wrong. In particular, make sure you step into the <tt>Foliater</tt>&#8217;s
<tt>start_stems</tt> method, when it creates the new threads. It&#8217;s
possible your exception will rear its head once you step into that line of
code.
</p>
<h2>Stems</h2>
<p>
Autumn::Stem is a full-featured IRC client library, written from the ground
up for Autumn. It makes extensive use of implicit protocols, meaning that
most features are accessed by implementing the methods you feel are
necessary.
</p>
<p>
Most of the time, you will only work with stems indirectly via leaves. For
instance, if you want an &quot;!opped&quot; command that returns true if
the sender is an operator, it would look like this:
</p>
<pre class="code">
 <span class='def def kw'>def</span> <span class='opped_command identifier id'>opped_command</span><span class='lparen token'>(</span><span class='stem identifier id'>stem</span><span class='comma token'>,</span> <span class='sender identifier id'>sender</span><span class='comma token'>,</span> <span class='reply_to identifier id'>reply_to</span><span class='comma token'>,</span> <span class='msg identifier id'>msg</span><span class='rparen token'>)</span>
   <span class='stem identifier id'>stem</span><span class='dot token'>.</span><span class='channel_members identifier id'>channel_members</span><span class='lbrack token'>[</span><span class='reply_to identifier id'>reply_to</span><span class='rbrack token'>]</span><span class='lbrack token'>[</span><span class='sender identifier id'>sender</span><span class='lbrack token'>[</span><span class='symbol val'>:nick</span><span class='rbrack token'>]</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='symbol val'>:operator</span> <span class='question op'>?</span> <span class='string val'>&quot;You are opped.&quot;</span> <span class='colon op'>:</span> <span class='string val'>&quot;You are not opped.&quot;</span>
 <span class='end end kw'>end</span>
</pre>
<p>
Let&#8217;s break this down. In order to figure out if someone is opped or
not, we need three pieces of information: their nick, the channel they are
in, and the IRC server they are connected to.
</p>
<p>
The <tt>stem</tt> parameter contains the Autumn::Stem instance that
received this message. It is our link to that server. Through it we can
perform IRC actions and make requests.
</p>
<p>
Autumn::Stem includes an attribute <tt>channel_members</tt>, a hash of
channels mapped to their members. The channel that received the message is
passed via the <tt>reply_to</tt> parameter. So we call
<tt>channel_members[reply_to]</tt> and we receive a hash of member names to
their privilege levels. The <tt>sender</tt> parameter contains information
about the person who sent the command, including their nick. So we use
their nick to resolve their privilege level.
</p>
<p>
Complicated? Sure it is. That&#8217;s the price we pay for separating stems
from leaves. But what if you, like probably 90% of the people out there who
use Autumn, only have one stem? Why should you have to call the same damn
stem each and every time?
</p>
<p>
Fortunately, your pleas are not in vain. For leaves that run off only one
stem, the stem&#8217;s methods are rolled right into the leaf. So, that
&quot;!opped&quot; command method becomes:
</p>
<pre class="code">
 <span class='def def kw'>def</span> <span class='opped_command identifier id'>opped_command</span><span class='lparen token'>(</span><span class='stem identifier id'>stem</span><span class='comma token'>,</span> <span class='sender identifier id'>sender</span><span class='comma token'>,</span> <span class='reply_to identifier id'>reply_to</span><span class='comma token'>,</span> <span class='msg identifier id'>msg</span><span class='rparen token'>)</span>
   <span class='channel_members identifier id'>channel_members</span><span class='lbrack token'>[</span><span class='reply_to identifier id'>reply_to</span><span class='rbrack token'>]</span><span class='lbrack token'>[</span><span class='sender identifier id'>sender</span><span class='lbrack token'>[</span><span class='symbol val'>:nick</span><span class='rbrack token'>]</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='symbol val'>:operator</span> <span class='question op'>?</span> <span class='string val'>&quot;You are opped.&quot;</span> <span class='colon op'>:</span> <span class='string val'>&quot;You are not opped.&quot;</span>
 <span class='end end kw'>end</span>
</pre>
<p>
OK, so it&#8217;s not like a world-class improvement, but it helps.
</p>
<p>
The primary thing your leaf will probably do with a Stem instance is use it
to send messages, like so:
</p>
<pre class="code">
 <span class='def def kw'>def</span> <span class='about_command identifier id'>about_command</span><span class='lparen token'>(</span><span class='stem identifier id'>stem</span><span class='comma token'>,</span> <span class='sender identifier id'>sender</span><span class='comma token'>,</span> <span class='reply_to identifier id'>reply_to</span><span class='comma token'>,</span> <span class='msg identifier id'>msg</span><span class='rparen token'>)</span>
   <span class='stem identifier id'>stem</span><span class='dot token'>.</span><span class='message identifier id'>message</span> <span class='string val'>&quot;I am a pretty awesome bot!&quot;</span><span class='comma token'>,</span> <span class='reply_to identifier id'>reply_to</span>
 <span class='end end kw'>end</span>
</pre>
<p>
Fortunately, if you just return a string, Autumn::Leaf will automatically
send it for you, simplifying our method:
</p>
<pre class="code">
 <span class='def def kw'>def</span> <span class='about_command identifier id'>about_command</span><span class='lparen token'>(</span><span class='stem identifier id'>stem</span><span class='comma token'>,</span> <span class='sender identifier id'>sender</span><span class='comma token'>,</span> <span class='reply_to identifier id'>reply_to</span><span class='comma token'>,</span> <span class='msg identifier id'>msg</span><span class='rparen token'>)</span>
   <span class='string val'>&quot;I am a pretty awesome bot!&quot;</span>
 <span class='end end kw'>end</span>
</pre>
<p>
You would still interact with the stem directly if you wanted to do
something like announce your leaf&#8217;s presence to everyone. To do this,
you&#8217;d have to send a message to every channel of every stem the leaf
is a listener for:
</p>
<pre class="code">
 <span class='stems identifier id'>stems</span><span class='dot token'>.</span><span class='each identifier id'>each</span> <span class='lbrace token'>{</span> <span class='bitor op'>|</span><span class='stem identifier id'>stem</span><span class='bitor op'>|</span> <span class='stem identifier id'>stem</span><span class='dot token'>.</span><span class='channels identifier id'>channels</span><span class='dot token'>.</span><span class='each identifier id'>each</span> <span class='lbrace token'>{</span> <span class='bitor op'>|</span><span class='channel identifier id'>channel</span><span class='bitor op'>|</span> <span class='stem identifier id'>stem</span><span class='dot token'>.</span><span class='message identifier id'>message</span> <span class='string val'>&quot;Hello!&quot;</span><span class='comma token'>,</span> <span class='channel identifier id'>channel</span> <span class='rbrace token'>}</span> <span class='rbrace token'>}</span>
</pre>
<p>
But! Autumn::Stem#message will automatically send a message to every
channel if you don&#8217;t specify any channels, simplifying our code to:
</p>
<pre class="code">
 <span class='stems identifier id'>stems</span><span class='dot token'>.</span><span class='each identifier id'>each</span> <span class='lbrace token'>{</span> <span class='bitor op'>|</span><span class='stem identifier id'>stem</span><span class='bitor op'>|</span> <span class='stem identifier id'>stem</span><span class='dot token'>.</span><span class='message identifier id'>message</span> <span class='string val'>&quot;Hello!&quot;</span> <span class='rbrace token'>}</span>
</pre>
<p>
It gets even better. <b>You can call methods on the <tt>stems</tt> array as
if it were a stem itself!</b> This simplifies the line significantly:
</p>
<pre class="code">
 <span class='stems identifier id'>stems</span><span class='dot token'>.</span><span class='message identifier id'>message</span> <span class='string val'>&quot;Hello!&quot;</span>
</pre>
<p>
Pretty nifty, huh? This also works for functions as well as methods; for
instance, the Autumn::Stem#ready? function, which returns true if a stem is
ready:
</p>
<pre class="code">
 <span class='stems identifier id'>stems</span><span class='dot token'>.</span><span class='ready? fid id'>ready?</span> <span class='comment val'>#=&gt; [ true, true, false, true ] (for example)</span>
</pre>
<h3>The nitty-gritty of stems</h3>
<p>
The section above dealt with stems as they relate to leaves. But when would
you need to deal with a stem directly? Generally, never. However, if you
find that Autumn::Leaf doesn&#8217;t have what you need, you may have to
turn to Autumn::Stem to get the functionality you are looking for. So
let&#8217;s take a look at how Stem works.
</p>
<p>
A stem interacts with interested parties via the listener protocol. Your
leaf signals its interest to a stem by calling Autumn::Stem#add_listener.
When a leaf or any other object becomes a stem&#8217;s listener, that stem
then invokes methods on the listener whenever an IRC event occurs.
</p>
<p>
Let&#8217;s take a simple example. Assume you wanted to build a basic
textual IRC client using Stem. You&#8217;d first want to indicate that your
client is a listener:
</p>
<pre class="code">
 <span class='class class kw'>class</span> <span class='MyClient constant id'>MyClient</span>
   <span class='def def kw'>def</span> <span class='initialize identifier id'>initialize</span><span class='lparen token'>(</span><span class='stem identifier id'>stem</span><span class='rparen token'>)</span>
     <span class='@stem ivar id'>@stem</span> <span class='assign token'>=</span> <span class='stem identifier id'>stem</span>
     <span class='@stem ivar id'>@stem</span><span class='dot token'>.</span><span class='add_listener identifier id'>add_listener</span> <span class='self self kw'>self</span>
   <span class='end end kw'>end</span>
 <span class='end end kw'>end</span>
</pre>
<p>
Now the stem will send method calls to your <tt>MyClient</tt> instance
every time an IRC event occurs. None of these methods are required &#8212;
you can implement as few or as many as you want. The different methods that
Stem will send are documented in the Autumn::Stem#add_listener method docs.
One very important method is the <tt>irc_privmsg_event</tt> method.
Let&#8217;s implement it:
</p>
<pre class="code">
 <span class='def def kw'>def</span> <span class='irc_privmsg_event identifier id'>irc_privmsg_event</span><span class='lparen token'>(</span><span class='stem identifier id'>stem</span><span class='comma token'>,</span> <span class='sender identifier id'>sender</span><span class='comma token'>,</span> <span class='arguments identifier id'>arguments</span><span class='rparen token'>)</span>
   <span class='puts identifier id'>puts</span> <span class='dstring node'>&quot;#{arguments[:channel]} &lt;#{sender[:nick]}&gt; #{arguments[:message]}&quot;</span>
 <span class='end end kw'>end</span>
</pre>
<p>
Now we&#8217;ve got the most important part of our IRC client done &#8212;
receiving messages.
</p>
<p>
You can also send IRC events using stem. It&#8217;s simple: Every IRC
command (such as JOIN and PRIVMSG and MODE) has a corresponding method in
Stem (such as <tt>join</tt> and <tt>privmsg</tt> and <tt>mode</tt>). These
methods aren&#8217;t in the API docs because they&#8217;re implemented
using <tt>method_missing</tt>. Their arguments are exactly the same as the
arguments the IRC command expects, and in the same order.
</p>
<p>
So how do we send a message? Well according to RFC-1459, the basic IRC
spec, the PRIVMSG command takes two arguments: a list of receivers, and the
text to be sent. So, we know our method call should look something like
this:
</p>
<pre class="code">
 <span class='@stem ivar id'>@stem</span><span class='dot token'>.</span><span class='privmsg identifier id'>privmsg</span> <span class='recipient identifier id'>recipient</span><span class='comma token'>,</span> <span class='message identifier id'>message</span>
</pre>
<p>
Astute readers will note that the spec shows a <em>list</em> of recipients,
and indeed, you can call the method like so:
</p>
<pre class="code">
 <span class='@stem ivar id'>@stem</span><span class='dot token'>.</span><span class='privmsg identifier id'>privmsg</span> <span class='lbrack token'>[</span> <span class='recipient1 identifier id'>recipient1</span><span class='comma token'>,</span> <span class='recipient2 identifier id'>recipient2</span> <span class='rbrack token'>]</span><span class='comma token'>,</span> <span class='message identifier id'>message</span>
</pre>
<p>
That&#8217;s the basics of how Autumn::Stem works, but there&#8217;s one
other thing worth mentioning, and that&#8217;s listener plugins. The
details are in the Autumn::Stem#add_listener method docs, but the short of
it is that these are special listeners that bestow their powers onto other
listeners.
</p>
<p>
The best example of this is the Autumn::CTCP class. This class is indeed a
Stem listener: It listens to PRIVMSG events from the stem, and checks them
to see if they are CTCP requests. However, it <em>also</em> gives you, the
author of another listener (such as your leaf) the ability to implement
methods according to <em>its</em> protocol.
</p>
<p>
For example, say you wanted to respond to CTCP VERSION requests with your
own version information. You do it like so:
</p>
<pre class="code">
 <span class='def def kw'>def</span> <span class='ctcp_version_request identifier id'>ctcp_version_request</span><span class='lparen token'>(</span><span class='handler identifier id'>handler</span><span class='comma token'>,</span> <span class='stem identifier id'>stem</span><span class='comma token'>,</span> <span class='sender identifier id'>sender</span><span class='comma token'>,</span> <span class='arguments identifier id'>arguments</span><span class='rparen token'>)</span>
   <span class='send_ctcp_reply identifier id'>send_ctcp_reply</span> <span class='stem identifier id'>stem</span><span class='comma token'>,</span> <span class='sender identifier id'>sender</span><span class='lbrack token'>[</span><span class='symbol val'>:nick</span><span class='rbrack token'>]</span><span class='comma token'>,</span> <span class='string val'>'VERSION'</span><span class='comma token'>,</span> <span class='string val'>&quot;AwesomeBot 2.0 by Sancho Sample&quot;</span>
 <span class='end end kw'>end</span>
</pre>
<p>
What&#8217;s going on here? Because the Autumn::CTCP class is a listener
plugin, it is sending its own method calls as well as implementing
Stem&#8217;s method calls. One such call is the
<tt>ctcp_version_request</tt> method, which you can see in the CTCP class
docs. Somewhere deep in the annals of Autumn::Foliater, there is some code
similar to the following:
</p>
<pre class="code">
 <span class='ctcp identifier id'>ctcp</span> <span class='assign token'>=</span> <span class='Autumn constant id'>Autumn</span><span class='colon2 op'>::</span><span class='CTCP constant id'>CTCP</span><span class='dot token'>.</span><span class='new identifier id'>new</span>
 <span class='stem identifier id'>stem</span><span class='dot token'>.</span><span class='add_listener identifier id'>add_listener</span> <span class='ctcp identifier id'>ctcp</span>
</pre>
<p>
Thus, every stem comes pre-fab with a CTCP listener plugin. That plugin is
intercepting PRIVMSG events and checking if they&#8217;re CTCP requests. If
they are, it is invoking methods, such as <tt>ctcp_version_request</tt>, in
all of the stem&#8217;s other listeners, among which is your leaf.
Hopefully you understand how this all fits together.
</p>
<p>
The lesson to take home here is two-fold: Firstly, if you&#8217;d like CTCP
support in your leaf, know that it&#8217;s the Autumn::CTCP class that is
providing the method calls to your leaf, not the Autumn::Stem class.
Secondly, this should hopefully give you some ideas should you want to
write your own listener plugin to enhance Stem&#8217;s functionality.
</p>
<h2>Autumn&#8217;s Logging</h2>
<p>
Autumn uses Ruby&#8217;s Logger class to log; however, it uses
Autumn::LogFacade to prepend additional information to each log entry. The
LogFacade class has the exact same external API as Logger, so you can use
it like a typical Ruby or Ruby on Rails logger. Many objects (such as Leaf
and Stem) include a <tt>logger</tt> attribute:
</p>
<pre class="code">
 <span class='logger identifier id'>logger</span><span class='dot token'>.</span><span class='debug identifier id'>debug</span> <span class='string val'>&quot;Debug statement&quot;</span>
 <span class='logger identifier id'>logger</span><span class='dot token'>.</span><span class='fatal identifier id'>fatal</span> <span class='$! gvar id'>$!</span>
</pre>
<p>
See the LogFacade class docs for details.
</p>
<h2>Tasks</h2>
<p>
The included Rakefile contains a number of useful tasks to help you develop
and deploy your leaves. You can always get a list of tasks by typing
<tt>rake --tasks</tt>. The various commands you can run are:
</p>
<p>
Application tasks:
</p>
<ul>
<li><b>rake app:start</b> - Starts the Autumn daemon in the background.

</li>
<li><b>rake app:stop</b> - Stops the Autumn daemon.

</li>
<li><b>rake app:restart</b> - Reloads the Autumn daemons.

</li>
<li><b>rake app:run</b> - Starts the Autumn daemon in the foreground.

</li>
<li><b>rake app:zap</b> - Forces the daemon to a stopped state. Use this
command if your daemon is not running but script/daemon thinks it still is.

</li>
</ul>
<p>
Database tasks:
</p>
<ul>
<li><b>LEAF=[leaf name] rake db:migrate</b> - Creates all the tables for a
leaf, as specified by the leaf&#8217;s model objects.

</li>
</ul>
<p>
Documentation tasks:
</p>
<ul>
<li><b>rake doc:api</b> - Generates HTML documentation for Autumn, found in the
doc/api directory.

</li>
<li><b>rake doc:leaves</b> - Generates HTML documentation for your leaves,
found in the doc/leaves directory.

</li>
<li><b>rake doc:clear</b> - Removes all HTML documentation.

</li>
</ul>
<p>
Logging tasks:
</p>
<ul>
<li><b>rake log:clear</b> - Clears the log files for all seasons.

</li>
<li><b>rake log:errors</b> - Prints a list of error-level log messages for the
current season, and uncaught exceptions in all seasons.

</li>
</ul>
<h3>Custom leaf tasks</h3>
<p>
You can define your own leaf-specific tasks in the tasks subdirectory
within your leaf&#8217;s directory. Any .rake files there will be loaded by
rake. The tasks will be added within a task-group named after your leaf.
Use Scorekeeper as an example: If you type <tt>rake --tasks</tt>,
you&#8217;ll see one other task, <tt>rake scorekeeper:scores</tt>. The
&quot;scores&quot; task is defined in the
leaves/scorekeeper/tasks/stats.rake file, and placed in the
&quot;scorekeeper&quot; task group by Autumn.
</p>
<p>
Also, if you open that file up, you&#8217;ll notice that you have to refer
to your leaf&#8217;s classes by their <em>full</em> names, including the
leaf module. (See &quot;Your Leaf&#8217;s Module&quot; if you&#8217;re
confused.)
</p>
<h2>Scripts</h2>
<p>
Autumn includes some scripts to help you control it.
</p>
<h3>script/console</h3>
<p>
Bootstraps an IRb console with the Autumn environment configured. Stems and
leaves are accessile from the Foliater instance. DataMapper models can be
used. Does not start any stems (in other words, no actual server login
occurs).
</p>
<p>
Usage: script/console &lt;options&gt;
</p>
<p>
where &lt;options&gt; may contain:
</p>
<table>
<tr><td valign="top"><tt>--irb</tt>:</td><td>Invoke a different Ruby terminal.

</td></tr>
</table>
<p>
You can alter the season by setting the <tt>SEASON</tt> environment
variable.
</p>
<h3>script/daemon</h3>
<p>
Controller for the Autumn daemon. Starts, stops, and manages the daemon.
Must be run from the Autumn root directory.
</p>
<p>
Usage: script/daemon &lt;command&gt; &lt;options&gt; &#8212;
&lt;application options&gt;
</p>
<p>
where &lt;command&gt; is one of:
</p>
<table>
<tr><td valign="top"><tt>start</tt>:</td><td>start an instance of the application

</td></tr>
<tr><td valign="top"><tt>stop</tt>:</td><td>stop all instances of the application

</td></tr>
<tr><td valign="top"><tt>restart</tt>:</td><td>stop all instances and restart them afterwards

</td></tr>
<tr><td valign="top"><tt>run</tt>:</td><td>start the application and stay on top

</td></tr>
<tr><td valign="top"><tt>zap</tt>:</td><td>set the application to a stopped state

</td></tr>
</table>
<p>
and where &lt;options&gt; may contain several of the following:
</p>
<table>
<tr><td valign="top"><tt>-t, --ontop</tt>:</td><td>Stay on top (does not daemonize)

</td></tr>
<tr><td valign="top"><tt>-f, --force</tt>:</td><td>Force operation

</td></tr>
</table>
<p>
Common options:
</p>
<table>
<tr><td valign="top"><tt>-h, --help</tt>:</td><td>Show this message

</td></tr>
<tr><td valign="top"><tt>--version</tt>:</td><td>Show version

</td></tr>
</table>
<h3>script/destroy</h3>
<p>
Destroys the files for leaves, seasons, and other objects of the Autumn
framework.
</p>
<p>
Usage: script/destroy &lt;options&gt; &lt;object&gt; &lt;name&gt;
</p>
<table>
<tr><td valign="top">&lt;object&gt;:</td><td>The object type to destroy. Valid types are &quot;leaf&quot; and
&quot;season&quot;.

</td></tr>
<tr><td valign="top">&lt;name&gt;:</td><td>The name of the object to destroy. For example, you can call
&quot;script/destroy leaf Scorekeeper&quot; to remove a leaf named
Scorekeeper.

</td></tr>
<tr><td valign="top"><tt>--help, -h</tt>:</td><td>Displays this usage information.

</td></tr>
<tr><td valign="top"><tt>--vcs, -c</tt>:</td><td>Remove any created files or directories from the project&#8217;s version
control system. (Autodetects CVS, Git, and Subversion.)

</td></tr>
</table>
<h3>script/generate</h3>
<p>
Generates template files for leaves, seasons, and other Autumn objects.
</p>
<p>
Usage: script/generate &lt;options&gt; &lt;template&gt; &lt;name&gt;
</p>
<table>
<tr><td valign="top">&lt;template&gt;:</td><td>The template to create. Valid templates are &quot;leaf&quot; and
&quot;season&quot;.

</td></tr>
<tr><td valign="top">&lt;name&gt;:</td><td>The name to give the created template. For example, you can call
&quot;script/generate leaf Scorekeeper&quot; to create a leaf named
Scorekeeper.

</td></tr>
<tr><td valign="top"><tt>--help, -h</tt>:</td><td>Displays this usage information.

</td></tr>
<tr><td valign="top"><tt>--vcs, -c</tt>:</td><td>Add any created files or directories to the project&#8217;s version control
system. (Autodetects CVS, Git, and Subversion.)

</td></tr>
</table>
<h3>script/server</h3>
<p>
Runs Autumn from the command line. This script will not exit until all
leaves have exited. You can set the SEASON environment variable to override
the season.
</p>
<h2>Thread Safety</h2>
<p>
Autumn is a multi-threaded IRC client. When a message is received, a new
thread is spawned to process the message. In this thread, the message will
be parsed, and all listener hooks will be invoked, including your
leaf&#8217;s methods. The thread will terminate once the message has been
fully processed and all methods invoked.
</p>
<p>
I have made every effort to ensure that Autumn::Stem and Autumn::Leaf are
thread-safe, as well as other relevant support classes such as
Autumn::CTCP. It is now in your hands to ensure your leaves are
thread-safe! This basically means recognizing that, while your leaf is
churning away at whatever command it received, things can and will change
in the background. If your command requires your leaf to have operator
privileges, write your code under the assumption that operator could be
taken from your leaf in the middle of executing the command. Write data in
critical blocks, use transactions in your database calls &#8230; you know
the deal. Don&#8217;t assume things will be the same between one line of
code and the next.
</p>
<p>
If you require thread synchronization at the expense of performance, you
can use the <tt>:stem_sync</tt> annotation. See the Autumn::Stem class docs
under &quot;Synchronous Methods&quot; for more information.
</p>
<h2>Getting Ready for Deployment</h2>
<p>
There&#8217;s only a few things you need to do once your leaf is ready to
greet the Real World:
</p>
<ol>
<li>Create a new production season. Configure your stems, leaves, and database
as necessary for your production environment.

</li>
<li>In config/global.yml, set the season to your production season.

</li>
<li>If desired, in script/daemon, set the <tt>:monitor</tt> option to true.
This will spawn a monitor process that will relaunch Autumn if it crashes.

</li>
</ol>
<h2>Other Information</h2>
<p>
Please see http://github.com/RISCfuture/autumn/wikis/known-bugs for a list
of known bugs, and
http://github.com/RISCfuture/autumn/wikis/version-history for complete
version history.
</p>
<p>
*<em>Why do you require Facets?</em>, I hear you ask. Facets doesn&#8217;t
add any super awesome new features to Ruby like Daemons or DataMapper does.
It does, however, improve code reuse, and I&#8217;m a big fan of that. Why
should a million different Ruby projects all write the same
<tt>Symbol#to_proc</tt> method or the same <tt>Hash#symbolize_keys</tt>
method? I use Facets because that job has already been done, and staying
DRY means staying DRY <em>between</em> codebases, not just within them.
</p>

</div>
          </div>
        </div>
      </div>                    
    </div>

    <div id="footer">
      <div class="site">
        <div class="info">
          <div class="links">
            <a href="http://github.com/blog/148-github-shirts-now-available">Shirts</a> |
            <a href="http://github.com/blog">Blog</a> |
            <a href="http://support.github.com/">Support</a> |
            <a href="http://github.com/training">Training</a> |
            <a href="http://github.com/contact">Contact</a> |
            <a href="http://groups.google.com/group/github/">Google Group</a> |
            <a href="http://develop.github.com/">API</a> |
            <a href="http://twitter.com/github">Status</a>
          </div>
          <div class="company">
            <span id="_rrt" title="0.64509s from xc88-s00039">GitHub</span>
            is <a href="http://logicalawesome.com/">Logical Awesome</a> 2009 | <a href="http://github.com/site/terms">Terms of Service</a> | <a href="http://github.com/site/privacy">Privacy Policy</a>
          </div>
        </div>
        <div class="sponsor">
          <a href="http://engineyard.com/"><img src="http://github.com/images/modules/footer/engine_yard_logo.png" alt="Engine Yard"></a>
          <div>
            Hosting provided by our<br> partners at Engine Yard
          </div>
        </div>
      </div>
    </div>
    
    <div id="coming_soon" style="display: none;">
      This feature is coming soon.  Sit tight!
    </div>

    <div id="facebox" style="display: none;">       
      <div class="popup">         
        <table>           
          <tbody>             
            <tr>               
              <td class="tl"></td>
              <td class="b"></td>
              <td class="tr"></td>             
            </tr>             
          <tr>               
            <td class="b"></td>               
            <td class="body">                 
              <div class="content"></div>                 
              <div class="footer">                   
                <a href="#" class="close"><img src="http://github.com/facebox/closelabel.gif" title="close" class="close_image"></a>                 
              </div>               
            </td>               
            <td class="b"></td>             
          </tr>             
          <tr>               
            <td class="bl"></td>
            <td class="b"></td>
            <td class="br"></td>             
          </tr>           
        </tbody>         
      </table>       
    </div>     


    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
    var pageTracker = _gat._getTracker("UA-8689483-1");
    pageTracker._trackPageview();
    } catch(err) {}</script>

  </body>
</html>